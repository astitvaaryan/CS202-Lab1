Hash,Message,Filename,Source Code (before),Source Code (current),Diff,LLM Inference (fix type),Rectified Message,MI_Before,CC_Before,LOC_Before,MI_After,CC_After,LOC_After,MI_Change,CC_Change,LOC_Change,Semantic_Similarity,Token_Similarity,Semantic_Class,Token_Class,Classes_Agree
32cc197a81502c30715c9e164006dce6debcd1bf,fixes,requests/core.py,"# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

import httplib
import urllib
import urllib2

import requests.handler

__title__ = 'requests'
__version__ = '0.0.1'
__build__ = 0x000001
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTHOAUTHS = []


class Request(object):
	""""""The :class:`Request` object. It's awesome.
	""""""
	
	_METHODS = ('get', 'head', 'put', 'post', 'delete')
	
	def __init__(self):
		self.headers = dict()
		self.method = None
		self.response = None
		self.auth = None
	
	def __setattr__(self, key, val):
		if key == 'method':
			if not val.lower() in _METHODS:
				raise InvalidMethod()
		
	def send(self):
		""""""Sends the request. """"""
		#set self.response
		# return True / False
		

class Response(object):
	""""""The :class:`Request` object. It's awesome.
	""""""
	
	def __init__(self):
		self.content = None
		self.status_code = None
		self.headers = dict()
		
	
class AuthObject(object):
	""""""The :class:`AuthObject` is a simple HTTP Authentication token.
	
	:param username: Username to authenticate with.
    :param password: Password for given username.
	 """"""
	
	def __init__(self, username, password):
		self.username = username
		self.password = password



def get(url, params={}, headers={}, auth=None):
	""""""Sends a GET request. Returns :class:`Response` object.
	""""""
	r = Request()
	
	r.url = url
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	r.method = 'GET'
	r.send()
	
	return r.response
	
	# return response object


def head(url, params={}, headers={}, auth=None):
	""""""Sends a HEAD request. Returns :class:`Response` object.
	""""""
	pass
	# return response object


def post(url, params={}, headers={}, auth=None):
	""""""Sends a POST request. Returns :class:`Response` object.
	""""""
	pass
	# return response object
	
	
def put(url, data='', headers={}, auth=None):
	""""""Sends a PUT request. Returns :class:`Response` object.
	""""""
	pass
	# return response object

	
def delete(url, params={}, headers={}, auth=None):
	""""""Sends a DELETE request. Returns :class:`Response` object.
	""""""
	pass
	# return response object


def add_autoauth(url, authobject):
	global AUTOAUTHS
	
	AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):

	return _get_autoauth(url) if not auth else auth

	
def _get_autoauth(url):
	for (authauth_url, auth) in AUTOAUTHS:
		if autoauth_url in url: 
			return auth
			
	return None

class RequestException(Exception):
	""""""There was an ambiguous exception that occured while handling your request.""""""

class AuthenticationError(RequestException):
	""""""The authentication credentials provided were invalid.""""""
	
class URLRequired(RequestException):
	""""""A valid URL is required to make a request.""""""
	
class InvalidMethod(RequestException):
	""""""An inappropriate method was attempted.""""""
	","# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

import httplib
import urllib
import urllib2
import urlparse


__title__ = 'requests'
__version__ = '0.0.1'
__build__ = 0x000001
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []


class Request(object):
	""""""The :class:`Request` object. It's awesome.
	""""""
	
	_METHODS = ('get', 'head', 'put', 'post', 'delete')
	
	def __init__(self):
		self.headers = dict()
		self.method = None
		self.response = Response()
		self.auth = None
		
	
	def __setattr__(self, name, value):
		if (name == 'method') and (value):
			if not value.lower() in self._METHODS:
				raise InvalidMethod()
		
		object.__setattr__(self, name, value)
		
		
	def send(self):
		""""""Sends the request. """"""
		#set self.response

		# return True / False
		

class Response(object):
	""""""The :class:`Request` object. It's awesome.
	""""""
	
	def __init__(self):
		self.content = None
		self.status_code = None
		self.headers = dict()
		
	
class AuthObject(object):
	""""""The :class:`AuthObject` is a simple HTTP Authentication token.
	
	:param username: Username to authenticate with.
    :param password: Password for given username.
	 """"""
	
	def __init__(self, username, password):
		self.username = username
		self.password = password



def get(url, params={}, headers={}, auth=None):
	""""""Sends a GET request. Returns :class:`Response` object.
	""""""
	r = Request()
	
	r.method = 'GET'
	r.url = url
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def head(url, params={}, headers={}, auth=None):
	""""""Sends a HEAD request. Returns :class:`Response` object.
	""""""
	r = Request()
	
	r.method = 'HEAD'
	# return response object
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def post(url, params={}, headers={}, auth=None):
	""""""Sends a POST request. Returns :class:`Response` object.
	""""""
	r = Request()
	
	r.method = 'POST'
	# return response object
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response
	
	
def put(url, data='', headers={}, auth=None):
	""""""Sends a PUT request. Returns :class:`Response` object.
	""""""
	r = Request()
	
	r.method = 'PUT'
	# return response object
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response

	
def delete(url, params={}, headers={}, auth=None):
	""""""Sends a DELETE request. Returns :class:`Response` object.
	""""""
	r = Request()
	
	r.method = 'DELETE'
	# return response object
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def add_autoauth(url, authobject):
	global AUTOAUTHS
	
	AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):

	return _get_autoauth(url) if not auth else auth

	
def _get_autoauth(url):
	for (authauth_url, auth) in AUTOAUTHS:
		if autoauth_url in url: 
			return auth
			
	return None

class RequestException(Exception):
	""""""There was an ambiguous exception that occured while handling your request.""""""

class AuthenticationError(RequestException):
	""""""The authentication credentials provided were invalid.""""""
	
class URLRequired(RequestException):
	""""""A valid URL is required to make a request.""""""
	
class InvalidMethod(RequestException):
	""""""An inappropriate method was attempted.""""""
	","@@ -13,8 +13,8 @@
 import httplib
 import urllib
 import urllib2
+import urlparse
 
-import requests.handler
 
 __title__ = 'requests'
 __version__ = '0.0.1'
@@ -24,7 +24,7 @@ __license__ = 'ISC'
 __copyright__ = 'Copyright 2011 Kenneth Reitz'
 
 
-AUTHOAUTHS = []
+AUTOAUTHS = []
 
 
 class Request(object):
@@ -36,17 +36,22 @@ class Request(object):
 	def __init__(self):
 		self.headers = dict()
 		self.method = None
-		self.response = None
+		self.response = Response()
 		self.auth = None
+		
 	
-	def __setattr__(self, key, val):
-		if key == 'method':
-			if not val.lower() in _METHODS:
+	def __setattr__(self, name, value):
+		if (name == 'method') and (value):
+			if not value.lower() in self._METHODS:
 				raise InvalidMethod()
 		
+		object.__setattr__(self, name, value)
+		
+		
 	def send(self):
 		""""""Sends the request. """"""
 		#set self.response
+
 		# return True / False
 		
 
@@ -78,43 +83,78 @@ def get(url, params={}, headers={}, auth=None):
 	""""""
 	r = Request()
 	
+	r.method = 'GET'
 	r.url = url
 	r.headers = headers
 	r.auth = _detect_auth(url, auth)
-	r.method = 'GET'
+	
 	r.send()
 	
 	return r.response
-	
-	# return response object
 
 
 def head(url, params={}, headers={}, auth=None):
 	""""""Sends a HEAD request. Returns :class:`Response` object.
 	""""""
-	pass
+	r = Request()
+	
+	r.method = 'HEAD'
 	# return response object
+	
+	r.headers = headers
+	r.auth = _detect_auth(url, auth)
+	
+	r.send()
+	
+	return r.response
 
 
 def post(url, params={}, headers={}, auth=None):
 	""""""Sends a POST request. Returns :class:`Response` object.
 	""""""
-	pass
+	r = Request()
+	
+	r.method = 'POST'
 	# return response object
 	
+	r.headers = headers
+	r.auth = _detect_auth(url, auth)
+	
+	r.send()
+	
+	return r.response
+	
 	
 def put(url, data='', headers={}, auth=None):
 	""""""Sends a PUT request. Returns :class:`Response` object.
 	""""""
-	pass
+	r = Request()
+	
+	r.method = 'PUT'
 	# return response object
+	
+	r.headers = headers
+	r.auth = _detect_auth(url, auth)
+	
+	r.send()
+	
+	return r.response
 
 	
 def delete(url, params={}, headers={}, auth=None):
 	""""""Sends a DELETE request. Returns :class:`Response` object.
 	""""""
-	pass
+	r = Request()
+	
+	r.method = 'DELETE'
 	# return response object
+	
+	r.headers = headers
+	r.auth = _detect_auth(url, auth)
+	
+	r.send()
+	
+	return r.response
 
 
 def add_autoauth(url, authobject):
",add missing docstrings,[requests/core.py] add missing docstrings,75.10723675046175,11.0,149.0,70.61664833323248,11.0,189.0,-4.490588417229276,0.0,40.0,0.999800443649292,0.7852281096089756,Minor,Minor,YES
3c32045da05cda554e65d3b943bb1128b2482c7f,FIXED,requests/core.py,"# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

import httplib
import urllib
import urllib2
import urlparse


__title__ = 'requests'
__version__ = '0.0.1'
__build__ = 0x000001
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []


class _Request(urllib2.Request):
    def __init__(self, url, data=None, headers={},
                 origin_req_host=None, unverifiable=False, method=None):
       urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
       self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
	""""""The :class:`Request` object. It's awesome.
	""""""
	
	_METHODS = ('get', 'head', 'put', 'post', 'delete')
	
	def __init__(self):
		self.url = None
		self.headers = dict()
		self.method = None
		self.params = {}
		self.data = {}
		self.response = Response()
		self.auth = None
		self.sent = False
		
	
	def __setattr__(self, name, value):
		if (name == 'method') and (value):
			if not value.lower() in self._METHODS:
				raise InvalidMethod()
		
		object.__setattr__(self, name, value)
	
	
	def _checks(self):
		pass

	
	def _get_opener(self):
		"""""" Creates appropriate opener object for urllib2.
		""""""
		
		if self.auth:

			# create a password manager
			authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

			authr.add_password(None, self.url, self.auth.username, self.auth.password)
			handler = urllib2.HTTPBasicAuthHandler(authr)
			opener = urllib2.build_opener(handler)

			# use the opener to fetch a URL
			return opener.open
		else:
			return urllib2.urlopen

	
	def send(self, anyway=False):
		""""""Sends the request. 
		
		   :param anyway: If True, request will be sent, even if it has already been sent.
		""""""
		self._checks()
		
		if self.method.lower() in ('get', 'head'):
			if (not self.sent) or anyway:
				try:
					# url encode GET params if it's a dict
					if isinstance(self.params, dict):
						params = urllib.urlencode(self.params)
					else:

						params = self.params

					if self.method.lower() == 'get':
						req = _Request((""%s?%s"" % (self.url, params)), method='GET')
					else:
						req = _Request((""%s?%s"" % (self.url, params)), method='HEAD')

					if self.headers:
						req.headers = self.headers

					opener = self._get_opener()
					resp = opener(req)

					self.response.status_code = resp.code
					self.response.headers = resp.info().dict
					if self.method.lower() == 'get':
						self.response.content = resp.read()

					success = True

				except RequestException:
					raise RequestException
				

		elif self.method.lower() == 'put':
			if (not self.sent) or anyway:
				try:

					req = _Request(self.url, method='PUT')
					req.data = self.data
					
#					if self.method.lower() == 'head':
#						req.get_method = lambda : 'PUT'

					if self.headers:
						req.headers = self.headers

					opener = self._get_opener()
					resp = opener(req)

					self.response.status_code = resp.code
					self.response.headers = resp.info().dict
					if self.method.lower() == 'get':
						self.response.content = resp.read()

					success = True


				except RequestException:
					raise RequestException
			
		elif self.method.lower() == 'post':
			if (not self.sent) or anyway:
				try:

					req = urllib2.Request(self.url)

					if self.headers:
						r.headers = self.headers

					# url encode form data if it's a dict
					if isinstance(self.data, dict):
						req.data = urllib.urlencode(self.data)
					else:
						req.data = self.data


					if self.auth:

						# create a password manager
						password_mgr = urllib2.HTTPPasswordMgrWithDefaultRealm()

						# Add the username and password.
						# If we knew the realm, we could use it instead of ``None``.
						password_mgr.add_password(None, self.url, self.auth.username, self.auth.password)
						handler = urllib2.HTTPBasicAuthHandler(password_mgr)
						opener = urllib2.build_opener(handler)

						# use the opener to fetch a URL
						resp = opener.open(req)
					else:
						resp =  urllib2.urlopen(req)

					self.response.status_code = resp.code
					self.response.headers = resp.info().dict
					self.response.content = resp.read()
					
					success = True

				except Exception:
					raise RequestException

		elif self.method.lower() == 'delete':
			if (not self.sent) or anyway:
				try:
					pass
					
					success = True

				except Exception:
					raise RequestException
			
		else:
			raise InvalidMethod

		
		self.sent = True if success else False
		
		return success
		

class Response(object):
	""""""The :class:`Request` object. It's awesome.
	""""""
	
	def __init__(self):
		self.content = None
		self.status_code = None
		self.headers = dict()
		
	
class AuthObject(object):
	""""""The :class:`AuthObject` is a simple HTTP Authentication token.
	
	:param username: Username to authenticate with.
    :param password: Password for given username.
	 """"""
	
	def __init__(self, username, password):
		self.username = username
		self.password = password



def get(url, params={}, headers={}, auth=None):
	""""""Sends a GET request. Returns :class:`Response` object.
	""""""
	r = Request()
	
	r.method = 'GET'
	r.url = url
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def head(url, params={}, headers={}, auth=None):
	""""""Sends a HEAD request. Returns :class:`Response` object.
	""""""
	r = Request()
	
	r.method = 'HEAD'
	r.url = url
	# return response object
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def post(url, data={}, headers={}, auth=None):
	""""""Sends a POST request. Returns :class:`Response` object.
	""""""
	r = Request()

	r.url = url
	r.method = 'POST'
	r.data = data
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response
	
	
def put(url, data='', headers={}, auth=None):
	""""""Sends a PUT request. Returns :class:`Response` object.
	""""""
	r = Request()

	r.url = url
	r.method = 'PUT'
	r.data = data
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response

	
def delete(url, params={}, headers={}, auth=None):
	""""""Sends a DELETE request. Returns :class:`Response` object.
	""""""
	r = Request()
	
	r.method = 'DELETE'
	# return response object
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def add_autoauth(url, authobject):
	global AUTOAUTHS
	
	AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):

	return _get_autoauth(url) if not auth else auth

	
def _get_autoauth(url):
	for (authauth_url, auth) in AUTOAUTHS:
		if autoauth_url in url: 
			return auth
			
	return None

class RequestException(Exception):
	""""""There was an ambiguous exception that occured while handling your request.""""""

class AuthenticationError(RequestException):
	""""""The authentication credentials provided were invalid.""""""
	
class URLRequired(RequestException):
	""""""A valid URL is required to make a request.""""""
	
class InvalidMethod(RequestException):
	""""""An inappropriate method was attempted.""""""
","# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

import httplib
import urllib
import urllib2
import urlparse


__title__ = 'requests'
__version__ = '0.0.1'
__build__ = 0x000001
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []


class _Request(urllib2.Request):
    def __init__(self, url, data=None, headers={},
                 origin_req_host=None, unverifiable=False, method=None):
       urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
       self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
	""""""The :class:`Request` object. It's awesome.
	""""""
	
	_METHODS = ('get', 'head', 'put', 'post', 'delete')
	
	def __init__(self):
		self.url = None
		self.headers = dict()
		self.method = None
		self.params = {}
		self.data = {}
		self.response = Response()
		self.auth = None
		self.sent = False
		
	
	def __setattr__(self, name, value):
		if (name == 'method') and (value):
			if not value.lower() in self._METHODS:
				raise InvalidMethod()
		
		object.__setattr__(self, name, value)
	
	
	def _checks(self):
		pass

	
	def _get_opener(self):
		"""""" Creates appropriate opener object for urllib2.
		""""""
		
		if self.auth:

			# create a password manager
			authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

			authr.add_password(None, self.url, self.auth.username, self.auth.password)
			handler = urllib2.HTTPBasicAuthHandler(authr)
			opener = urllib2.build_opener(handler)

			# use the opener to fetch a URL
			return opener.open
		else:
			return urllib2.urlopen

	
	def send(self, anyway=False):
		""""""Sends the request. 
		
		   :param anyway: If True, request will be sent, even if it has already been sent.
		""""""
		self._checks()
		
		if self.method.lower() in ('get', 'head', 'delete'):
			if (not self.sent) or anyway:
				try:
					# url encode GET params if it's a dict
					if isinstance(self.params, dict):
						params = urllib.urlencode(self.params)
					else:

						params = self.params

					if self.method.lower() == 'get':
						req = _Request((""%s?%s"" % (self.url, params)), method='GET')
					elif self.method.lower() == 'head':
						req = _Request((""%s?%s"" % (self.url, params)), method='HEAD')
					elif self.method.lower() == 'delete':
						req = _Request((""%s?%s"" % (self.url, params)), method='DELETE')

					if self.headers:
						req.headers = self.headers

					opener = self._get_opener()
					resp = opener(req)

					self.response.status_code = resp.code
					self.response.headers = resp.info().dict
					if self.method.lower() == 'get':
						self.response.content = resp.read()

					success = True

				except Exception:
					raise RequestException
				

		elif self.method.lower() == 'put':
			if (not self.sent) or anyway:

				try:
					try:

						req = _Request(self.url, method='PUT')

						if self.headers:
							req.headers = self.headers

						req.data = self.data

						opener = self._get_opener()
						resp =  opener(req)

						self.response.status_code = resp.code
						self.response.headers = resp.info().dict
						self.response.content = resp.read()

						success = True
					except Exception:
						raise RequestException

				except urllib2.HTTPError:
					self.resonse.status_code = 405

			
		elif self.method.lower() == 'post':
			if (not self.sent) or anyway:
				try:

					req = _Request(self.url, method='POST')

					if self.headers:
						req.headers = self.headers

					# url encode form data if it's a dict
					if isinstance(self.data, dict):
						req.data = urllib.urlencode(self.data)
					else:
						req.data = self.data


					opener = self._get_opener()
					resp =  opener(req)

					self.response.status_code = resp.code
					self.response.headers = resp.info().dict
					self.response.content = resp.read()
					
					success = True

				except Exception:
					raise RequestException

		elif self.method.lower() == 'delete':
			if (not self.sent) or anyway:
				try:
					pass
					
					success = True

				except Exception:
					raise RequestException
			
		else:
			raise InvalidMethod

		
		self.sent = True if success else False
		
		return success
		

class Response(object):
	""""""The :class:`Request` object. It's awesome.
	""""""
	
	def __init__(self):
		self.content = None
		self.status_code = None
		self.headers = dict()
		
	
class AuthObject(object):
	""""""The :class:`AuthObject` is a simple HTTP Authentication token.
	
	:param username: Username to authenticate with.
    :param password: Password for given username.
	 """"""
	
	def __init__(self, username, password):
		self.username = username
		self.password = password



def get(url, params={}, headers={}, auth=None):
	""""""Sends a GET request. Returns :class:`Response` object.
	""""""
	r = Request()
	
	r.method = 'GET'
	r.url = url
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def head(url, params={}, headers={}, auth=None):
	""""""Sends a HEAD request. Returns :class:`Response` object.
	""""""
	r = Request()
	
	r.method = 'HEAD'
	r.url = url
	# return response object
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def post(url, data={}, headers={}, auth=None):
	""""""Sends a POST request. Returns :class:`Response` object.
	""""""
	r = Request()

	r.url = url
	r.method = 'POST'
	r.data = data
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response
	
	
def put(url, data='', headers={}, auth=None):
	""""""Sends a PUT request. Returns :class:`Response` object.
	""""""
	r = Request()

	r.url = url
	r.method = 'PUT'
	r.data = data
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response

	
def delete(url, params={}, headers={}, auth=None):
	""""""Sends a DELETE request. Returns :class:`Response` object.
	""""""
	r = Request()
	
	r.method = 'DELETE'
	# return response object
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def add_autoauth(url, authobject):
	global AUTOAUTHS
	
	AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):

	return _get_autoauth(url) if not auth else auth

	
def _get_autoauth(url):
	for (authauth_url, auth) in AUTOAUTHS:
		if autoauth_url in url: 
			return auth
			
	return None

class RequestException(Exception):
	""""""There was an ambiguous exception that occured while handling your request.""""""

class AuthenticationError(RequestException):
	""""""The authentication credentials provided were invalid.""""""
	
class URLRequired(RequestException):
	""""""A valid URL is required to make a request.""""""
	
class InvalidMethod(RequestException):
	""""""An inappropriate method was attempted.""""""
","@@ -95,7 +95,7 @@ class Request(object):
 		""""""
 		self._checks()
 		
-		if self.method.lower() in ('get', 'head'):
+		if self.method.lower() in ('get', 'head', 'delete'):
 			if (not self.sent) or anyway:
 				try:
 					# url encode GET params if it's a dict
@@ -107,8 +107,10 @@ class Request(object):
 
 					if self.method.lower() == 'get':
 						req = _Request((""%s?%s"" % (self.url, params)), method='GET')
-					else:
+					elif self.method.lower() == 'head':
 						req = _Request((""%s?%s"" % (self.url, params)), method='HEAD')
+					elif self.method.lower() == 'delete':
+						req = _Request((""%s?%s"" % (self.url, params)), method='DELETE')
 
 					if self.headers:
 						req.headers = self.headers
@@ -123,45 +125,46 @@ class Request(object):
 
 					success = True
 
-				except RequestException:
+				except Exception:
 					raise RequestException
 				
 
 		elif self.method.lower() == 'put':
 			if (not self.sent) or anyway:
+
 				try:
+					try:
 
-					req = _Request(self.url, method='PUT')
-					req.data = self.data
-					
-#					if self.method.lower() == 'head':
-#						req.get_method = lambda : 'PUT'
+						req = _Request(self.url, method='PUT')
 
-					if self.headers:
-						req.headers = self.headers
+						if self.headers:
+							req.headers = self.headers
 
-					opener = self._get_opener()
-					resp = opener(req)
+						req.data = self.data
 
-					self.response.status_code = resp.code
-					self.response.headers = resp.info().dict
-					if self.method.lower() == 'get':
+						opener = self._get_opener()
+						resp =  opener(req)
+
+						self.response.status_code = resp.code
+						self.response.headers = resp.info().dict
 						self.response.content = resp.read()
 
-					success = True
+						success = True
+					except Exception:
+						raise RequestException
 
+				except urllib2.HTTPError:
+					self.resonse.status_code = 405
 
-				except RequestException:
-					raise RequestException
 			
 		elif self.method.lower() == 'post':
 			if (not self.sent) or anyway:
 				try:
 
-					req = urllib2.Request(self.url)
+					req = _Request(self.url, method='POST')
 
 					if self.headers:
-						r.headers = self.headers
+						req.headers = self.headers
 
 					# url encode form data if it's a dict
 					if isinstance(self.data, dict):
@@ -170,21 +173,8 @@ class Request(object):
 						req.data = self.data
 
 
-					if self.auth:
-
-						# create a password manager
-						password_mgr = urllib2.HTTPPasswordMgrWithDefaultRealm()
-
-						# Add the username and password.
-						# If we knew the realm, we could use it instead of ``None``.
-						password_mgr.add_password(None, self.url, self.auth.username, self.auth.password)
-						handler = urllib2.HTTPBasicAuthHandler(password_mgr)
-						opener = urllib2.build_opener(handler)
-
-						# use the opener to fetch a URL
-						resp = opener.open(req)
-					else:
-						resp =  urllib2.urlopen(req)
+					opener = self._get_opener()
+					resp =  opener(req)
 
 					self.response.status_code = resp.code
 					self.response.headers = resp.info().dict
",fix linting issues,[requests/core.py] fix linting issues,50.63581777832412,11.0,351.0,49.13001650749881,11.0,341.0,-1.5058012708253088,0.0,-10.0,1.0,0.924428567670054,Minor,Minor,YES
f566bb21400cecf4dfe5a6c7d9bc7fb62abbb57d,Much better exception handling,requests/core.py,"# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

import httplib
import urllib
import urllib2
import urlparse


__title__ = 'requests'
__version__ = '0.0.1'
__build__ = 0x000001
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []


class _Request(urllib2.Request):
    def __init__(self, url, data=None, headers={},
                 origin_req_host=None, unverifiable=False, method=None):
       urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
       self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
	""""""The :class:`Request` object. It's awesome.
	""""""
	
	_METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')
	
	def __init__(self):
		self.url = None
		self.headers = dict()
		self.method = None
		self.params = {}
		self.data = {}
		self.response = Response()
		self.auth = None
		self.sent = False
		
	
	def __setattr__(self, name, value):
		if (name == 'method') and (value):
			if not value in self._METHODS:
				raise InvalidMethod()
		
		object.__setattr__(self, name, value)
	
	
	def _checks(self):
		pass

	
	def _get_opener(self):
		"""""" Creates appropriate opener object for urllib2.
		""""""
		
		if self.auth:

			# create a password manager
			authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

			authr.add_password(None, self.url, self.auth.username, self.auth.password)
			handler = urllib2.HTTPBasicAuthHandler(authr)
			opener = urllib2.build_opener(handler)

			# use the opener to fetch a URL
			return opener.open
		else:
			return urllib2.urlopen

	
	def send(self, anyway=False):
		""""""Sends the request. 
		
		   :param anyway: If True, request will be sent, even if it has already been sent.
		""""""
		self._checks()
		
		if self.method in ('GET', 'HEAD', 'DELETE'):
			if (not self.sent) or anyway:
				try:
					# url encode GET params if it's a dict
					if isinstance(self.params, dict):
						params = urllib.urlencode(self.params)
					else:

						params = self.params

					req = _Request((""%s?%s"" % (self.url, params)), method=self.method)

					if self.headers:
						req.headers = self.headers

					opener = self._get_opener()
					resp = opener(req)

					self.response.status_code = resp.code
					self.response.headers = resp.info().dict
					if self.method.lower() == 'get':
						self.response.content = resp.read()

					success = True

				except RequestException:
					raise RequestException
				

		elif self.method == 'PUT':
			if (not self.sent) or anyway:

				try:
					try:

						req = _Request(self.url, method='PUT')

						if self.headers:
							req.headers = self.headers

						req.data = self.data

						opener = self._get_opener()
						resp =  opener(req)

						self.response.status_code = resp.code
						self.response.headers = resp.info().dict
						self.response.content = resp.read()

						success = True
					except urllib2.HTTPError:
						self.resonse.status_code = 405

				except Exception:
					# TODO: Fix this shit
					raise RequestException


			
		elif self.method == 'POST':
			if (not self.sent) or anyway:
				try:

					req = _Request(self.url, method='POST')

					if self.headers:
						req.headers = self.headers

					# url encode form data if it's a dict
					if isinstance(self.data, dict):
						req.data = urllib.urlencode(self.data)
					else:
						req.data = self.data


					opener = self._get_opener()
					resp =  opener(req)

					self.response.status_code = resp.code
					self.response.headers = resp.info().dict
					self.response.content = resp.read()
					
					success = True

				except Exception:
					raise RequestException

		
		self.sent = True if success else False
		
		return success
		

class Response(object):
	""""""The :class:`Request` object. It's awesome.
	""""""
	
	def __init__(self):
		self.content = None
		self.status_code = None
		self.headers = dict()
		
	
class AuthObject(object):
	""""""The :class:`AuthObject` is a simple HTTP Authentication token.
	
	:param username: Username to authenticate with.
    :param password: Password for given username.
	 """"""
	
	def __init__(self, username, password):
		self.username = username
		self.password = password



def get(url, params={}, headers={}, auth=None):
	""""""Sends a GET request. Returns :class:`Response` object.
	""""""
	r = Request()
	
	r.method = 'GET'
	r.url = url
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def head(url, params={}, headers={}, auth=None):
	""""""Sends a HEAD request. Returns :class:`Response` object.
	""""""
	r = Request()
	
	r.method = 'HEAD'
	r.url = url
	# return response object
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def post(url, data={}, headers={}, auth=None):
	""""""Sends a POST request. Returns :class:`Response` object.
	""""""
	r = Request()

	r.url = url
	r.method = 'POST'
	r.data = data
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response
	
	
def put(url, data='', headers={}, auth=None):
	""""""Sends a PUT request. Returns :class:`Response` object.
	""""""
	r = Request()

	r.url = url
	r.method = 'PUT'
	r.data = data
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response

	
def delete(url, params={}, headers={}, auth=None):
	""""""Sends a DELETE request. Returns :class:`Response` object.
	""""""
	r = Request()

	r.url = url
	r.method = 'DELETE'
	# return response object
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def add_autoauth(url, authobject):
	global AUTOAUTHS
	
	AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):

	return _get_autoauth(url) if not auth else auth

	
def _get_autoauth(url):
	for (authauth_url, auth) in AUTOAUTHS:
		if autoauth_url in url: 
			return auth
			
	return None

class RequestException(Exception):
	""""""There was an ambiguous exception that occured while handling your request.""""""

class AuthenticationError(RequestException):
	""""""The authentication credentials provided were invalid.""""""
	
class URLRequired(RequestException):
	""""""A valid URL is required to make a request.""""""
	
class InvalidMethod(RequestException):
	""""""An inappropriate method was attempted.""""""
","# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

import httplib
import urllib
import urllib2
import urlparse


__title__ = 'requests'
__version__ = '0.0.1'
__build__ = 0x000001
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []


class _Request(urllib2.Request):
    def __init__(self, url, data=None, headers={},
                 origin_req_host=None, unverifiable=False, method=None):
       urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
       self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
	""""""The :class:`Request` object. It's awesome.
	""""""
	
	_METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')
	
	def __init__(self):
		self.url = None
		self.headers = dict()
		self.method = None
		self.params = {}
		self.data = {}
		self.response = Response()
		self.auth = None
		self.sent = False
		
	
	def __setattr__(self, name, value):
		if (name == 'method') and (value):
			if not value in self._METHODS:
				raise InvalidMethod()
		
		object.__setattr__(self, name, value)
	
	
	def _checks(self):
		""""""Deterministic checks for consistiency.""""""

		if not self.url:
			raise URLRequired

		
	def _get_opener(self):
		"""""" Creates appropriate opener object for urllib2.
		""""""
		
		if self.auth:

			# create a password manager
			authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

			authr.add_password(None, self.url, self.auth.username, self.auth.password)
			handler = urllib2.HTTPBasicAuthHandler(authr)
			opener = urllib2.build_opener(handler)

			# use the opener to fetch a URL
			return opener.open
		else:
			return urllib2.urlopen

	
	def send(self, anyway=False):
		""""""Sends the request. 
		
		   :param anyway: If True, request will be sent, even if it has already been sent.
		""""""
		self._checks()

		success = False
		
		if self.method in ('GET', 'HEAD', 'DELETE'):
			if (not self.sent) or anyway:

				# url encode GET params if it's a dict
				if isinstance(self.params, dict):
					params = urllib.urlencode(self.params)
				else:

					params = self.params

				req = _Request((""%s?%s"" % (self.url, params)), method=self.method)

				if self.headers:
					req.headers = self.headers

				opener = self._get_opener()

				try:
					resp = opener(req)
					self.response.status_code = resp.code
					self.response.headers = resp.info().dict
					if self.method.lower() == 'get':
						self.response.content = resp.read()

					success = True
				except urllib2.HTTPError, why:
					self.response.status_code = why.code


		elif self.method == 'PUT':
			if (not self.sent) or anyway:

				req = _Request(self.url, method='PUT')

				if self.headers:
					req.headers = self.headers

				req.data = self.data

				try:
					opener = self._get_opener()
					resp =  opener(req)

					self.response.status_code = resp.code
					self.response.headers = resp.info().dict
					self.response.content = resp.read()

					success = True

				except urllib2.HTTPError, why:
					self.response.status_code = why.code




		elif self.method == 'POST':
			if (not self.sent) or anyway:

				req = _Request(self.url, method='POST')

				if self.headers:
					req.headers = self.headers

				# url encode form data if it's a dict
				if isinstance(self.data, dict):
					req.data = urllib.urlencode(self.data)
				else:
					req.data = self.data

				try:

					opener = self._get_opener()
					resp =  opener(req)

					self.response.status_code = resp.code
					self.response.headers = resp.info().dict
					self.response.content = resp.read()

					success = True

				except urllib2.HTTPError, why:
					self.response.status_code = why.code

		
		self.sent = True if success else False
		
		return success
		

class Response(object):
	""""""The :class:`Request` object. It's awesome.
	""""""

	def __init__(self):
		self.content = None
		self.status_code = None
		self.headers = dict()

	
class AuthObject(object):
	""""""The :class:`AuthObject` is a simple HTTP Authentication token.
	
	:param username: Username to authenticate with.
    :param password: Password for given username.
	 """"""
	
	def __init__(self, username, password):
		self.username = username
		self.password = password



def get(url, params={}, headers={}, auth=None):
	""""""Sends a GET request. Returns :class:`Response` object.
	""""""
	r = Request()
	
	r.method = 'GET'
	r.url = url
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def head(url, params={}, headers={}, auth=None):
	""""""Sends a HEAD request. Returns :class:`Response` object.
	""""""
	r = Request()
	
	r.method = 'HEAD'
	r.url = url
	# return response object
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def post(url, data={}, headers={}, auth=None):
	""""""Sends a POST request. Returns :class:`Response` object.
	""""""
	r = Request()

	r.url = url
	r.method = 'POST'
	r.data = data
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response
	
	
def put(url, data='', headers={}, auth=None):
	""""""Sends a PUT request. Returns :class:`Response` object.
	""""""
	r = Request()

	r.url = url
	r.method = 'PUT'
	r.data = data
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response

	
def delete(url, params={}, headers={}, auth=None):
	""""""Sends a DELETE request. Returns :class:`Response` object.
	""""""
	r = Request()

	r.url = url
	r.method = 'DELETE'
	# return response object
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def add_autoauth(url, authobject):
	global AUTOAUTHS
	
	AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):

	return _get_autoauth(url) if not auth else auth

	
def _get_autoauth(url):
	for (authauth_url, auth) in AUTOAUTHS:
		if autoauth_url in url: 
			return auth
			
	return None

class RequestException(Exception):
	""""""There was an ambiguous exception that occured while handling your request.""""""

class AuthenticationError(RequestException):
	""""""The authentication credentials provided were invalid.""""""
	
class URLRequired(RequestException):
	""""""A valid URL is required to make a request.""""""
	
class InvalidMethod(RequestException):
	""""""An inappropriate method was attempted.""""""
","@@ -66,9 +66,12 @@ class Request(object):
 	
 	
 	def _checks(self):
-		pass
+		""""""Deterministic checks for consistiency.""""""
 
-	
+		if not self.url:
+			raise URLRequired
+
+		
 	def _get_opener(self):
 		"""""" Creates appropriate opener object for urllib2.
 		""""""
@@ -94,81 +97,79 @@ class Request(object):
 		   :param anyway: If True, request will be sent, even if it has already been sent.
 		""""""
 		self._checks()
+
+		success = False
 		
 		if self.method in ('GET', 'HEAD', 'DELETE'):
 			if (not self.sent) or anyway:
-				try:
-					# url encode GET params if it's a dict
-					if isinstance(self.params, dict):
-						params = urllib.urlencode(self.params)
-					else:
 
-						params = self.params
+				# url encode GET params if it's a dict
+				if isinstance(self.params, dict):
+					params = urllib.urlencode(self.params)
+				else:
 
-					req = _Request((""%s?%s"" % (self.url, params)), method=self.method)
+					params = self.params
 
-					if self.headers:
-						req.headers = self.headers
+				req = _Request((""%s?%s"" % (self.url, params)), method=self.method)
 
-					opener = self._get_opener()
-					resp = opener(req)
+				if self.headers:
+					req.headers = self.headers
 
+				opener = self._get_opener()
+
+				try:
+					resp = opener(req)
 					self.response.status_code = resp.code
 					self.response.headers = resp.info().dict
 					if self.method.lower() == 'get':
 						self.response.content = resp.read()
 
 					success = True
+				except urllib2.HTTPError, why:
+					self.response.status_code = why.code
 
-				except RequestException:
-					raise RequestException
-				
 
 		elif self.method == 'PUT':
 			if (not self.sent) or anyway:
 
-				try:
-					try:
+				req = _Request(self.url, method='PUT')
 
-						req = _Request(self.url, method='PUT')
+				if self.headers:
+					req.headers = self.headers
 
-						if self.headers:
-							req.headers = self.headers
+				req.data = self.data
+
+				try:
+					opener = self._get_opener()
+					resp =  opener(req)
 
-						req.data = self.data
+					self.response.status_code = resp.code
+					self.response.headers = resp.info().dict
+					self.response.content = resp.read()
 
-						opener = self._get_opener()
-						resp =  opener(req)
+					success = True
 
-						self.response.status_code = resp.code
-						self.response.headers = resp.info().dict
-						self.response.content = resp.read()
+				except urllib2.HTTPError, why:
+					self.response.status_code = why.code
 
-						success = True
-					except urllib2.HTTPError:
-						self.resonse.status_code = 405
 
-				except Exception:
-					# TODO: Fix this shit
-					raise RequestException
 
 
-			
 		elif self.method == 'POST':
 			if (not self.sent) or anyway:
-				try:
 
-					req = _Request(self.url, method='POST')
+				req = _Request(self.url, method='POST')
 
-					if self.headers:
-						req.headers = self.headers
+				if self.headers:
+					req.headers = self.headers
 
-					# url encode form data if it's a dict
-					if isinstance(self.data, dict):
-						req.data = urllib.urlencode(self.data)
-					else:
-						req.data = self.data
+				# url encode form data if it's a dict
+				if isinstance(self.data, dict):
+					req.data = urllib.urlencode(self.data)
+				else:
+					req.data = self.data
 
+				try:
 
 					opener = self._get_opener()
 					resp =  opener(req)
@@ -176,11 +177,11 @@ class Request(object):
 					self.response.status_code = resp.code
 					self.response.headers = resp.info().dict
 					self.response.content = resp.read()
-					
+
 					success = True
 
-				except Exception:
-					raise RequestException
+				except urllib2.HTTPError, why:
+					self.response.status_code = why.code
 
 		
 		self.sent = True if success else False
@@ -191,12 +192,12 @@ class Request(object):
 class Response(object):
 	""""""The :class:`Request` object. It's awesome.
 	""""""
-	
+
 	def __init__(self):
 		self.content = None
 		self.status_code = None
 		self.headers = dict()
-		
+
 	
 class AuthObject(object):
 	""""""The :class:`AuthObject` is a simple HTTP Authentication token.
",fix issue with urllib2 requests,[requests/core.py] fix issue with urllib2 requests,53.0516893620175,11.0,326.0,0.0,0.0,0.0,-53.0516893620175,-11.0,-326.0,0.9999998807907104,0.9529448114530767,Minor,Minor,YES
4a3f55997bc73d9ff8312cfae68a028728b49f66,a few test fixtures for now,test_requests.py,"#!/usr/bin/env python
# -*- coding: utf-8 -*-

import unittest

import requests

print requests.get('http://kennethreitz.com').headers


r = requests.Request()","#!/usr/bin/env python
# -*- coding: utf-8 -*-

import unittest

import requests


class RequestsTestSuite(unittest.TestCase):
	""""""Requests test cases.""""""
	
	def setUp(self):
		pass

	def tearDown(self):
		""""""Teardown.""""""
		pass
		
	def test_invalid_url(self):
		self.assertRaises(ValueError, requests.get, 'hiwpefhipowhefopw')

	def test_HTTP_200_OK_GET(self):
		r = requests.get('http://google.com')
		self.assertEqual(r.status_code, 200)

	def test_HTTPS_200_OK_GET(self):
		r = requests.get('https://google.com')
		self.assertEqual(r.status_code, 200)

	def test_HTTP_200_OK_HEAD(self):
		r = requests.head('http://google.com')
		self.assertEqual(r.status_code, 200)

	def test_HTTPS_200_OK_HEAD(self):
		r = requests.head('https://google.com')
		self.assertEqual(r.status_code, 200)

	def test_AUTH_HTTPS_200_OK_GET(self):
		auth = requests.AuthObject('requeststest', 'requeststest')
		url = 'https://convore.com/api/account/verify.json'
		r = requests.get(url, auth=auth)

		self.assertEqual(r.status_code, 200)


if __name__ == '__main__':
	unittest.main()
","@@ -5,7 +5,43 @@ import unittest
 
 import requests
 
-print requests.get('http://kennethreitz.com').headers
 
+class RequestsTestSuite(unittest.TestCase):
+	""""""Requests test cases.""""""
+	
+	def setUp(self):
+		pass
 
-r = requests.Request()
\ No newline at end of file
+	def tearDown(self):
+		""""""Teardown.""""""
+		pass
+		
+	def test_invalid_url(self):
+		self.assertRaises(ValueError, requests.get, 'hiwpefhipowhefopw')
+
+	def test_HTTP_200_OK_GET(self):
+		r = requests.get('http://google.com')
+		self.assertEqual(r.status_code, 200)
+
+	def test_HTTPS_200_OK_GET(self):
+		r = requests.get('https://google.com')
+		self.assertEqual(r.status_code, 200)
+
+	def test_HTTP_200_OK_HEAD(self):
+		r = requests.head('http://google.com')
+		self.assertEqual(r.status_code, 200)
+
+	def test_HTTPS_200_OK_HEAD(self):
+		r = requests.head('https://google.com')
+		self.assertEqual(r.status_code, 200)
+
+	def test_AUTH_HTTPS_200_OK_GET(self):
+		auth = requests.AuthObject('requeststest', 'requeststest')
+		url = 'https://convore.com/api/account/verify.json'
+		r = requests.get(url, auth=auth)
+
+		self.assertEqual(r.status_code, 200)
+
+
+if __name__ == '__main__':
+	unittest.main()
",add more tests,[test_requests.py] add more tests,0.0,0.0,0.0,77.06928226830426,0.0,47.0,77.06928226830426,0.0,47.0,0.9736248254776001,0.09534551083240742,Minor,Major,NO
4c8b428bbd3800cafa0e3764512eb719f67315f0,except clause fix for python3,requests/core.py,"# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

import urllib
import urllib2

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers


__title__ = 'requests'
__version__ = '0.2.0'
__build__ = 0x000200
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []


class _Request(urllib2.Request):
	""""""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""
	
	def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
		urllib2.Request.__init__( self, url, data, headers, origin_req_host, unverifiable)
		self.method = method

	def get_method(self):
		if self.method:
			return self.method

		return urllib2.Request.get_method(self)


class Request(object):
	""""""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""
	
	_METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')
	
	def __init__(self):
		self.url = None
		self.headers = dict()
		self.multipart_files = None
		self.method = None
		self.params = {}
		self.data = {}
		self.response = Response()
		self.auth = None
		self.sent = False
		
		
	def __repr__(self):
		return '<Request [%s]>' % (self.method)
	
	
	def __setattr__(self, name, value):
		if (name == 'method') and (value):
			if not value in self._METHODS:
				raise InvalidMethod()
		
		object.__setattr__(self, name, value)
	
	
	def _checks(self):
		""""""Deterministic checks for consistiency.""""""

		if not self.url:
			raise URLRequired

		
	def _get_opener(self):
		""""""Creates appropriate opener object for urllib2.""""""
		
		if self.auth:

			# create a password manager
			authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

			authr.add_password(None, self.url, self.auth.username, self.auth.password)
			handler = urllib2.HTTPBasicAuthHandler(authr)
			opener = urllib2.build_opener(handler)

			# use the opener to fetch a URL
			return opener.open
		else:
			return urllib2.urlopen

	
	def send(self, anyway=False):
		""""""Sends the request. Returns True of successfull, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""

		self._checks()

		success = False


		if self.method in ('GET', 'HEAD', 'DELETE'):
			if (not self.sent) or anyway:

				# url encode GET params if it's a dict
				if isinstance(self.params, dict):
					params = urllib.urlencode(self.params)
				else:

					params = self.params

				req = _Request((""%s?%s"" % (self.url, params)), method=self.method)

				if self.headers:
					req.headers = self.headers

				opener = self._get_opener()

				try:
					resp = opener(req)
					self.response.status_code = resp.code
					self.response.headers = resp.info().dict
					if self.method.lower() == 'get':
						self.response.content = resp.read()

					success = True
				except urllib2.HTTPError, why:
					self.response.status_code = why.code


		elif self.method == 'PUT':
			if (not self.sent) or anyway:

				req = _Request(self.url, method='PUT')

				if self.headers:
					req.headers = self.headers

				req.data = self.data

				try:
					opener = self._get_opener()
					resp =  opener(req)

					self.response.status_code = resp.code
					self.response.headers = resp.info().dict
					self.response.content = resp.read()

					success = True

				except urllib2.HTTPError, why:
					self.response.status_code = why.code


		elif self.method == 'POST':
			if (not self.sent) or anyway:

				if self.multipart_files:
					register_openers()
					datagen, headers = multipart_encode(self.multipart_files)
					req = _Request(self.url, data=datagen, headers=headers, method='POST')

					if self.headers:
						req.headers.update(self.headers)
				
				else:
					req = _Request(self.url, method='POST')
					req.headers = self.headers

					if isinstance(self.data, dict):
						req.data = urllib.urlencode(self.data)
					else:
						req.data = self.data
					
				# url encode form data if it's a dict


				try:

					opener = self._get_opener()
					resp =  opener(req)

					self.response.status_code = resp.code
					self.response.headers = resp.info().dict
					self.response.content = resp.read()

					success = True

				except(urllib2.HTTPError, why):
					self.response.status_code = why.code

		
		self.sent = True if success else False
		
		return success
		

class Response(object):
	""""""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

	def __init__(self):
		self.content = None
		self.status_code = None
		self.headers = dict()
		
	def __repr__(self):
		return '<Response [%s]>' % (self.status_code)
		

	
class AuthObject(object):
	""""""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.
    
    :param username: Username to authenticate with.
    :param password: Password for given username.
    """"""
	
	def __init__(self, username, password):
		self.username = username
		self.password = password



def get(url, params={}, headers={}, auth=None):
	""""""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'GET'
	r.url = url
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def head(url, params={}, headers={}, auth=None):
	""""""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'HEAD'
	r.url = url
	# return response object
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def post(url, data={}, headers={}, multipart_files=None, auth=None):
	""""""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param multipart_files: (optional) Dictoinary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.url = url
	r.method = 'POST'
	r.data = data
	
	if multipart_files:
		r.multipart_files = multipart_files
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response
	
	
def put(url, data='', headers={}, multipart_files={}, auth=None):
	""""""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param multipart_files: (optional) Dictoinary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'PUT'
	r.data = data
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response

	
def delete(url, params={}, headers={}, auth=None):
	""""""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'DELETE'
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def add_autoauth(url, authobject):
	""""""Registers given AuthObject to given URL domain. for auto-activation.
    Once a URL is registered with an AuthObject, the configured HTTP
    Authentication will be used for all requests with URLS containing the given
    URL string.

    Example: ::
        >>> c_auth = requests.AuthObject('kennethreitz', 'xxxxxxx')
        >>> requests.add_autoauth('https://convore.com/api/', c_auth)
        >>> r = requests.get('https://convore.com/api/account/verify.json')
        # Automatically HTTP Authenticated! Wh00t!

    :param url: Base URL for given AuthObject to auto-activate for.
    :param authobject: AuthObject to auto-activate.
    """"""

	global AUTOAUTHS
	
	AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):
	""""""Returns registered AuthObject for given url if available, defaulting to
    given AuthObject.
    """"""

	return _get_autoauth(url) if not auth else auth

	
def _get_autoauth(url):
	""""""Returns registered AuthObject for given url if available.""""""
	
	for (autoauth_url, auth) in AUTOAUTHS:
		if autoauth_url in url: 
			return auth
			
	return None


class RequestException(Exception):
	""""""There was an ambiguous exception that occured while handling your request.""""""

class AuthenticationError(RequestException):
	""""""The authentication credentials provided were invalid.""""""
	
class URLRequired(RequestException):
	""""""A valid URL is required to make a request.""""""
	
class InvalidMethod(RequestException):
	""""""An inappropriate method was attempted.""""""
","# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

import urllib
import urllib2

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers


__title__ = 'requests'
__version__ = '0.2.0'
__build__ = 0x000200
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []


class _Request(urllib2.Request):
	""""""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""
	
	def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
		urllib2.Request.__init__( self, url, data, headers, origin_req_host, unverifiable)
		self.method = method

	def get_method(self):
		if self.method:
			return self.method

		return urllib2.Request.get_method(self)


class Request(object):
	""""""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""
	
	_METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')
	
	def __init__(self):
		self.url = None
		self.headers = dict()
		self.multipart_files = None
		self.method = None
		self.params = {}
		self.data = {}
		self.response = Response()
		self.auth = None
		self.sent = False
		
		
	def __repr__(self):
		return '<Request [%s]>' % (self.method)
	
	
	def __setattr__(self, name, value):
		if (name == 'method') and (value):
			if not value in self._METHODS:
				raise InvalidMethod()
		
		object.__setattr__(self, name, value)
	
	
	def _checks(self):
		""""""Deterministic checks for consistiency.""""""

		if not self.url:
			raise URLRequired

		
	def _get_opener(self):
		""""""Creates appropriate opener object for urllib2.""""""
		
		if self.auth:

			# create a password manager
			authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

			authr.add_password(None, self.url, self.auth.username, self.auth.password)
			handler = urllib2.HTTPBasicAuthHandler(authr)
			opener = urllib2.build_opener(handler)

			# use the opener to fetch a URL
			return opener.open
		else:
			return urllib2.urlopen

	
	def send(self, anyway=False):
		""""""Sends the request. Returns True of successfull, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""

		self._checks()

		success = False


		if self.method in ('GET', 'HEAD', 'DELETE'):
			if (not self.sent) or anyway:

				# url encode GET params if it's a dict
				if isinstance(self.params, dict):
					params = urllib.urlencode(self.params)
				else:

					params = self.params

				req = _Request((""%s?%s"" % (self.url, params)), method=self.method)

				if self.headers:
					req.headers = self.headers

				opener = self._get_opener()

				try:
					resp = opener(req)
					self.response.status_code = resp.code
					self.response.headers = resp.info().dict
					if self.method.lower() == 'get':
						self.response.content = resp.read()

					success = True
				except urllib2.HTTPError as why:
					self.response.status_code = why.code


		elif self.method == 'PUT':
			if (not self.sent) or anyway:

				req = _Request(self.url, method='PUT')

				if self.headers:
					req.headers = self.headers

				req.data = self.data

				try:
					opener = self._get_opener()
					resp =  opener(req)

					self.response.status_code = resp.code
					self.response.headers = resp.info().dict
					self.response.content = resp.read()

					success = True

				except urllib2.HTTPError as why:
					self.response.status_code = why.code


		elif self.method == 'POST':
			if (not self.sent) or anyway:

				if self.multipart_files:
					register_openers()
					datagen, headers = multipart_encode(self.multipart_files)
					req = _Request(self.url, data=datagen, headers=headers, method='POST')

					if self.headers:
						req.headers.update(self.headers)
				
				else:
					req = _Request(self.url, method='POST')
					req.headers = self.headers

					if isinstance(self.data, dict):
						req.data = urllib.urlencode(self.data)
					else:
						req.data = self.data
					
				# url encode form data if it's a dict


				try:

					opener = self._get_opener()
					resp =  opener(req)

					self.response.status_code = resp.code
					self.response.headers = resp.info().dict
					self.response.content = resp.read()

					success = True

				except urllib2.HTTPError as why:
					self.response.status_code = why.code

		
		self.sent = True if success else False
		
		return success
		

class Response(object):
	""""""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

	def __init__(self):
		self.content = None
		self.status_code = None
		self.headers = dict()
		
	def __repr__(self):
		return '<Response [%s]>' % (self.status_code)


	
class AuthObject(object):
	""""""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.
    
    :param username: Username to authenticate with.
    :param password: Password for given username.
    """"""
	
	def __init__(self, username, password):
		self.username = username
		self.password = password



def get(url, params={}, headers={}, auth=None):
	""""""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'GET'
	r.url = url
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def head(url, params={}, headers={}, auth=None):
	""""""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'HEAD'
	r.url = url
	# return response object
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def post(url, data={}, headers={}, multipart_files=None, auth=None):
	""""""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param multipart_files: (optional) Dictoinary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.url = url
	r.method = 'POST'
	r.data = data
	
	if multipart_files:
		r.multipart_files = multipart_files
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response
	
	
def put(url, data='', headers={}, multipart_files={}, auth=None):
	""""""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param multipart_files: (optional) Dictoinary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'PUT'
	r.data = data
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response

	
def delete(url, params={}, headers={}, auth=None):
	""""""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'DELETE'
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def add_autoauth(url, authobject):
	""""""Registers given AuthObject to given URL domain. for auto-activation.
    Once a URL is registered with an AuthObject, the configured HTTP
    Authentication will be used for all requests with URLS containing the given
    URL string.

    Example: ::
        >>> c_auth = requests.AuthObject('kennethreitz', 'xxxxxxx')
        >>> requests.add_autoauth('https://convore.com/api/', c_auth)
        >>> r = requests.get('https://convore.com/api/account/verify.json')
        # Automatically HTTP Authenticated! Wh00t!

    :param url: Base URL for given AuthObject to auto-activate for.
    :param authobject: AuthObject to auto-activate.
    """"""

	global AUTOAUTHS
	
	AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):
	""""""Returns registered AuthObject for given url if available, defaulting to
    given AuthObject.
    """"""

	return _get_autoauth(url) if not auth else auth

	
def _get_autoauth(url):
	""""""Returns registered AuthObject for given url if available.""""""
	
	for (autoauth_url, auth) in AUTOAUTHS:
		if autoauth_url in url: 
			return auth
			
	return None


class RequestException(Exception):
	""""""There was an ambiguous exception that occured while handling your request.""""""

class AuthenticationError(RequestException):
	""""""The authentication credentials provided were invalid.""""""
	
class URLRequired(RequestException):
	""""""A valid URL is required to make a request.""""""
	
class InvalidMethod(RequestException):
	""""""An inappropriate method was attempted.""""""
","@@ -141,7 +141,7 @@ class Request(object):
 						self.response.content = resp.read()
 
 					success = True
-				except urllib2.HTTPError, why:
+				except urllib2.HTTPError as why:
 					self.response.status_code = why.code
 
 
@@ -165,7 +165,7 @@ class Request(object):
 
 					success = True
 
-				except urllib2.HTTPError, why:
+				except urllib2.HTTPError as why:
 					self.response.status_code = why.code
 
 
@@ -203,7 +203,7 @@ class Request(object):
 
 					success = True
 
-				except(urllib2.HTTPError, why):
+				except urllib2.HTTPError as why:
 					self.response.status_code = why.code
 
 		
@@ -225,7 +225,7 @@ class Response(object):
 		
 	def __repr__(self):
 		return '<Response [%s]>' % (self.status_code)
-		
+
 
 	
 class AuthObject(object):
",add missing docstrings,[requests/core.py] add missing docstrings,0.0,0.0,0.0,55.73182865571206,12.0,414.0,55.73182865571206,12.0,414.0,0.9999999403953552,0.9955257436031326,Minor,Minor,YES
02834e353d7a9d9a6dff5a2c2ee5ba477f83d46c,"added simple test fixture for Postbin and posting 
both files and data",test_requests.py,"#!/usr/bin/env python
# -*- coding: utf-8 -*-

import unittest

import requests


class RequestsTestSuite(unittest.TestCase):
	""""""Requests test cases.""""""
	
	def setUp(self):
		pass

	def tearDown(self):
		""""""Teardown.""""""
		pass
		
	def test_invalid_url(self):
		self.assertRaises(ValueError, requests.get, 'hiwpefhipowhefopw')

	def test_HTTP_200_OK_GET(self):
		r = requests.get('http://google.com')
		self.assertEqual(r.status_code, 200)

	def test_HTTPS_200_OK_GET(self):
		r = requests.get('https://google.com')
		self.assertEqual(r.status_code, 200)

	def test_HTTP_200_OK_HEAD(self):
		r = requests.head('http://google.com')
		self.assertEqual(r.status_code, 200)

	def test_HTTPS_200_OK_HEAD(self):
		r = requests.head('https://google.com')
		self.assertEqual(r.status_code, 200)

	def test_AUTH_HTTPS_200_OK_GET(self):
		auth = requests.AuthObject('requeststest', 'requeststest')
		url = 'https://convore.com/api/account/verify.json'
		r = requests.get(url, auth=auth)

		self.assertEqual(r.status_code, 200)


if __name__ == '__main__':
	unittest.main()
","#!/usr/bin/env python
# -*- coding: utf-8 -*-


import unittest
from cStringIO import StringIO

import requests


class RequestsTestSuite(unittest.TestCase):
	""""""Requests test cases.""""""
	
	def setUp(self):
		pass

	def tearDown(self):
		""""""Teardown.""""""
		pass
		
	def test_invalid_url(self):
		self.assertRaises(ValueError, requests.get, 'hiwpefhipowhefopw')

	def test_HTTP_200_OK_GET(self):
		r = requests.get('http://google.com')
		self.assertEqual(r.status_code, 200)

	def test_HTTPS_200_OK_GET(self):
		r = requests.get('https://google.com')
		self.assertEqual(r.status_code, 200)

	def test_HTTP_200_OK_HEAD(self):
		r = requests.head('http://google.com')
		self.assertEqual(r.status_code, 200)

	def test_HTTPS_200_OK_HEAD(self):
		r = requests.head('https://google.com')
		self.assertEqual(r.status_code, 200)

	def test_AUTH_HTTPS_200_OK_GET(self):
		auth = requests.AuthObject('requeststest', 'requeststest')
		url = 'https://convore.com/api/account/verify.json'
		r = requests.get(url, auth=auth)

		self.assertEqual(r.status_code, 200)

	def test_POSTBIN_GET_POST_FILES(self):

		bin = requests.post('http://www.postbin.org/')
		self.assertEqual(bin.status_code, 200)

		post = requests.post(bin.url, data={'some': 'data'})
		self.assertEqual(post.status_code, 201)

		post2 = requests.post(bin.url, files={'some': StringIO('data')})
		self.assertEqual(post2.status_code, 201)



if __name__ == '__main__':
	unittest.main()
","@@ -1,7 +1,9 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
 
+
 import unittest
+from cStringIO import StringIO
 
 import requests
 
@@ -42,6 +44,18 @@ class RequestsTestSuite(unittest.TestCase):
 
 		self.assertEqual(r.status_code, 200)
 
+	def test_POSTBIN_GET_POST_FILES(self):
+
+		bin = requests.post('http://www.postbin.org/')
+		self.assertEqual(bin.status_code, 200)
+
+		post = requests.post(bin.url, data={'some': 'data'})
+		self.assertEqual(post.status_code, 201)
+
+		post2 = requests.post(bin.url, files={'some': StringIO('data')})
+		self.assertEqual(post2.status_code, 201)
+
+
 
 if __name__ == '__main__':
 	unittest.main()
",add test for postbin_get_post_files,[test_requests.py] add test for postbin_get_post_files,77.06928226830426,0.0,47.0,72.5513737864984,0.0,61.0,-4.517908481805861,0.0,14.0,0.9990721940994263,0.743458756952151,Minor,Major,NO
10280c697dcfd3d334f1c9c381a11c324bb550bc,"Handles request in event of HTTPError. Fixes Issue #2
Building of internal request object refactor",requests/core.py,"# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

import urllib
import urllib2

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers


__title__ = 'requests'
__version__ = '0.2.1'
__build__ = 0x000201
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []


class _Request(urllib2.Request):
	""""""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""
	
	def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
		urllib2.Request.__init__( self, url, data, headers, origin_req_host, unverifiable)
		self.method = method

	def get_method(self):
		if self.method:
			return self.method

		return urllib2.Request.get_method(self)


class Request(object):
	""""""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""
	
	_METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')
	
	def __init__(self):
		self.url = None
		self.headers = dict()
		self.files = None
		self.method = None
		self.params = {}
		self.data = {}
		self.response = Response()
		self.auth = None
		self.sent = False
		
		
	def __repr__(self):
		return '<Request [%s]>' % (self.method)
	
	
	def __setattr__(self, name, value):
		if (name == 'method') and (value):
			if not value in self._METHODS:
				raise InvalidMethod()
		
		object.__setattr__(self, name, value)
	
	
	def _checks(self):
		""""""Deterministic checks for consistiency.""""""

		if not self.url:
			raise URLRequired

		
	def _get_opener(self):
		""""""Creates appropriate opener object for urllib2.""""""
		
		if self.auth:

			# create a password manager
			authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

			authr.add_password(None, self.url, self.auth.username, self.auth.password)
			handler = urllib2.HTTPBasicAuthHandler(authr)
			opener = urllib2.build_opener(handler)

			# use the opener to fetch a URL
			return opener.open
		else:
			return urllib2.urlopen

	
	def send(self, anyway=False):
		""""""Sends the request. Returns True of successfull, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""

		self._checks()

		success = False


		if self.method in ('GET', 'HEAD', 'DELETE'):
			if (not self.sent) or anyway:

				# url encode GET params if it's a dict
				if isinstance(self.params, dict):
					params = urllib.urlencode(self.params)
				else:

					params = self.params

				req = _Request((""%s?%s"" % (self.url, params)), method=self.method)

				if self.headers:
					req.headers = self.headers

				opener = self._get_opener()

				try:
					resp = opener(req)
					self.response.status_code = resp.code
					self.response.headers = resp.info().dict
					if self.method == 'GET':
						self.response.content = resp.read()
					self.response.url = resp.url

					success = True
				except urllib2.HTTPError as why:
					self.response.status_code = why.code


		elif self.method == 'PUT':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='PUT')

					if self.headers:
						req.headers.update(self.headers)

				else:

					req = _Request(self.url, method='PUT')

					if self.headers:
						req.headers = self.headers

					req.data = self.data

				try:
					opener = self._get_opener()
					resp =  opener(req)

					self.response.status_code = resp.code
					self.response.headers = resp.info().dict
					self.response.content = resp.read()
					self.response.url = resp.url

					success = True

				except urllib2.HTTPError as why:
					self.response.status_code = why.code


		elif self.method == 'POST':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='POST')

					if self.headers:
						req.headers.update(self.headers)
				
				else:
					req = _Request(self.url, method='POST')
					req.headers = self.headers

					# url encode form data if it's a dict
					if isinstance(self.data, dict):
						req.data = urllib.urlencode(self.data)
					else:
						req.data = self.data

				try:

					opener = self._get_opener()
					resp =  opener(req)

					self.response.status_code = resp.code
					self.response.headers = resp.info().dict
					self.response.content = resp.read()
					self.response.url = resp.url

					success = True

				except urllib2.HTTPError as why:
					self.response.status_code = why.code

		
		self.sent = True if success else False
		
		return success
		

class Response(object):
	""""""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

	def __init__(self):
		self.content = None
		self.status_code = None
		self.headers = dict()
		self.url = None
		
	def __repr__(self):
		return '<Response [%s]>' % (self.status_code)


	
class AuthObject(object):
	""""""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.
    
    :param username: Username to authenticate with.
    :param password: Password for given username.
    """"""
	
	def __init__(self, username, password):
		self.username = username
		self.password = password



def get(url, params={}, headers={}, auth=None):
	""""""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'GET'
	r.url = url
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def head(url, params={}, headers={}, auth=None):
	""""""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'HEAD'
	r.url = url
	# return response object
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def post(url, data={}, headers={}, files=None, auth=None):
	""""""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.url = url
	r.method = 'POST'
	r.data = data
	
	if files:
		r.files = files
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response
	
	
def put(url, data='', headers={}, files={}, auth=None):
	""""""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'PUT'
	r.data = data
	r.files = files
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response

	
def delete(url, params={}, headers={}, auth=None):
	""""""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'DELETE'
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def add_autoauth(url, authobject):
	""""""Registers given AuthObject to given URL domain. for auto-activation.
    Once a URL is registered with an AuthObject, the configured HTTP
    Authentication will be used for all requests with URLS containing the given
    URL string.

    Example: ::
        >>> c_auth = requests.AuthObject('kennethreitz', 'xxxxxxx')
        >>> requests.add_autoauth('https://convore.com/api/', c_auth)
        >>> r = requests.get('https://convore.com/api/account/verify.json')
        # Automatically HTTP Authenticated! Wh00t!

    :param url: Base URL for given AuthObject to auto-activate for.
    :param authobject: AuthObject to auto-activate.
    """"""

	global AUTOAUTHS
	
	AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):
	""""""Returns registered AuthObject for given url if available, defaulting to
    given AuthObject.
    """"""

	return _get_autoauth(url) if not auth else auth

	
def _get_autoauth(url):
	""""""Returns registered AuthObject for given url if available.""""""
	
	for (autoauth_url, auth) in AUTOAUTHS:
		if autoauth_url in url: 
			return auth
			
	return None


class RequestException(Exception):
	""""""There was an ambiguous exception that occured while handling your request.""""""

class AuthenticationError(RequestException):
	""""""The authentication credentials provided were invalid.""""""
	
class URLRequired(RequestException):
	""""""A valid URL is required to make a request.""""""
	
class InvalidMethod(RequestException):
	""""""An inappropriate method was attempted.""""""
","# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

import urllib
import urllib2

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers


__title__ = 'requests'
__version__ = '0.2.1'
__build__ = 0x000201
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []


class _Request(urllib2.Request):
	""""""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""
	
	def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
		urllib2.Request.__init__( self, url, data, headers, origin_req_host, unverifiable)
		self.method = method

	def get_method(self):
		if self.method:
			return self.method

		return urllib2.Request.get_method(self)


class Request(object):
	""""""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""
	
	_METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')
	
	def __init__(self):
		self.url = None
		self.headers = dict()
		self.files = None
		self.method = None
		self.params = {}
		self.data = {}
		self.response = Response()
		self.auth = None
		self.sent = False
		
		
	def __repr__(self):
		return '<Request [%s]>' % (self.method)
	
	
	def __setattr__(self, name, value):
		if (name == 'method') and (value):
			if not value in self._METHODS:
				raise InvalidMethod()
		
		object.__setattr__(self, name, value)
	
	
	def _checks(self):
		""""""Deterministic checks for consistiency.""""""

		if not self.url:
			raise URLRequired

		
	def _get_opener(self):
		""""""Creates appropriate opener object for urllib2.""""""
		
		if self.auth:

			# create a password manager
			authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

			authr.add_password(None, self.url, self.auth.username, self.auth.password)
			handler = urllib2.HTTPBasicAuthHandler(authr)
			opener = urllib2.build_opener(handler)

			# use the opener to fetch a URL
			return opener.open
		else:
			return urllib2.urlopen


	def _build_response(self, resp):
		""""""Build internal Response object from given response.""""""
		
		self.response.status_code = resp.code
		self.response.headers = resp.info().dict
		self.response.content = resp.read()
		self.response.url = resp.url

	def send(self, anyway=False):
		""""""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""

		self._checks()

		success = False


		if self.method in ('GET', 'HEAD', 'DELETE'):
			if (not self.sent) or anyway:

				# url encode GET params if it's a dict
				if isinstance(self.params, dict):
					params = urllib.urlencode(self.params)
				else:

					params = self.params

				req = _Request((""%s?%s"" % (self.url, params)), method=self.method)

				if self.headers:
					req.headers = self.headers

				opener = self._get_opener()

				try:
					resp = opener(req)
					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					success = False


		elif self.method == 'PUT':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='PUT')

					if self.headers:
						req.headers.update(self.headers)

				else:

					req = _Request(self.url, method='PUT')

					if self.headers:
						req.headers = self.headers

					req.data = self.data

				try:
					opener = self._get_opener()
					resp =  opener(req)

					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					success = False


		elif self.method == 'POST':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='POST')

					if self.headers:
						req.headers.update(self.headers)
				
				else:
					req = _Request(self.url, method='POST')
					req.headers = self.headers

					# url encode form data if it's a dict
					if isinstance(self.data, dict):
						req.data = urllib.urlencode(self.data)
					else:
						req.data = self.data

				try:

					opener = self._get_opener()
					resp =  opener(req)

					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					sself._build_response(why)
					success = False

		
		self.sent = True if success else False
		
		return success
		

class Response(object):
	""""""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

	def __init__(self):
		self.content = None
		self.status_code = None
		self.headers = dict()
		self.url = None
		
	def __repr__(self):
		return '<Response [%s]>' % (self.status_code)


	
class AuthObject(object):
	""""""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.
    
    :param username: Username to authenticate with.
    :param password: Password for given username.
    """"""
	
	def __init__(self, username, password):
		self.username = username
		self.password = password



def get(url, params={}, headers={}, auth=None):
	""""""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'GET'
	r.url = url
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def head(url, params={}, headers={}, auth=None):
	""""""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'HEAD'
	r.url = url
	# return response object
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def post(url, data={}, headers={}, files=None, auth=None):
	""""""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.url = url
	r.method = 'POST'
	r.data = data
	
	if files:
		r.files = files
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response
	
	
def put(url, data='', headers={}, files={}, auth=None):
	""""""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'PUT'
	r.data = data
	r.files = files
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response

	
def delete(url, params={}, headers={}, auth=None):
	""""""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'DELETE'
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def add_autoauth(url, authobject):
	""""""Registers given AuthObject to given URL domain. for auto-activation.
    Once a URL is registered with an AuthObject, the configured HTTP
    Authentication will be used for all requests with URLS containing the given
    URL string.

    Example: ::
        >>> c_auth = requests.AuthObject('kennethreitz', 'xxxxxxx')
        >>> requests.add_autoauth('https://convore.com/api/', c_auth)
        >>> r = requests.get('https://convore.com/api/account/verify.json')
        # Automatically HTTP Authenticated! Wh00t!

    :param url: Base URL for given AuthObject to auto-activate for.
    :param authobject: AuthObject to auto-activate.
    """"""

	global AUTOAUTHS
	
	AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):
	""""""Returns registered AuthObject for given url if available, defaulting to
    given AuthObject.
    """"""

	return _get_autoauth(url) if not auth else auth

	
def _get_autoauth(url):
	""""""Returns registered AuthObject for given url if available.""""""
	
	for (autoauth_url, auth) in AUTOAUTHS:
		if autoauth_url in url: 
			return auth
			
	return None


class RequestException(Exception):
	""""""There was an ambiguous exception that occured while handling your request.""""""

class AuthenticationError(RequestException):
	""""""The authentication credentials provided were invalid.""""""
	
class URLRequired(RequestException):
	""""""A valid URL is required to make a request.""""""
	
class InvalidMethod(RequestException):
	""""""An inappropriate method was attempted.""""""
","@@ -99,9 +99,17 @@ class Request(object):
 		else:
 			return urllib2.urlopen
 
-	
+
+	def _build_response(self, resp):
+		""""""Build internal Response object from given response.""""""
+		
+		self.response.status_code = resp.code
+		self.response.headers = resp.info().dict
+		self.response.content = resp.read()
+		self.response.url = resp.url
+
 	def send(self, anyway=False):
-		""""""Sends the request. Returns True of successfull, false if not.
+		""""""Sends the request. Returns True of successful, false if not.
         If there was an HTTPError during transmission,
         self.response.status_code will contain the HTTPError code.
 
@@ -135,15 +143,12 @@ class Request(object):
 
 				try:
 					resp = opener(req)
-					self.response.status_code = resp.code
-					self.response.headers = resp.info().dict
-					if self.method == 'GET':
-						self.response.content = resp.read()
-					self.response.url = resp.url
-
+					self._build_response(resp)
 					success = True
+
 				except urllib2.HTTPError as why:
-					self.response.status_code = why.code
+					self._build_response(why)
+					success = False
 
 
 		elif self.method == 'PUT':
@@ -170,15 +175,12 @@ class Request(object):
 					opener = self._get_opener()
 					resp =  opener(req)
 
-					self.response.status_code = resp.code
-					self.response.headers = resp.info().dict
-					self.response.content = resp.read()
-					self.response.url = resp.url
-
+					self._build_response(resp)
 					success = True
 
 				except urllib2.HTTPError as why:
-					self.response.status_code = why.code
+					self._build_response(why)
+					success = False
 
 
 		elif self.method == 'POST':
@@ -207,15 +209,12 @@ class Request(object):
 					opener = self._get_opener()
 					resp =  opener(req)
 
-					self.response.status_code = resp.code
-					self.response.headers = resp.info().dict
-					self.response.content = resp.read()
-					self.response.url = resp.url
-
+					self._build_response(resp)
 					success = True
 
 				except urllib2.HTTPError as why:
-					self.response.status_code = why.code
+					sself._build_response(why)
+					success = False
 
 		
 		self.sent = True if success else False
",add more info to the request class,[requests/core.py] add more info to the request class,54.70464601845915,12.0,426.0,54.993081295705146,12.0,425.0,0.2884352772459948,0.0,-1.0,1.0,0.9539945830028742,Minor,Minor,YES
bfe91296cbf990ce579639777412f5395e951247,monkey patchin' (will this suffice?),requests/core.py,"# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

import urllib
try:
	from eventlet.green import urllib2
except ImportError:
	import urllib2

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers


__title__ = 'requests'
__version__ = '0.2.1'
__build__ = 0x000201
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []


class _Request(urllib2.Request):
	""""""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""
	
	def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
		urllib2.Request.__init__( self, url, data, headers, origin_req_host, unverifiable)
		self.method = method

	def get_method(self):
		if self.method:
			return self.method

		return urllib2.Request.get_method(self)


class Request(object):
	""""""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""
	
	_METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')
	
	def __init__(self):
		self.url = None
		self.headers = dict()
		self.files = None
		self.method = None
		self.params = {}
		self.data = {}
		self.response = Response()
		self.auth = None
		self.sent = False
		
		
	def __repr__(self):
		return '<Request [%s]>' % (self.method)
	
	
	def __setattr__(self, name, value):
		if (name == 'method') and (value):
			if not value in self._METHODS:
				raise InvalidMethod()
		
		object.__setattr__(self, name, value)
	
	
	def _checks(self):
		""""""Deterministic checks for consistiency.""""""

		if not self.url:
			raise URLRequired

		
	def _get_opener(self):
		""""""Creates appropriate opener object for urllib2.""""""
		
		if self.auth:

			# create a password manager
			authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

			authr.add_password(None, self.url, self.auth.username, self.auth.password)
			handler = urllib2.HTTPBasicAuthHandler(authr)
			opener = urllib2.build_opener(handler)

			# use the opener to fetch a URL
			return opener.open
		else:
			return urllib2.urlopen


	def _build_response(self, resp):
		""""""Build internal Response object from given response.""""""
		
		self.response.status_code = resp.code
		self.response.headers = resp.info().dict
		self.response.content = resp.read()
		self.response.url = resp.url

	def send(self, anyway=False):
		""""""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""

		self._checks()

		success = False


		if self.method in ('GET', 'HEAD', 'DELETE'):
			if (not self.sent) or anyway:

				# url encode GET params if it's a dict
				if isinstance(self.params, dict):
					params = urllib.urlencode(self.params)
				else:

					params = self.params

				req = _Request((""%s?%s"" % (self.url, params)), method=self.method)

				if self.headers:
					req.headers = self.headers

				opener = self._get_opener()

				try:
					resp = opener(req)
					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					success = False


		elif self.method == 'PUT':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='PUT')

					if self.headers:
						req.headers.update(self.headers)

				else:

					req = _Request(self.url, method='PUT')

					if self.headers:
						req.headers = self.headers

					req.data = self.data

				try:
					opener = self._get_opener()
					resp =  opener(req)

					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					success = False


		elif self.method == 'POST':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='POST')

					if self.headers:
						req.headers.update(self.headers)
				
				else:
					req = _Request(self.url, method='POST')
					req.headers = self.headers

					# url encode form data if it's a dict
					if isinstance(self.data, dict):
						req.data = urllib.urlencode(self.data)
					else:
						req.data = self.data

				try:

					opener = self._get_opener()
					resp =  opener(req)

					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					success = False

		
		self.sent = True if success else False
		
		return success
		

class Response(object):
	""""""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

	def __init__(self):
		self.content = None
		self.status_code = None
		self.headers = dict()
		self.url = None
		
	def __repr__(self):
		return '<Response [%s]>' % (self.status_code)


	
class AuthObject(object):
	""""""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.
    
    :param username: Username to authenticate with.
    :param password: Password for given username.
    """"""
	
	def __init__(self, username, password):
		self.username = username
		self.password = password



def get(url, params={}, headers={}, auth=None):
	""""""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'GET'
	r.url = url
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def head(url, params={}, headers={}, auth=None):
	""""""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'HEAD'
	r.url = url
	# return response object
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def post(url, data={}, headers={}, files=None, auth=None):
	""""""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.url = url
	r.method = 'POST'
	r.data = data
	
	if files:
		r.files = files
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response
	
	
def put(url, data='', headers={}, files={}, auth=None):
	""""""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'PUT'
	r.data = data
	r.files = files
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response

	
def delete(url, params={}, headers={}, auth=None):
	""""""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'DELETE'
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def add_autoauth(url, authobject):
	""""""Registers given AuthObject to given URL domain. for auto-activation.
    Once a URL is registered with an AuthObject, the configured HTTP
    Authentication will be used for all requests with URLS containing the given
    URL string.

    Example: ::
        >>> c_auth = requests.AuthObject('kennethreitz', 'xxxxxxx')
        >>> requests.add_autoauth('https://convore.com/api/', c_auth)
        >>> r = requests.get('https://convore.com/api/account/verify.json')
        # Automatically HTTP Authenticated! Wh00t!

    :param url: Base URL for given AuthObject to auto-activate for.
    :param authobject: AuthObject to auto-activate.
    """"""

	global AUTOAUTHS
	
	AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):
	""""""Returns registered AuthObject for given url if available, defaulting to
    given AuthObject.
    """"""

	return _get_autoauth(url) if not auth else auth

	
def _get_autoauth(url):
	""""""Returns registered AuthObject for given url if available.""""""
	
	for (autoauth_url, auth) in AUTOAUTHS:
		if autoauth_url in url: 
			return auth
			
	return None


class RequestException(Exception):
	""""""There was an ambiguous exception that occured while handling your request.""""""

class AuthenticationError(RequestException):
	""""""The authentication credentials provided were invalid.""""""
	
class URLRequired(RequestException):
	""""""A valid URL is required to make a request.""""""
	
class InvalidMethod(RequestException):
	""""""An inappropriate method was attempted.""""""
","# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

import urllib
import urllib2

try:
	from gevent import monkey 
	monkey.patch_all()
except ImportError:
	pass
	
try:
	import eventlet
	eventlet.monkey_patch()
except ImportError:
	pass


from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers


__title__ = 'requests'
__version__ = '0.2.1'
__build__ = 0x000201
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []


class _Request(urllib2.Request):
	""""""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""
	
	def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
		urllib2.Request.__init__( self, url, data, headers, origin_req_host, unverifiable)
		self.method = method

	def get_method(self):
		if self.method:
			return self.method

		return urllib2.Request.get_method(self)


class Request(object):
	""""""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""
	
	_METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')
	
	def __init__(self):
		self.url = None
		self.headers = dict()
		self.files = None
		self.method = None
		self.params = {}
		self.data = {}
		self.response = Response()
		self.auth = None
		self.sent = False
		
		
	def __repr__(self):
		return '<Request [%s]>' % (self.method)
	
	
	def __setattr__(self, name, value):
		if (name == 'method') and (value):
			if not value in self._METHODS:
				raise InvalidMethod()
		
		object.__setattr__(self, name, value)
	
	
	def _checks(self):
		""""""Deterministic checks for consistiency.""""""

		if not self.url:
			raise URLRequired

		
	def _get_opener(self):
		""""""Creates appropriate opener object for urllib2.""""""
		
		if self.auth:

			# create a password manager
			authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

			authr.add_password(None, self.url, self.auth.username, self.auth.password)
			handler = urllib2.HTTPBasicAuthHandler(authr)
			opener = urllib2.build_opener(handler)

			# use the opener to fetch a URL
			return opener.open
		else:
			return urllib2.urlopen


	def _build_response(self, resp):
		""""""Build internal Response object from given response.""""""
		
		self.response.status_code = resp.code
		self.response.headers = resp.info().dict
		self.response.content = resp.read()
		self.response.url = resp.url

	def send(self, anyway=False):
		""""""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""

		self._checks()

		success = False


		if self.method in ('GET', 'HEAD', 'DELETE'):
			if (not self.sent) or anyway:

				# url encode GET params if it's a dict
				if isinstance(self.params, dict):
					params = urllib.urlencode(self.params)
				else:

					params = self.params

				req = _Request((""%s?%s"" % (self.url, params)), method=self.method)

				if self.headers:
					req.headers = self.headers

				opener = self._get_opener()

				try:
					resp = opener(req)
					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					success = False


		elif self.method == 'PUT':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='PUT')

					if self.headers:
						req.headers.update(self.headers)

				else:

					req = _Request(self.url, method='PUT')

					if self.headers:
						req.headers = self.headers

					req.data = self.data

				try:
					opener = self._get_opener()
					resp =  opener(req)

					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					success = False


		elif self.method == 'POST':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='POST')

					if self.headers:
						req.headers.update(self.headers)
				
				else:
					req = _Request(self.url, method='POST')
					req.headers = self.headers

					# url encode form data if it's a dict
					if isinstance(self.data, dict):
						req.data = urllib.urlencode(self.data)
					else:
						req.data = self.data

				try:

					opener = self._get_opener()
					resp =  opener(req)

					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					success = False

		
		self.sent = True if success else False
		
		return success
		

class Response(object):
	""""""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

	def __init__(self):
		self.content = None
		self.status_code = None
		self.headers = dict()
		self.url = None
		
	def __repr__(self):
		return '<Response [%s]>' % (self.status_code)


	
class AuthObject(object):
	""""""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.
    
    :param username: Username to authenticate with.
    :param password: Password for given username.
    """"""
	
	def __init__(self, username, password):
		self.username = username
		self.password = password



def get(url, params={}, headers={}, auth=None):
	""""""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'GET'
	r.url = url
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def head(url, params={}, headers={}, auth=None):
	""""""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'HEAD'
	r.url = url
	# return response object
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def post(url, data={}, headers={}, files=None, auth=None):
	""""""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.url = url
	r.method = 'POST'
	r.data = data
	
	if files:
		r.files = files
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response
	
	
def put(url, data='', headers={}, files={}, auth=None):
	""""""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'PUT'
	r.data = data
	r.files = files
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response

	
def delete(url, params={}, headers={}, auth=None):
	""""""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'DELETE'
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def add_autoauth(url, authobject):
	""""""Registers given AuthObject to given URL domain. for auto-activation.
    Once a URL is registered with an AuthObject, the configured HTTP
    Authentication will be used for all requests with URLS containing the given
    URL string.

    Example: ::
        >>> c_auth = requests.AuthObject('kennethreitz', 'xxxxxxx')
        >>> requests.add_autoauth('https://convore.com/api/', c_auth)
        >>> r = requests.get('https://convore.com/api/account/verify.json')
        # Automatically HTTP Authenticated! Wh00t!

    :param url: Base URL for given AuthObject to auto-activate for.
    :param authobject: AuthObject to auto-activate.
    """"""

	global AUTOAUTHS
	
	AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):
	""""""Returns registered AuthObject for given url if available, defaulting to
    given AuthObject.
    """"""

	return _get_autoauth(url) if not auth else auth

	
def _get_autoauth(url):
	""""""Returns registered AuthObject for given url if available.""""""
	
	for (autoauth_url, auth) in AUTOAUTHS:
		if autoauth_url in url: 
			return auth
			
	return None


class RequestException(Exception):
	""""""There was an ambiguous exception that occured while handling your request.""""""

class AuthenticationError(RequestException):
	""""""The authentication credentials provided were invalid.""""""
	
class URLRequired(RequestException):
	""""""A valid URL is required to make a request.""""""
	
class InvalidMethod(RequestException):
	""""""An inappropriate method was attempted.""""""
","@@ -11,10 +11,20 @@
 """"""
 
 import urllib
+import urllib2
+
 try:
-	from eventlet.green import urllib2
+	from gevent import monkey 
+	monkey.patch_all()
 except ImportError:
-	import urllib2
+	pass
+	
+try:
+	import eventlet
+	eventlet.monkey_patch()
+except ImportError:
+	pass
+
 
 from .packages.poster.encode import multipart_encode
 from .packages.poster.streaminghttp import register_openers
",add missing monkey patch,[requests/core.py] add missing monkey patch,54.66302226401755,12.0,428.0,54.073369511365634,12.0,438.0,-0.5896527526519151,0.0,10.0,0.9996637105941772,0.9886567169065017,Minor,Minor,YES
16e5119b2ad8be05673b5f8762cd71edaa0cd882,fixed gevent problem,requests/core.py,"# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

import urllib
import urllib2
#
#try:
#	import eventlet
##	eventlet.monkey_patch()
#except ImportError:
#	pass
#
#if not 'eventlet' in locals():
#	try:
#		from gevent import monkey
#		monkey.patch_all()
#	except ImportError:
#		pass
#

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers


__title__ = 'requests'
__version__ = '0.2.1'
__build__ = 0x000201
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []


class _Request(urllib2.Request):
	""""""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""
	
	def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
		urllib2.Request.__init__( self, url, data, headers, origin_req_host, unverifiable)
		self.method = method

	def get_method(self):
		if self.method:
			return self.method

		return urllib2.Request.get_method(self)


class Request(object):
	""""""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""
	
	_METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')
	
	def __init__(self):
		self.url = None
		self.headers = dict()
		self.files = None
		self.method = None
		self.params = {}
		self.data = {}
		self.response = Response()
		
		self.auth = None
		self.cookiejar = None
		self.sent = False
		
		
	def __repr__(self):
		return '<Request [%s]>' % (self.method)
	
	
	def __setattr__(self, name, value):
		if (name == 'method') and (value):
			if not value in self._METHODS:
				raise InvalidMethod()
		
		object.__setattr__(self, name, value)
	
	
	def _checks(self):
		""""""Deterministic checks for consistiency.""""""

		if not self.url:
			raise URLRequired

		
	def _get_opener(self):
		""""""Creates appropriate opener object for urllib2.""""""

		_handlers = []

		if self.auth:
			
			authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

			authr.add_password(None, self.url, self.auth.username, self.auth.password)
			auth_handler = urllib2.HTTPBasicAuthHandler(authr)

			_handlers.append(auth_handler)

		if self.cookiejar:
			
			cookie_handler = urllib2.HTTPCookieProcessor(cookiejar)
			_handlers.append(cookie_handler)

		
		opener = urllib2.build_opener(*_handlers)
		return opener.open


	def _build_response(self, resp):
		""""""Build internal Response object from given response.""""""
		
		self.response.status_code = resp.code
		self.response.headers = resp.info().dict
		self.response.content = resp.read()
		self.response.url = resp.url

	def send(self, anyway=False):
		""""""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""

		self._checks()

		success = False


		if self.method in ('GET', 'HEAD', 'DELETE'):
			if (not self.sent) or anyway:

				# url encode GET params if it's a dict
				if isinstance(self.params, dict):
					params = urllib.urlencode(self.params)
				else:

					params = self.params

				req = _Request((""%s?%s"" % (self.url, params)), method=self.method)

				if self.headers:
					req.headers = self.headers

				opener = self._get_opener()

				try:
					resp = opener(req)
					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					success = False


		elif self.method == 'PUT':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='PUT')

					if self.headers:
						req.headers.update(self.headers)

				else:

					req = _Request(self.url, method='PUT')

					if self.headers:
						req.headers = self.headers

					req.data = self.data

				try:
					opener = self._get_opener()
					resp =  opener(req)

					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					success = False


		elif self.method == 'POST':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='POST')

					if self.headers:
						req.headers.update(self.headers)
				
				else:
					req = _Request(self.url, method='POST')
					req.headers = self.headers

					# url encode form data if it's a dict
					if isinstance(self.data, dict):
						req.data = urllib.urlencode(self.data)
					else:
						req.data = self.data

				try:

					opener = self._get_opener()
					resp =  opener(req)

					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					success = False

		
		self.sent = True if success else False
		
		return success
		

class Response(object):
	""""""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

	def __init__(self):
		self.content = None
		self.status_code = None
		self.headers = dict()
		self.url = None
		
	def __repr__(self):
		return '<Response [%s]>' % (self.status_code)


	
class AuthObject(object):
	""""""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.
    
    :param username: Username to authenticate with.
    :param password: Password for given username.
    """"""
	
	def __init__(self, username, password):
		self.username = username
		self.password = password



def get(url, params={}, headers={}, auth=None):
	""""""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'GET'
	r.url = url
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def head(url, params={}, headers={}, auth=None):
	""""""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'HEAD'
	r.url = url
	# return response object
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def post(url, data={}, headers={}, files=None, auth=None):
	""""""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.url = url
	r.method = 'POST'
	r.data = data
	
	if files:
		r.files = files
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response
	
	
def put(url, data='', headers={}, files={}, auth=None):
	""""""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'PUT'
	r.data = data
	r.files = files
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response

	
def delete(url, params={}, headers={}, auth=None):
	""""""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'DELETE'
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def add_autoauth(url, authobject):
	""""""Registers given AuthObject to given URL domain. for auto-activation.
    Once a URL is registered with an AuthObject, the configured HTTP
    Authentication will be used for all requests with URLS containing the given
    URL string.

    Example: ::
        >>> c_auth = requests.AuthObject('kennethreitz', 'xxxxxxx')
        >>> requests.add_autoauth('https://convore.com/api/', c_auth)
        >>> r = requests.get('https://convore.com/api/account/verify.json')
        # Automatically HTTP Authenticated! Wh00t!

    :param url: Base URL for given AuthObject to auto-activate for.
    :param authobject: AuthObject to auto-activate.
    """"""

	global AUTOAUTHS
	
	AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):
	""""""Returns registered AuthObject for given url if available, defaulting to
    given AuthObject.
    """"""

	return _get_autoauth(url) if not auth else auth

	
def _get_autoauth(url):
	""""""Returns registered AuthObject for given url if available.""""""
	
	for (autoauth_url, auth) in AUTOAUTHS:
		if autoauth_url in url: 
			return auth
			
	return None


class RequestException(Exception):
	""""""There was an ambiguous exception that occured while handling your request.""""""

class AuthenticationError(RequestException):
	""""""The authentication credentials provided were invalid.""""""
	
class URLRequired(RequestException):
	""""""A valid URL is required to make a request.""""""
	
class InvalidMethod(RequestException):
	""""""An inappropriate method was attempted.""""""
","# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

import urllib
import urllib2
#
#try:
#	import eventlet
##	eventlet.monkey_patch()
#except ImportError:
#	pass
#
#if not 'eventlet' in locals():
#	try:
#		from gevent import monkey
#		monkey.patch_all()
#	except ImportError:
#		pass
#

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers


__title__ = 'requests'
__version__ = '0.2.1'
__build__ = 0x000201
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []


class _Request(urllib2.Request):
	""""""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""
	
	def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
		urllib2.Request.__init__( self, url, data, headers, origin_req_host, unverifiable)
		self.method = method

	def get_method(self):
		if self.method:
			return self.method

		return urllib2.Request.get_method(self)


class Request(object):
	""""""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""
	
	_METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')
	
	def __init__(self):
		self.url = None
		self.headers = dict()
		self.files = None
		self.method = None
		self.params = {}
		self.data = {}
		self.response = Response()
		
		self.auth = None
		self.cookiejar = None
		self.sent = False
		
		
	def __repr__(self):
		return '<Request [%s]>' % (self.method)
	
	
	def __setattr__(self, name, value):
		if (name == 'method') and (value):
			if not value in self._METHODS:
				raise InvalidMethod()
		
		object.__setattr__(self, name, value)
	
	
	def _checks(self):
		""""""Deterministic checks for consistiency.""""""

		if not self.url:
			raise URLRequired

		
	def _get_opener(self):
		""""""Creates appropriate opener object for urllib2.""""""

		_handlers = []

		if self.auth or self.cookiejar:

			if self.auth:

				authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

				authr.add_password(None, self.url, self.auth.username, self.auth.password)
				auth_handler = urllib2.HTTPBasicAuthHandler(authr)

				_handlers.append(auth_handler)

			if self.cookiejar:

				cookie_handler = urllib2.HTTPCookieProcessor(cookiejar)
				_handlers.append(cookie_handler)

			opener = urllib2.build_opener(*_handlers)
			return opener.open

		else:
			return urllib2.urlopen


	def _build_response(self, resp):
		""""""Build internal Response object from given response.""""""
		
		self.response.status_code = resp.code
		self.response.headers = resp.info().dict
		self.response.content = resp.read()
		self.response.url = resp.url

	def send(self, anyway=False):
		""""""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""

		self._checks()

		success = False


		if self.method in ('GET', 'HEAD', 'DELETE'):
			if (not self.sent) or anyway:

				# url encode GET params if it's a dict
				if isinstance(self.params, dict):
					params = urllib.urlencode(self.params)
				else:

					params = self.params

				req = _Request((""%s?%s"" % (self.url, params)), method=self.method)

				if self.headers:
					req.headers = self.headers

				opener = self._get_opener()

				try:
					resp = opener(req)
					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					success = False


		elif self.method == 'PUT':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='PUT')

					if self.headers:
						req.headers.update(self.headers)

				else:

					req = _Request(self.url, method='PUT')

					if self.headers:
						req.headers = self.headers

					req.data = self.data

				try:
					opener = self._get_opener()
					resp =  opener(req)

					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					success = False


		elif self.method == 'POST':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='POST')

					if self.headers:
						req.headers.update(self.headers)
				
				else:
					req = _Request(self.url, method='POST')
					req.headers = self.headers

					# url encode form data if it's a dict
					if isinstance(self.data, dict):
						req.data = urllib.urlencode(self.data)
					else:
						req.data = self.data

				try:

					opener = self._get_opener()
					resp =  opener(req)

					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					success = False

		
		self.sent = True if success else False
		
		return success
		

class Response(object):
	""""""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

	def __init__(self):
		self.content = None
		self.status_code = None
		self.headers = dict()
		self.url = None
		
	def __repr__(self):
		return '<Response [%s]>' % (self.status_code)


	
class AuthObject(object):
	""""""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.
    
    :param username: Username to authenticate with.
    :param password: Password for given username.
    """"""
	
	def __init__(self, username, password):
		self.username = username
		self.password = password



def get(url, params={}, headers={}, auth=None):
	""""""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'GET'
	r.url = url
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def head(url, params={}, headers={}, auth=None):
	""""""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'HEAD'
	r.url = url
	# return response object
	r.params = params
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def post(url, data={}, headers={}, files=None, auth=None):
	""""""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.url = url
	r.method = 'POST'
	r.data = data
	
	if files:
		r.files = files
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response
	
	
def put(url, data='', headers={}, files={}, auth=None):
	""""""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'PUT'
	r.data = data
	r.files = files
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response

	
def delete(url, params={}, headers={}, auth=None):
	""""""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'DELETE'
	
	r.headers = headers
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def add_autoauth(url, authobject):
	""""""Registers given AuthObject to given URL domain. for auto-activation.
    Once a URL is registered with an AuthObject, the configured HTTP
    Authentication will be used for all requests with URLS containing the given
    URL string.

    Example: ::
        >>> c_auth = requests.AuthObject('kennethreitz', 'xxxxxxx')
        >>> requests.add_autoauth('https://convore.com/api/', c_auth)
        >>> r = requests.get('https://convore.com/api/account/verify.json')
        # Automatically HTTP Authenticated! Wh00t!

    :param url: Base URL for given AuthObject to auto-activate for.
    :param authobject: AuthObject to auto-activate.
    """"""

	global AUTOAUTHS
	
	AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):
	""""""Returns registered AuthObject for given url if available, defaulting to
    given AuthObject.
    """"""

	return _get_autoauth(url) if not auth else auth

	
def _get_autoauth(url):
	""""""Returns registered AuthObject for given url if available.""""""
	
	for (autoauth_url, auth) in AUTOAUTHS:
		if autoauth_url in url: 
			return auth
			
	return None


class RequestException(Exception):
	""""""There was an ambiguous exception that occured while handling your request.""""""

class AuthenticationError(RequestException):
	""""""The authentication credentials provided were invalid.""""""
	
class URLRequired(RequestException):
	""""""A valid URL is required to make a request.""""""
	
class InvalidMethod(RequestException):
	""""""An inappropriate method was attempted.""""""
","@@ -103,23 +103,27 @@ class Request(object):
 
 		_handlers = []
 
-		if self.auth:
-			
-			authr = urllib2.HTTPPasswordMgrWithDefaultRealm()
+		if self.auth or self.cookiejar:
 
-			authr.add_password(None, self.url, self.auth.username, self.auth.password)
-			auth_handler = urllib2.HTTPBasicAuthHandler(authr)
+			if self.auth:
 
-			_handlers.append(auth_handler)
+				authr = urllib2.HTTPPasswordMgrWithDefaultRealm()
 
-		if self.cookiejar:
-			
-			cookie_handler = urllib2.HTTPCookieProcessor(cookiejar)
-			_handlers.append(cookie_handler)
+				authr.add_password(None, self.url, self.auth.username, self.auth.password)
+				auth_handler = urllib2.HTTPBasicAuthHandler(authr)
 
-		
-		opener = urllib2.build_opener(*_handlers)
-		return opener.open
+				_handlers.append(auth_handler)
+
+			if self.cookiejar:
+
+				cookie_handler = urllib2.HTTPCookieProcessor(cookiejar)
+				_handlers.append(cookie_handler)
+
+			opener = urllib2.build_opener(*_handlers)
+			return opener.open
+
+		else:
+			return urllib2.urlopen
 
 
 	def _build_response(self, resp):
",fix bug in request.py,[requests/core.py] fix bug in request.py,55.07097751445964,12.0,447.0,54.40236647570744,12.0,451.0,-0.6686110387522035,0.0,4.0,1.0,0.99401172662625,Minor,Minor,YES
397bd4b67688fe8b35b5c17a6f1d6f43ab076c18,spelling error,requests/core.py,"# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

import urllib
import urllib2


try:
	import eventlet
	eventlet.monkey_patch()
except ImportError:
	pass

if not 'eventlet' in locals():
	try:
		from gevent import monkey
		monkey.patch_all()
	except ImportError:
		pass


from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers


__title__ = 'requests'
__version__ = '0.2.1'
__build__ = 0x000201
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []


class _Request(urllib2.Request):
	""""""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""
	
	def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
		urllib2.Request.__init__( self, url, data, headers, origin_req_host, unverifiable)
		self.method = method

	def get_method(self):
		if self.method:
			return self.method

		return urllib2.Request.get_method(self)


class Request(object):
	""""""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""
	
	_METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')
	
	def __init__(self):
		self.url = None
		self.headers = dict()
		self.files = None
		self.method = None
		self.params = {}
		self.data = {}
		self.response = Response()
		
		self.auth = None
		self.cookiejar = None
		self.sent = False
		
		
	def __repr__(self):
		return '<Request [%s]>' % (self.method)
	
	
	def __setattr__(self, name, value):
		if (name == 'method') and (value):
			if not value in self._METHODS:
				raise InvalidMethod()
		
		object.__setattr__(self, name, value)
	
	
	def _checks(self):
		""""""Deterministic checks for consistiency.""""""

		if not self.url:
			raise URLRequired

		
	def _get_opener(self):
		""""""Creates appropriate opener object for urllib2.""""""

		_handlers = []

		if self.auth or self.cookiejar:

			if self.auth:

				authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

				authr.add_password(None, self.url, self.auth.username, self.auth.password)
				auth_handler = urllib2.HTTPBasicAuthHandler(authr)

				_handlers.append(auth_handler)

			if self.cookiejar:

				cookie_handler = urllib2.HTTPCookieProcessor(cookiejar)
				_handlers.append(cookie_handler)

			opener = urllib2.build_opener(*_handlers)
			return opener.open

		else:
			return urllib2.urlopen


	def _build_response(self, resp):
		""""""Build internal Response object from given response.""""""
		
		self.response.status_code = resp.code
		self.response.headers = resp.info().dict
		self.response.content = resp.read()
		self.response.url = resp.url

	def send(self, anyway=False):
		""""""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""

		self._checks()

		success = False


		if self.method in ('GET', 'HEAD', 'DELETE'):
			if (not self.sent) or anyway:

				# url encode GET params if it's a dict
				if isinstance(self.params, dict):
					params = urllib.urlencode(self.params)
				else:

					params = self.params

				req = _Request((""%s?%s"" % (self.url, params)), method=self.method)

				if self.headers:
					req.headers = self.headers

				opener = self._get_opener()

				try:
					resp = opener(req)
					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					success = False


		elif self.method == 'PUT':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='PUT')

					if self.headers:
						req.headers.update(self.headers)

				else:

					req = _Request(self.url, method='PUT')

					if self.headers:
						req.headers = self.headers

					req.data = self.data

				try:
					opener = self._get_opener()
					resp =  opener(req)

					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					success = False


		elif self.method == 'POST':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='POST')

					if self.headers:
						req.headers.update(self.headers)
				
				else:
					req = _Request(self.url, method='POST')
					req.headers = self.headers

					# url encode form data if it's a dict
					if isinstance(self.data, dict):
						req.data = urllib.urlencode(self.data)
					else:
						req.data = self.data

				try:

					opener = self._get_opener()
					resp =  opener(req)

					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					success = False

		
		self.sent = True if success else False
		
		return success
		

class Response(object):
	""""""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

	def __init__(self):
		self.content = None
		self.status_code = None
		self.headers = dict()
		self.url = None
		
	def __repr__(self):
		return '<Response [%s]>' % (self.status_code)


	
class AuthObject(object):
	""""""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.
    
    :param username: Username to authenticate with.
    :param password: Password for given username.
    """"""
	
	def __init__(self, username, password):
		self.username = username
		self.password = password



def get(url, params={}, headers={}, cookies=None, auth=None):
	""""""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'GET'
	r.url = url
	r.params = params
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def head(url, params={}, headers={}, cookies=None, auth=None):
	""""""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'HEAD'
	r.url = url
	# return response object
	r.params = params
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
	""""""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.url = url
	r.method = 'POST'
	r.data = data
	
	if files:
		r.files = files
	
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response
	
	
def put(url, data='', headers={}, files={}, cookies=None, auth=None):
	""""""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'PUT'
	r.data = data
	r.files = files
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response

	
def delete(url, params={}, headers={}, cookies=None, auth=None):
	""""""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'DELETE'
	
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def add_autoauth(url, authobject):
	""""""Registers given AuthObject to given URL domain. for auto-activation.
    Once a URL is registered with an AuthObject, the configured HTTP
    Authentication will be used for all requests with URLS containing the given
    URL string.

    Example: ::
        >>> c_auth = requests.AuthObject('kennethreitz', 'xxxxxxx')
        >>> requests.add_autoauth('https://convore.com/api/', c_auth)
        >>> r = requests.get('https://convore.com/api/account/verify.json')
        # Automatically HTTP Authenticated! Wh00t!

    :param url: Base URL for given AuthObject to auto-activate for.
    :param authobject: AuthObject to auto-activate.
    """"""

	global AUTOAUTHS
	
	AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):
	""""""Returns registered AuthObject for given url if available, defaulting to
    given AuthObject.
    """"""

	return _get_autoauth(url) if not auth else auth

	
def _get_autoauth(url):
	""""""Returns registered AuthObject for given url if available.""""""
	
	for (autoauth_url, auth) in AUTOAUTHS:
		if autoauth_url in url: 
			return auth
			
	return None


class RequestException(Exception):
	""""""There was an ambiguous exception that occured while handling your request.""""""

class AuthenticationError(RequestException):
	""""""The authentication credentials provided were invalid.""""""
	
class URLRequired(RequestException):
	""""""A valid URL is required to make a request.""""""
	
class InvalidMethod(RequestException):
	""""""An inappropriate method was attempted.""""""
","# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

import urllib
import urllib2


try:
	import eventlet
	eventlet.monkey_patch()
except ImportError:
	pass

if not 'eventlet' in locals():
	try:
		from gevent import monkey
		monkey.patch_all()
	except ImportError:
		pass


from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers


__title__ = 'requests'
__version__ = '0.2.1'
__build__ = 0x000201
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []


class _Request(urllib2.Request):
	""""""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""
	
	def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
		urllib2.Request.__init__( self, url, data, headers, origin_req_host, unverifiable)
		self.method = method

	def get_method(self):
		if self.method:
			return self.method

		return urllib2.Request.get_method(self)


class Request(object):
	""""""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""
	
	_METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')
	
	def __init__(self):
		self.url = None
		self.headers = dict()
		self.files = None
		self.method = None
		self.params = {}
		self.data = {}
		self.response = Response()
		
		self.auth = None
		self.cookiejar = None
		self.sent = False
		
		
	def __repr__(self):
		return '<Request [%s]>' % (self.method)
	
	
	def __setattr__(self, name, value):
		if (name == 'method') and (value):
			if not value in self._METHODS:
				raise InvalidMethod()
		
		object.__setattr__(self, name, value)
	
	
	def _checks(self):
		""""""Deterministic checks for consistency.""""""

		if not self.url:
			raise URLRequired

		
	def _get_opener(self):
		""""""Creates appropriate opener object for urllib2.""""""

		_handlers = []

		if self.auth or self.cookiejar:

			if self.auth:

				authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

				authr.add_password(None, self.url, self.auth.username, self.auth.password)
				auth_handler = urllib2.HTTPBasicAuthHandler(authr)

				_handlers.append(auth_handler)

			if self.cookiejar:

				cookie_handler = urllib2.HTTPCookieProcessor(cookiejar)
				_handlers.append(cookie_handler)

			opener = urllib2.build_opener(*_handlers)
			return opener.open

		else:
			return urllib2.urlopen


	def _build_response(self, resp):
		""""""Build internal Response object from given response.""""""
		
		self.response.status_code = resp.code
		self.response.headers = resp.info().dict
		self.response.content = resp.read()
		self.response.url = resp.url

	
	def send(self, anyway=False):
		""""""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""

		self._checks()

		success = False


		if self.method in ('GET', 'HEAD', 'DELETE'):
			if (not self.sent) or anyway:

				# url encode GET params if it's a dict
				if isinstance(self.params, dict):
					params = urllib.urlencode(self.params)
				else:

					params = self.params

				req = _Request((""%s?%s"" % (self.url, params)), method=self.method)

				if self.headers:
					req.headers = self.headers

				opener = self._get_opener()

				try:
					resp = opener(req)
					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					success = False


		elif self.method == 'PUT':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='PUT')

					if self.headers:
						req.headers.update(self.headers)

				else:

					req = _Request(self.url, method='PUT')

					if self.headers:
						req.headers = self.headers

					req.data = self.data

				try:
					opener = self._get_opener()
					resp =  opener(req)

					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					success = False


		elif self.method == 'POST':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='POST')

					if self.headers:
						req.headers.update(self.headers)
				
				else:
					req = _Request(self.url, method='POST')
					req.headers = self.headers

					# url encode form data if it's a dict
					if isinstance(self.data, dict):
						req.data = urllib.urlencode(self.data)
					else:
						req.data = self.data

				try:

					opener = self._get_opener()
					resp =  opener(req)

					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					success = False

		
		self.sent = True if success else False
		
		return success
		

class Response(object):
	""""""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

	def __init__(self):
		self.content = None
		self.status_code = None
		self.headers = dict()
		self.url = None
		
	def __repr__(self):
		return '<Response [%s]>' % (self.status_code)


	
class AuthObject(object):
	""""""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.
    
    :param username: Username to authenticate with.
    :param password: Password for given username.
    """"""
	
	def __init__(self, username, password):
		self.username = username
		self.password = password



def get(url, params={}, headers={}, cookies=None, auth=None):
	""""""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'GET'
	r.url = url
	r.params = params
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def head(url, params={}, headers={}, cookies=None, auth=None):
	""""""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'HEAD'
	r.url = url
	# return response object
	r.params = params
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
	""""""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.url = url
	r.method = 'POST'
	r.data = data
	
	if files:
		r.files = files
	
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response
	
	
def put(url, data='', headers={}, files={}, cookies=None, auth=None):
	""""""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'PUT'
	r.data = data
	r.files = files
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response

	
def delete(url, params={}, headers={}, cookies=None, auth=None):
	""""""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'DELETE'
	
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def add_autoauth(url, authobject):
	""""""Registers given AuthObject to given URL domain. for auto-activation.
    Once a URL is registered with an AuthObject, the configured HTTP
    Authentication will be used for all requests with URLS containing the given
    URL string.

    Example: ::
        >>> c_auth = requests.AuthObject('kennethreitz', 'xxxxxxx')
        >>> requests.add_autoauth('https://convore.com/api/', c_auth)
        >>> r = requests.get('https://convore.com/api/account/verify.json')
        # Automatically HTTP Authenticated! Wh00t!

    :param url: Base URL for given AuthObject to auto-activate for.
    :param authobject: AuthObject to auto-activate.
    """"""

	global AUTOAUTHS
	
	AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):
	""""""Returns registered AuthObject for given url if available, defaulting to
    given AuthObject.
    """"""

	return _get_autoauth(url) if not auth else auth

	
def _get_autoauth(url):
	""""""Returns registered AuthObject for given url if available.""""""
	
	for (autoauth_url, auth) in AUTOAUTHS:
		if autoauth_url in url: 
			return auth
			
	return None


class RequestException(Exception):
	""""""There was an ambiguous exception that occured while handling your request.""""""

class AuthenticationError(RequestException):
	""""""The authentication credentials provided were invalid.""""""
	
class URLRequired(RequestException):
	""""""A valid URL is required to make a request.""""""
	
class InvalidMethod(RequestException):
	""""""An inappropriate method was attempted.""""""
","@@ -93,7 +93,7 @@ class Request(object):
 	
 	
 	def _checks(self):
-		""""""Deterministic checks for consistiency.""""""
+		""""""Deterministic checks for consistency.""""""
 
 		if not self.url:
 			raise URLRequired
@@ -135,6 +135,7 @@ class Request(object):
 		self.response.content = resp.read()
 		self.response.url = resp.url
 
+	
 	def send(self, anyway=False):
 		""""""Sends the request. Returns True of successful, false if not.
         If there was an HTTPError during transmission,
",update request.py,[requests/core.py] update request.py,51.996127906328894,12.0,457.0,51.996127906328894,12.0,458.0,0.0,0.0,1.0,1.0,0.9991022530473217,Minor,Minor,YES
c900b4379b9bda3fb8491fa3bd96fdfa2f163a3f,Added new HTTPError handing mechanisms.,requests/core.py,"# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

import urllib
import urllib2


try:
	import eventlet
	eventlet.monkey_patch()
except ImportError:
	pass

if not 'eventlet' in locals():
	try:
		from gevent import monkey
		monkey.patch_all()
	except ImportError:
		pass


from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers


__title__ = 'requests'
__version__ = '0.2.2'
__build__ = 0x000202
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []


class _Request(urllib2.Request):
	""""""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""
	
	def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
		urllib2.Request.__init__( self, url, data, headers, origin_req_host, unverifiable)
		self.method = method

	def get_method(self):
		if self.method:
			return self.method

		return urllib2.Request.get_method(self)


class Request(object):
	""""""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""
	
	_METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')
	
	def __init__(self):
		self.url = None
		self.headers = dict()
		self.files = None
		self.method = None
		self.params = {}
		self.data = {}
		self.response = Response()
		
		self.auth = None
		self.cookiejar = None
		self.sent = False
		
		
	def __repr__(self):
		return '<Request [%s]>' % (self.method)
	
	
	def __setattr__(self, name, value):
		if (name == 'method') and (value):
			if not value in self._METHODS:
				raise InvalidMethod()
		
		object.__setattr__(self, name, value)
	
	
	def _checks(self):
		""""""Deterministic checks for consistency.""""""

		if not self.url:
			raise URLRequired

		
	def _get_opener(self):
		""""""Creates appropriate opener object for urllib2.""""""

		_handlers = []

		if self.auth or self.cookiejar:

			if self.auth:

				authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

				authr.add_password(None, self.url, self.auth.username, self.auth.password)
				auth_handler = urllib2.HTTPBasicAuthHandler(authr)

				_handlers.append(auth_handler)

			if self.cookiejar:

				cookie_handler = urllib2.HTTPCookieProcessor(cookiejar)
				_handlers.append(cookie_handler)

			opener = urllib2.build_opener(*_handlers)
			return opener.open

		else:
			return urllib2.urlopen


	def _build_response(self, resp):
		""""""Build internal Response object from given response.""""""
		
		self.response.status_code = resp.code
		self.response.headers = resp.info().dict
		self.response.content = resp.read()
		self.response.url = resp.url

	
	def send(self, anyway=False):
		""""""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""

		self._checks()

		success = False


		if self.method in ('GET', 'HEAD', 'DELETE'):
			if (not self.sent) or anyway:

				# url encode GET params if it's a dict
				if isinstance(self.params, dict):
					params = urllib.urlencode(self.params)
				else:

					params = self.params

				req = _Request((""%s?%s"" % (self.url, params)), method=self.method)

				if self.headers:
					req.headers = self.headers

				opener = self._get_opener()

				try:
					resp = opener(req)
					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					success = False


		elif self.method == 'PUT':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='PUT')

					if self.headers:
						req.headers.update(self.headers)

				else:

					req = _Request(self.url, method='PUT')

					if self.headers:
						req.headers = self.headers

					req.data = self.data

				try:
					opener = self._get_opener()
					resp =  opener(req)

					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					success = False


		elif self.method == 'POST':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='POST')

					if self.headers:
						req.headers.update(self.headers)
				
				else:
					req = _Request(self.url, method='POST')
					req.headers = self.headers

					# url encode form data if it's a dict
					if isinstance(self.data, dict):
						req.data = urllib.urlencode(self.data)
					else:
						req.data = self.data

				try:

					opener = self._get_opener()
					resp =  opener(req)

					self._build_response(resp)
					success = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					success = False

		
		self.sent = True if success else False
		
		return success
		

class Response(object):
	""""""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

	def __init__(self):
		self.content = None
		self.status_code = None
		self.headers = dict()
		self.url = None
		
	def __repr__(self):
		return '<Response [%s]>' % (self.status_code)


	
class AuthObject(object):
	""""""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.
    
    :param username: Username to authenticate with.
    :param password: Password for given username.
    """"""
	
	def __init__(self, username, password):
		self.username = username
		self.password = password



def get(url, params={}, headers={}, cookies=None, auth=None):
	""""""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'GET'
	r.url = url
	r.params = params
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def head(url, params={}, headers={}, cookies=None, auth=None):
	""""""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'HEAD'
	r.url = url
	# return response object
	r.params = params
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
	""""""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.url = url
	r.method = 'POST'
	r.data = data
	
	if files:
		r.files = files
	
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response
	
	
def put(url, data='', headers={}, files={}, cookies=None, auth=None):
	""""""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'PUT'
	r.data = data
	r.files = files
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response

	
def delete(url, params={}, headers={}, cookies=None, auth=None):
	""""""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'DELETE'
	
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def add_autoauth(url, authobject):
	""""""Registers given AuthObject to given URL domain. for auto-activation.
    Once a URL is registered with an AuthObject, the configured HTTP
    Authentication will be used for all requests with URLS containing the given
    URL string.

    Example: ::
        >>> c_auth = requests.AuthObject('kennethreitz', 'xxxxxxx')
        >>> requests.add_autoauth('https://convore.com/api/', c_auth)
        >>> r = requests.get('https://convore.com/api/account/verify.json')
        # Automatically HTTP Authenticated! Wh00t!

    :param url: Base URL for given AuthObject to auto-activate for.
    :param authobject: AuthObject to auto-activate.
    """"""

	global AUTOAUTHS
	
	AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):
	""""""Returns registered AuthObject for given url if available, defaulting to
    given AuthObject.
    """"""

	return _get_autoauth(url) if not auth else auth

	
def _get_autoauth(url):
	""""""Returns registered AuthObject for given url if available.""""""
	
	for (autoauth_url, auth) in AUTOAUTHS:
		if autoauth_url in url: 
			return auth
			
	return None


class RequestException(Exception):
	""""""There was an ambiguous exception that occured while handling your request.""""""

class AuthenticationError(RequestException):
	""""""The authentication credentials provided were invalid.""""""
	
class URLRequired(RequestException):
	""""""A valid URL is required to make a request.""""""
	
class InvalidMethod(RequestException):
	""""""An inappropriate method was attempted.""""""
","# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

import urllib
import urllib2


try:
	import eventlet
	eventlet.monkey_patch()
except ImportError:
	pass

if not 'eventlet' in locals():
	try:
		from gevent import monkey
		monkey.patch_all()
	except ImportError:
		pass


from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers


__title__ = 'requests'
__version__ = '0.2.2'
__build__ = 0x000202
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []


class _Request(urllib2.Request):
	""""""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""
	
	def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
		urllib2.Request.__init__( self, url, data, headers, origin_req_host, unverifiable)
		self.method = method

	def get_method(self):
		if self.method:
			return self.method

		return urllib2.Request.get_method(self)


class Request(object):
	""""""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""
	
	_METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')
	
	def __init__(self):
		self.url = None
		self.headers = dict()
		self.files = None
		self.method = None
		self.params = {}
		self.data = {}
		self.response = Response()
		
		self.auth = None
		self.cookiejar = None
		self.sent = False
		
		
	def __repr__(self):
		return '<Request [%s]>' % (self.method)
	
	
	def __setattr__(self, name, value):
		if (name == 'method') and (value):
			if not value in self._METHODS:
				raise InvalidMethod()
		
		object.__setattr__(self, name, value)
	
	
	def _checks(self):
		""""""Deterministic checks for consistency.""""""

		if not self.url:
			raise URLRequired

		
	def _get_opener(self):
		""""""Creates appropriate opener object for urllib2.""""""

		_handlers = []

		if self.auth or self.cookiejar:

			if self.auth:

				authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

				authr.add_password(None, self.url, self.auth.username, self.auth.password)
				auth_handler = urllib2.HTTPBasicAuthHandler(authr)

				_handlers.append(auth_handler)

			if self.cookiejar:

				cookie_handler = urllib2.HTTPCookieProcessor(cookiejar)
				_handlers.append(cookie_handler)

			opener = urllib2.build_opener(*_handlers)
			return opener.open

		else:
			return urllib2.urlopen


	def _build_response(self, resp):
		""""""Build internal Response object from given response.""""""
		
		self.response.status_code = resp.code
		self.response.headers = resp.info().dict
		self.response.content = resp.read()
		self.response.url = resp.url

	
	def send(self, anyway=False):
		""""""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""

		self._checks()

		success = False


		if self.method in ('GET', 'HEAD', 'DELETE'):
			if (not self.sent) or anyway:

				# url encode GET params if it's a dict
				if isinstance(self.params, dict):
					params = urllib.urlencode(self.params)
				else:
					params = self.params

				req = _Request((""%s?%s"" % (self.url, params)), method=self.method)

				if self.headers:
					req.headers = self.headers

				opener = self._get_opener()

				try:
					resp = opener(req)
					self._build_response(resp)
					self.response.ok = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					self.response.error = why


		elif self.method == 'PUT':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='PUT')

					if self.headers:
						req.headers.update(self.headers)

				else:

					req = _Request(self.url, method='PUT')

					if self.headers:
						req.headers = self.headers

					req.data = self.data

				try:
					opener = self._get_opener()
					resp =  opener(req)

					self._build_response(resp)
					self.response.ok = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					self.response.error = why


		elif self.method == 'POST':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='POST')

					if self.headers:
						req.headers.update(self.headers)
				
				else:
					req = _Request(self.url, method='POST')
					req.headers = self.headers

					# url encode form data if it's a dict
					if isinstance(self.data, dict):
						req.data = urllib.urlencode(self.data)
					else:
						req.data = self.data

				try:
					opener = self._get_opener()
					resp =  opener(req)

					self._build_response(resp)
					self.response.ok = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					self.response.error = why
		
		self.sent = self.response.ok
		
		return self.sent
		

class Response(object):
	""""""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

	def __init__(self):
		self.content = None
		self.status_code = None
		self.headers = dict()
		self.url = None
		self.ok = False
		self.error = False
		
	def __repr__(self):
		return '<Response [%s]>' % (self.status_code)
		
	def __nonzero__(self):
		""""""Returns true if status_code is 'OK'.""""""
		return not self.error
		
	def raise_for_response(self):
		""""""Raises stored HTTPError if one exists.""""""
		if self.error:
			raise self.error


	
class AuthObject(object):
	""""""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.
    
    :param username: Username to authenticate with.
    :param password: Password for given username.
    """"""
	
	def __init__(self, username, password):
		self.username = username
		self.password = password



def get(url, params={}, headers={}, cookies=None, auth=None):
	""""""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'GET'
	r.url = url
	r.params = params
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def head(url, params={}, headers={}, cookies=None, auth=None):
	""""""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'HEAD'
	r.url = url
	# return response object
	r.params = params
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
	""""""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.url = url
	r.method = 'POST'
	r.data = data
	
	if files:
		r.files = files
	
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response
	
	
def put(url, data='', headers={}, files={}, cookies=None, auth=None):
	""""""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'PUT'
	r.data = data
	r.files = files
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response

	
def delete(url, params={}, headers={}, cookies=None, auth=None):
	""""""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'DELETE'
	
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def add_autoauth(url, authobject):
	""""""Registers given AuthObject to given URL domain. for auto-activation.
    Once a URL is registered with an AuthObject, the configured HTTP
    Authentication will be used for all requests with URLS containing the given
    URL string.

    Example: ::
        >>> c_auth = requests.AuthObject('kennethreitz', 'xxxxxxx')
        >>> requests.add_autoauth('https://convore.com/api/', c_auth)
        >>> r = requests.get('https://convore.com/api/account/verify.json')
        # Automatically HTTP Authenticated! Wh00t!

    :param url: Base URL for given AuthObject to auto-activate for.
    :param authobject: AuthObject to auto-activate.
    """"""

	global AUTOAUTHS
	
	AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):
	""""""Returns registered AuthObject for given url if available, defaulting to
    given AuthObject.
    """"""

	return _get_autoauth(url) if not auth else auth

	
def _get_autoauth(url):
	""""""Returns registered AuthObject for given url if available.""""""
	
	for (autoauth_url, auth) in AUTOAUTHS:
		if autoauth_url in url: 
			return auth
			
	return None


class RequestException(Exception):
	""""""There was an ambiguous exception that occured while handling your request.""""""

class AuthenticationError(RequestException):
	""""""The authentication credentials provided were invalid.""""""
	
class URLRequired(RequestException):
	""""""A valid URL is required to make a request.""""""
	
class InvalidMethod(RequestException):
	""""""An inappropriate method was attempted.""""""
","@@ -159,7 +159,6 @@ class Request(object):
 				if isinstance(self.params, dict):
 					params = urllib.urlencode(self.params)
 				else:
-
 					params = self.params
 
 				req = _Request((""%s?%s"" % (self.url, params)), method=self.method)
@@ -172,11 +171,11 @@ class Request(object):
 				try:
 					resp = opener(req)
 					self._build_response(resp)
-					success = True
+					self.response.ok = True
 
 				except urllib2.HTTPError as why:
 					self._build_response(why)
-					success = False
+					self.response.error = why
 
 
 		elif self.method == 'PUT':
@@ -204,11 +203,11 @@ class Request(object):
 					resp =  opener(req)
 
 					self._build_response(resp)
-					success = True
+					self.response.ok = True
 
 				except urllib2.HTTPError as why:
 					self._build_response(why)
-					success = False
+					self.response.error = why
 
 
 		elif self.method == 'POST':
@@ -233,21 +232,19 @@ class Request(object):
 						req.data = self.data
 
 				try:
-
 					opener = self._get_opener()
 					resp =  opener(req)
 
 					self._build_response(resp)
-					success = True
+					self.response.ok = True
 
 				except urllib2.HTTPError as why:
 					self._build_response(why)
-					success = False
-
+					self.response.error = why
 		
-		self.sent = True if success else False
+		self.sent = self.response.ok
 		
-		return success
+		return self.sent
 		
 
 class Response(object):
@@ -261,9 +258,20 @@ class Response(object):
 		self.status_code = None
 		self.headers = dict()
 		self.url = None
+		self.ok = False
+		self.error = False
 		
 	def __repr__(self):
 		return '<Response [%s]>' % (self.status_code)
+		
+	def __nonzero__(self):
+		""""""Returns true if status_code is 'OK'.""""""
+		return not self.error
+		
+	def raise_for_response(self):
+		""""""Raises stored HTTPError if one exists.""""""
+		if self.error:
+			raise self.error
 
 
 	
",add missing docstrings,[requests/core.py] add missing docstrings,52.303027685609024,12.0,463.0,51.39720682954768,12.0,471.0,-0.9058208560613394,0.0,8.0,1.0000001192092896,0.9573383973901888,Minor,Minor,YES
4f1301f6ad24505e67125ee3b316c8e4cdbdf409,Now Requests has it's own HTTPError,requests/core.py,"# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

import urllib
import urllib2


try:
	import eventlet
	eventlet.monkey_patch()
except ImportError:
	pass

if not 'eventlet' in locals():
	try:
		from gevent import monkey
		monkey.patch_all()
	except ImportError:
		pass


from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers


__title__ = 'requests'
__version__ = '0.2.2'
__build__ = 0x000202
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []


class _Request(urllib2.Request):
	""""""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""
	
	def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
		urllib2.Request.__init__( self, url, data, headers, origin_req_host, unverifiable)
		self.method = method

	def get_method(self):
		if self.method:
			return self.method

		return urllib2.Request.get_method(self)


class Request(object):
	""""""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""
	
	_METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')
	
	def __init__(self):
		self.url = None
		self.headers = dict()
		self.files = None
		self.method = None
		self.params = {}
		self.data = {}
		self.response = Response()
		
		self.auth = None
		self.cookiejar = None
		self.sent = False
		
		
	def __repr__(self):
		return '<Request [%s]>' % (self.method)
	
	
	def __setattr__(self, name, value):
		if (name == 'method') and (value):
			if not value in self._METHODS:
				raise InvalidMethod()
		
		object.__setattr__(self, name, value)
	
	
	def _checks(self):
		""""""Deterministic checks for consistency.""""""

		if not self.url:
			raise URLRequired

		
	def _get_opener(self):
		""""""Creates appropriate opener object for urllib2.""""""

		_handlers = []

		if self.auth or self.cookiejar:

			if self.auth:

				authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

				authr.add_password(None, self.url, self.auth.username, self.auth.password)
				auth_handler = urllib2.HTTPBasicAuthHandler(authr)

				_handlers.append(auth_handler)

			if self.cookiejar:

				cookie_handler = urllib2.HTTPCookieProcessor(cookiejar)
				_handlers.append(cookie_handler)

			opener = urllib2.build_opener(*_handlers)
			return opener.open

		else:
			return urllib2.urlopen


	def _build_response(self, resp):
		""""""Build internal Response object from given response.""""""
		
		self.response.status_code = resp.code
		self.response.headers = resp.info().dict
		self.response.content = resp.read()
		self.response.url = resp.url

	
	def send(self, anyway=False):
		""""""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""

		self._checks()

		success = False


		if self.method in ('GET', 'HEAD', 'DELETE'):
			if (not self.sent) or anyway:

				# url encode GET params if it's a dict
				if isinstance(self.params, dict):
					params = urllib.urlencode(self.params)
				else:
					params = self.params

				req = _Request((""%s?%s"" % (self.url, params)), method=self.method)

				if self.headers:
					req.headers = self.headers

				opener = self._get_opener()

				try:
					resp = opener(req)
					self._build_response(resp)
					self.response.ok = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					self.response.error = why


		elif self.method == 'PUT':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='PUT')

					if self.headers:
						req.headers.update(self.headers)

				else:

					req = _Request(self.url, method='PUT')

					if self.headers:
						req.headers = self.headers

					req.data = self.data

				try:
					opener = self._get_opener()
					resp =  opener(req)

					self._build_response(resp)
					self.response.ok = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					self.response.error = why


		elif self.method == 'POST':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='POST')

					if self.headers:
						req.headers.update(self.headers)
				
				else:
					req = _Request(self.url, method='POST')
					req.headers = self.headers

					# url encode form data if it's a dict
					if isinstance(self.data, dict):
						req.data = urllib.urlencode(self.data)
					else:
						req.data = self.data

				try:
					opener = self._get_opener()
					resp =  opener(req)

					self._build_response(resp)
					self.response.ok = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					self.response.error = why
		
		self.sent = self.response.ok
		
		return self.sent
		

class Response(object):
	""""""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

	def __init__(self):
		self.content = None
		self.status_code = None
		self.headers = dict()
		self.url = None
		self.ok = False
		self.error = None
		
	def __repr__(self):
		return '<Response [%s]>' % (self.status_code)
		
	def __nonzero__(self):
		""""""Returns true if status_code is 'OK'.""""""
		return not self.error
		
	def raise_for_status(self):
		""""""Raises stored HTTPError if one exists.""""""
		if self.error:
			raise self.error


	
class AuthObject(object):
	""""""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.
    
    :param username: Username to authenticate with.
    :param password: Password for given username.
    """"""
	
	def __init__(self, username, password):
		self.username = username
		self.password = password



def get(url, params={}, headers={}, cookies=None, auth=None):
	""""""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'GET'
	r.url = url
	r.params = params
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def head(url, params={}, headers={}, cookies=None, auth=None):
	""""""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'HEAD'
	r.url = url
	# return response object
	r.params = params
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
	""""""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.url = url
	r.method = 'POST'
	r.data = data
	
	if files:
		r.files = files
	
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response
	
	
def put(url, data='', headers={}, files={}, cookies=None, auth=None):
	""""""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'PUT'
	r.data = data
	r.files = files
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response

	
def delete(url, params={}, headers={}, cookies=None, auth=None):
	""""""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'DELETE'
	
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def add_autoauth(url, authobject):
	""""""Registers given AuthObject to given URL domain. for auto-activation.
    Once a URL is registered with an AuthObject, the configured HTTP
    Authentication will be used for all requests with URLS containing the given
    URL string.

    Example: ::
        >>> c_auth = requests.AuthObject('kennethreitz', 'xxxxxxx')
        >>> requests.add_autoauth('https://convore.com/api/', c_auth)
        >>> r = requests.get('https://convore.com/api/account/verify.json')
        # Automatically HTTP Authenticated! Wh00t!

    :param url: Base URL for given AuthObject to auto-activate for.
    :param authobject: AuthObject to auto-activate.
    """"""

	global AUTOAUTHS
	
	AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):
	""""""Returns registered AuthObject for given url if available, defaulting to
    given AuthObject.
    """"""

	return _get_autoauth(url) if not auth else auth

	
def _get_autoauth(url):
	""""""Returns registered AuthObject for given url if available.""""""
	
	for (autoauth_url, auth) in AUTOAUTHS:
		if autoauth_url in url: 
			return auth
			
	return None


class RequestException(Exception):
	""""""There was an ambiguous exception that occured while handling your request.""""""

class AuthenticationError(RequestException):
	""""""The authentication credentials provided were invalid.""""""
	
class URLRequired(RequestException):
	""""""A valid URL is required to make a request.""""""
	
class InvalidMethod(RequestException):
	""""""An inappropriate method was attempted.""""""
","# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

import urllib
import urllib2

from urllib2 import HTTPError

try:
	import eventlet
	eventlet.monkey_patch()
except ImportError:
	pass

if not 'eventlet' in locals():
	try:
		from gevent import monkey
		monkey.patch_all()
	except ImportError:
		pass


from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers


__title__ = 'requests'
__version__ = '0.2.2'
__build__ = 0x000202
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []


class _Request(urllib2.Request):
	""""""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""
	
	def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
		urllib2.Request.__init__( self, url, data, headers, origin_req_host, unverifiable)
		self.method = method

	def get_method(self):
		if self.method:
			return self.method

		return urllib2.Request.get_method(self)


class Request(object):
	""""""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""
	
	_METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')
	
	def __init__(self):
		self.url = None
		self.headers = dict()
		self.files = None
		self.method = None
		self.params = {}
		self.data = {}
		self.response = Response()
		
		self.auth = None
		self.cookiejar = None
		self.sent = False
		
		
	def __repr__(self):
		return '<Request [%s]>' % (self.method)
	
	
	def __setattr__(self, name, value):
		if (name == 'method') and (value):
			if not value in self._METHODS:
				raise InvalidMethod()
		
		object.__setattr__(self, name, value)
	
	
	def _checks(self):
		""""""Deterministic checks for consistency.""""""

		if not self.url:
			raise URLRequired

		
	def _get_opener(self):
		""""""Creates appropriate opener object for urllib2.""""""

		_handlers = []

		if self.auth or self.cookiejar:

			if self.auth:

				authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

				authr.add_password(None, self.url, self.auth.username, self.auth.password)
				auth_handler = urllib2.HTTPBasicAuthHandler(authr)

				_handlers.append(auth_handler)

			if self.cookiejar:

				cookie_handler = urllib2.HTTPCookieProcessor(cookiejar)
				_handlers.append(cookie_handler)

			opener = urllib2.build_opener(*_handlers)
			return opener.open

		else:
			return urllib2.urlopen


	def _build_response(self, resp):
		""""""Build internal Response object from given response.""""""
		
		self.response.status_code = resp.code
		self.response.headers = resp.info().dict
		self.response.content = resp.read()
		self.response.url = resp.url

	
	def send(self, anyway=False):
		""""""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""

		self._checks()

		success = False


		if self.method in ('GET', 'HEAD', 'DELETE'):
			if (not self.sent) or anyway:

				# url encode GET params if it's a dict
				if isinstance(self.params, dict):
					params = urllib.urlencode(self.params)
				else:
					params = self.params

				req = _Request((""%s?%s"" % (self.url, params)), method=self.method)

				if self.headers:
					req.headers = self.headers

				opener = self._get_opener()

				try:
					resp = opener(req)
					self._build_response(resp)
					self.response.ok = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					self.response.error = why


		elif self.method == 'PUT':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='PUT')

					if self.headers:
						req.headers.update(self.headers)

				else:

					req = _Request(self.url, method='PUT')

					if self.headers:
						req.headers = self.headers

					req.data = self.data

				try:
					opener = self._get_opener()
					resp =  opener(req)

					self._build_response(resp)
					self.response.ok = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					self.response.error = why


		elif self.method == 'POST':
			if (not self.sent) or anyway:

				if self.files:
					register_openers()
					datagen, headers = multipart_encode(self.files)
					req = _Request(self.url, data=datagen, headers=headers, method='POST')

					if self.headers:
						req.headers.update(self.headers)
				
				else:
					req = _Request(self.url, method='POST')
					req.headers = self.headers

					# url encode form data if it's a dict
					if isinstance(self.data, dict):
						req.data = urllib.urlencode(self.data)
					else:
						req.data = self.data

				try:
					opener = self._get_opener()
					resp =  opener(req)

					self._build_response(resp)
					self.response.ok = True

				except urllib2.HTTPError as why:
					self._build_response(why)
					self.response.error = why
		
		self.sent = self.response.ok
		
		return self.sent
		

class Response(object):
	""""""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

	def __init__(self):
		self.content = None
		self.status_code = None
		self.headers = dict()
		self.url = None
		self.ok = False
		self.error = None
		
	def __repr__(self):
		return '<Response [%s]>' % (self.status_code)
		
	def __nonzero__(self):
		""""""Returns true if status_code is 'OK'.""""""
		return not self.error
		
	def raise_for_status(self):
		""""""Raises stored HTTPError if one exists.""""""
		if self.error:
			raise self.error


	
class AuthObject(object):
	""""""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.
    
    :param username: Username to authenticate with.
    :param password: Password for given username.
    """"""
	
	def __init__(self, username, password):
		self.username = username
		self.password = password



def get(url, params={}, headers={}, cookies=None, auth=None):
	""""""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'GET'
	r.url = url
	r.params = params
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def head(url, params={}, headers={}, cookies=None, auth=None):
	""""""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.method = 'HEAD'
	r.url = url
	# return response object
	r.params = params
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
	""""""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()
	
	r.url = url
	r.method = 'POST'
	r.data = data
	
	if files:
		r.files = files
	
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response
	
	
def put(url, data='', headers={}, files={}, cookies=None, auth=None):
	""""""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'PUT'
	r.data = data
	r.files = files
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response

	
def delete(url, params={}, headers={}, cookies=None, auth=None):
	""""""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
	
	r = Request()

	r.url = url
	r.method = 'DELETE'
	
	r.headers = headers
	r.cookiejar = cookies
	r.auth = _detect_auth(url, auth)
	
	r.send()
	
	return r.response


def add_autoauth(url, authobject):
	""""""Registers given AuthObject to given URL domain. for auto-activation.
    Once a URL is registered with an AuthObject, the configured HTTP
    Authentication will be used for all requests with URLS containing the given
    URL string.

    Example: ::
        >>> c_auth = requests.AuthObject('kennethreitz', 'xxxxxxx')
        >>> requests.add_autoauth('https://convore.com/api/', c_auth)
        >>> r = requests.get('https://convore.com/api/account/verify.json')
        # Automatically HTTP Authenticated! Wh00t!

    :param url: Base URL for given AuthObject to auto-activate for.
    :param authobject: AuthObject to auto-activate.
    """"""

	global AUTOAUTHS
	
	AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):
	""""""Returns registered AuthObject for given url if available, defaulting to
    given AuthObject.
    """"""

	return _get_autoauth(url) if not auth else auth

	
def _get_autoauth(url):
	""""""Returns registered AuthObject for given url if available.""""""
	
	for (autoauth_url, auth) in AUTOAUTHS:
		if autoauth_url in url: 
			return auth
			
	return None


class RequestException(Exception):
	""""""There was an ambiguous exception that occured while handling your request.""""""

class AuthenticationError(RequestException):
	""""""The authentication credentials provided were invalid.""""""
	
class URLRequired(RequestException):
	""""""A valid URL is required to make a request.""""""
	
class InvalidMethod(RequestException):
	""""""An inappropriate method was attempted.""""""
","@@ -13,6 +13,7 @@
 import urllib
 import urllib2
 
+from urllib2 import HTTPError
 
 try:
 	import eventlet
",add missing import,[requests/core.py] add missing import,51.39720682954768,12.0,471.0,51.33564324622893,12.0,472.0,-0.0615635833187511,0.0,1.0,0.9998868107795715,0.9981587850898951,Minor,Minor,YES
6bde9551709444a9b3859ae33b6174edcc99b03e,Python 2.5 Fixes.,requests/__init__.py,"# -*- coding: utf-8 -*-

from . import packages
from .core import *
","# -*- coding: utf-8 -*-

import packages
from core import *



","@@ -1,4 +1,7 @@
 # -*- coding: utf-8 -*-
 
-from . import packages
-from .core import *
+import packages
+from core import *
+
+
+
",add missing import,[requests/__init__.py] add missing import,100.0,0.0,4.0,100.0,0.0,7.0,0.0,0.0,3.0,0.9973489046096802,0.6042570088997969,Minor,Major,NO
6bde9551709444a9b3859ae33b6174edcc99b03e,Python 2.5 Fixes.,requests/core.py,"# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import
import urllib
import urllib2

from urllib2 import HTTPError

try:
    import eventlet
    eventlet.monkey_patch()
except ImportError:
    pass

if not 'eventlet' in locals():
    try:
        from gevent import monkey
        monkey.patch_all()
    except ImportError:
        pass

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers


__title__ = 'requests'
__version__ = '0.2.3'
__build__ = 0x000203
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []



class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""
    
    def __init__(self, url, data=None, headers={}, origin_req_host=None,
                 unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""
    
    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')
    
    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 params=dict(), data=dict(), auth=None, cookiejar=None):
        self.url = url
        self.headers = headers
        self.files = files
        self.method = method
        self.params = params
        self.data = data
        self.response = Response()
        
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False
        
        
    def __repr__(self):
        return '<Request [%s]>' % (self.method)
    
    
    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()
        
        object.__setattr__(self, name, value)
    
    
    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired

        
    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.auth or self.cookiejar:

            if self.auth:

                authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

                authr.add_password(None, self.url, self.auth.username, self.auth.password)
                auth_handler = urllib2.HTTPBasicAuthHandler(authr)

                _handlers.append(auth_handler)

            if self.cookiejar:

                cookie_handler = urllib2.HTTPCookieProcessor(cookiejar)
                _handlers.append(cookie_handler)

            opener = urllib2.build_opener(*_handlers)
            return opener.open

        else:
            return urllib2.urlopen


    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""
        
        self.response.status_code = resp.code
        self.response.headers = resp.info().dict
        self.response.content = resp.read()
        self.response.url = resp.url

    
    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""

        self._checks()

        success = False


        if self.method in ('GET', 'HEAD', 'DELETE'):
            if (not self.sent) or anyway:

                # url encode GET params if it's a dict
                if isinstance(self.params, dict):
                    params = urllib.urlencode(self.params)
                else:
                    params = self.params

                req = _Request((""%s?%s"" % (self.url, params)), method=self.method)

                if self.headers:
                    req.headers = self.headers

                opener = self._get_opener()

                try:
                    resp = opener(req)
                    self._build_response(resp)
                    self.response.ok = True

                except urllib2.HTTPError as why:
                    self._build_response(why)
                    self.response.error = why


        elif self.method == 'PUT':
            if (not self.sent) or anyway:

                if self.files:
                    register_openers()
                    datagen, headers = multipart_encode(self.files)
                    req = _Request(self.url, data=datagen, headers=headers, method='PUT')

                    if self.headers:
                        req.headers.update(self.headers)

                else:

                    req = _Request(self.url, method='PUT')

                    if self.headers:
                        req.headers = self.headers

                    req.data = self.data

                try:
                    opener = self._get_opener()
                    resp =  opener(req)

                    self._build_response(resp)
                    self.response.ok = True

                except urllib2.HTTPError as why:
                    self._build_response(why)
                    self.response.error = why


        elif self.method == 'POST':
            if (not self.sent) or anyway:

                if self.files:
                    register_openers()
                    datagen, headers = multipart_encode(self.files)
                    req = _Request(self.url, data=datagen, headers=headers, method='POST')

                    if self.headers:
                        req.headers.update(self.headers)
                
                else:
                    req = _Request(self.url, method='POST')
                    req.headers = self.headers

                    # url encode form data if it's a dict
                    if isinstance(self.data, dict):
                        req.data = urllib.urlencode(self.data)
                    else:
                        req.data = self.data

                try:
                    opener = self._get_opener()
                    resp =  opener(req)

                    self._build_response(resp)
                    self.response.ok = True

                except urllib2.HTTPError as why:
                    self._build_response(why)
                    self.response.error = why
        
        self.sent = self.response.ok
        
        return self.sent
        

class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        
    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)
        
    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error
        
    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error


    
class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.
    
    :param username: Username to authenticate with.
    :param password: Password for given username.
    """"""
    
    def __init__(self, username, password):
        self.username = username
        self.password = password



def get(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    
    r = Request(method='GET', url=url, params=params, headers=headers,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response


def head(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    r = Request(method='HEAD', url=url, params=params, headers=headers,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    
    r = Request(method='POST', url=url, data=data, headers=headers,
                files=files, cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response
    
    
def put(url, data='', headers={}, files={}, cookies=None, auth=None):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    r = Request(method='PUT', url=url, data=data, headers=headers, files=files,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response

    
def delete(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    
    r = Request(method='DELETE', url=url, params=params, headers=headers,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response


def add_autoauth(url, authobject):
    """"""Registers given AuthObject to given URL domain. for auto-activation.
    Once a URL is registered with an AuthObject, the configured HTTP
    Authentication will be used for all requests with URLS containing the given
    URL string.

    Example: ::
        >>> c_auth = requests.AuthObject('kennethreitz', 'xxxxxxx')
        >>> requests.add_autoauth('https://convore.com/api/', c_auth)
        >>> r = requests.get('https://convore.com/api/account/verify.json')
        # Automatically HTTP Authenticated! Wh00t!

    :param url: Base URL for given AuthObject to auto-activate for.
    :param authobject: AuthObject to auto-activate.
    """"""

    global AUTOAUTHS
    
    AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):
    """"""Returns registered AuthObject for given url if available, defaulting to
    given AuthObject.
    """"""

    return _get_autoauth(url) if not auth else auth

    
def _get_autoauth(url):
    """"""Returns registered AuthObject for given url if available.""""""
    
    for (autoauth_url, auth) in AUTOAUTHS:
        if autoauth_url in url: 
            return auth
            
    return None


class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""
    
class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""
    
class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import
import urllib
import urllib2

from urllib2 import HTTPError

try:
    import eventlet
    eventlet.monkey_patch()
except ImportError:
    pass

if not 'eventlet' in locals():
    try:
        from gevent import monkey
        monkey.patch_all()
    except ImportError:
        pass

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers


__title__ = 'requests'
__version__ = '0.2.3'
__build__ = 0x000203
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []



class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""
    
    def __init__(self, url, data=None, headers={}, origin_req_host=None,
                 unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""
    
    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')
    
    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 params=dict(), data=dict(), auth=None, cookiejar=None):
        self.url = url
        self.headers = headers
        self.files = files
        self.method = method
        self.params = params
        self.data = data
        self.response = Response()
        
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False
        
        
    def __repr__(self):
        return '<Request [%s]>' % (self.method)
    
    
    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()
        
        object.__setattr__(self, name, value)
    
    
    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired

        
    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.auth or self.cookiejar:

            if self.auth:

                authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

                authr.add_password(None, self.url, self.auth.username, self.auth.password)
                auth_handler = urllib2.HTTPBasicAuthHandler(authr)

                _handlers.append(auth_handler)

            if self.cookiejar:

                cookie_handler = urllib2.HTTPCookieProcessor(cookiejar)
                _handlers.append(cookie_handler)

            opener = urllib2.build_opener(*_handlers)
            return opener.open

        else:
            return urllib2.urlopen


    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""
        
        self.response.status_code = resp.code
        self.response.headers = resp.info().dict
        self.response.content = resp.read()
        self.response.url = resp.url

    
    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""

        self._checks()

        success = False


        if self.method in ('GET', 'HEAD', 'DELETE'):
            if (not self.sent) or anyway:

                # url encode GET params if it's a dict
                if isinstance(self.params, dict):
                    params = urllib.urlencode(self.params)
                else:
                    params = self.params

                req = _Request((""%s?%s"" % (self.url, params)), method=self.method)

                if self.headers:
                    req.headers = self.headers

                opener = self._get_opener()

                try:
                    resp = opener(req)
                    self._build_response(resp)
                    self.response.ok = True

                except urllib2.HTTPError, why:
                    self._build_response(why)
                    self.response.error = why


        elif self.method == 'PUT':
            if (not self.sent) or anyway:

                if self.files:
                    register_openers()
                    datagen, headers = multipart_encode(self.files)
                    req = _Request(self.url, data=datagen, headers=headers, method='PUT')

                    if self.headers:
                        req.headers.update(self.headers)

                else:

                    req = _Request(self.url, method='PUT')

                    if self.headers:
                        req.headers = self.headers

                    req.data = self.data

                try:
                    opener = self._get_opener()
                    resp =  opener(req)

                    self._build_response(resp)
                    self.response.ok = True

                except urllib2.HTTPError, why:
                    self._build_response(why)
                    self.response.error = why


        elif self.method == 'POST':
            if (not self.sent) or anyway:

                if self.files:
                    register_openers()
                    datagen, headers = multipart_encode(self.files)
                    req = _Request(self.url, data=datagen, headers=headers, method='POST')

                    if self.headers:
                        req.headers.update(self.headers)
                
                else:
                    req = _Request(self.url, method='POST')
                    req.headers = self.headers

                    # url encode form data if it's a dict
                    if isinstance(self.data, dict):
                        req.data = urllib.urlencode(self.data)
                    else:
                        req.data = self.data

                try:
                    opener = self._get_opener()
                    resp =  opener(req)

                    self._build_response(resp)
                    self.response.ok = True

                except urllib2.HTTPError, why:
                    self._build_response(why)
                    self.response.error = why
        
        self.sent = self.response.ok
        
        return self.sent
        

class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        
    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)
        
    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error
        
    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error


    
class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.
    
    :param username: Username to authenticate with.
    :param password: Password for given username.
    """"""
    
    def __init__(self, username, password):
        self.username = username
        self.password = password



def get(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    
    r = Request(method='GET', url=url, params=params, headers=headers,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response


def head(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    r = Request(method='HEAD', url=url, params=params, headers=headers,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    
    r = Request(method='POST', url=url, data=data, headers=headers,
                files=files, cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response
    
    
def put(url, data='', headers={}, files={}, cookies=None, auth=None):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    r = Request(method='PUT', url=url, data=data, headers=headers, files=files,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response

    
def delete(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    
    r = Request(method='DELETE', url=url, params=params, headers=headers,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response


def add_autoauth(url, authobject):
    """"""Registers given AuthObject to given URL domain. for auto-activation.
    Once a URL is registered with an AuthObject, the configured HTTP
    Authentication will be used for all requests with URLS containing the given
    URL string.

    Example: ::
        >>> c_auth = requests.AuthObject('kennethreitz', 'xxxxxxx')
        >>> requests.add_autoauth('https://convore.com/api/', c_auth)
        >>> r = requests.get('https://convore.com/api/account/verify.json')
        # Automatically HTTP Authenticated! Wh00t!

    :param url: Base URL for given AuthObject to auto-activate for.
    :param authobject: AuthObject to auto-activate.
    """"""

    global AUTOAUTHS
    
    AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):
    """"""Returns registered AuthObject for given url if available, defaulting to
    given AuthObject.
    """"""

    return _get_autoauth(url) if not auth else auth

    
def _get_autoauth(url):
    """"""Returns registered AuthObject for given url if available.""""""
    
    for (autoauth_url, auth) in AUTOAUTHS:
        if autoauth_url in url: 
            return auth
            
    return None


class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""
    
class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""
    
class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","@@ -177,7 +177,7 @@ class Request(object):
                     self._build_response(resp)
                     self.response.ok = True
 
-                except urllib2.HTTPError as why:
+                except urllib2.HTTPError, why:
                     self._build_response(why)
                     self.response.error = why
 
@@ -209,7 +209,7 @@ class Request(object):
                     self._build_response(resp)
                     self.response.ok = True
 
-                except urllib2.HTTPError as why:
+                except urllib2.HTTPError, why:
                     self._build_response(why)
                     self.response.error = why
 
@@ -242,7 +242,7 @@ class Request(object):
                     self._build_response(resp)
                     self.response.ok = True
 
-                except urllib2.HTTPError as why:
+                except urllib2.HTTPError, why:
                     self._build_response(why)
                     self.response.error = why
         
",fix typo in request.py,[requests/core.py] fix typo in request.py,53.3113326951571,11.0,434.0,0.0,0.0,0.0,-53.3113326951571,-11.0,-434.0,1.0,0.9974926844590755,Minor,Minor,YES
b82e72eb04156f269aa393b1805e7d9de48f6b62,cStringIO fix.,test_requests.py,"#!/usr/bin/env python
# -*- coding: utf-8 -*-

import unittest
from cStringIO import StringIO

import requests


class RequestsTestSuite(unittest.TestCase):
    """"""Requests test cases.""""""
    
    def setUp(self):
        pass

    def tearDown(self):
        """"""Teardown.""""""
        pass
        
    def test_invalid_url(self):
        self.assertRaises(ValueError, requests.get, 'hiwpefhipowhefopw')


    def test_HTTP_200_OK_GET(self):
        r = requests.get('http://google.com')
        self.assertEqual(r.status_code, 200)


    def test_HTTPS_200_OK_GET(self):
        r = requests.get('https://google.com')
        self.assertEqual(r.status_code, 200)


    def test_HTTP_200_OK_HEAD(self):
        r = requests.head('http://google.com')
        self.assertEqual(r.status_code, 200)


    def test_HTTPS_200_OK_HEAD(self):
        r = requests.head('https://google.com')
        self.assertEqual(r.status_code, 200)


    def test_AUTH_HTTPS_200_OK_GET(self):
        auth = requests.AuthObject('requeststest', 'requeststest')
        url = 'https://convore.com/api/account/verify.json'
        r = requests.get(url, auth=auth)

        self.assertEqual(r.status_code, 200)


    def test_POSTBIN_GET_POST_FILES(self):

        bin = requests.post('http://www.postbin.org/')
        self.assertEqual(bin.status_code, 200)

        post = requests.post(bin.url, data={'some': 'data'})
        self.assertEqual(post.status_code, 201)

        post2 = requests.post(bin.url, files={'some': StringIO('data')})
        self.assertEqual(post2.status_code, 201)


    def test_nonzero_evaluation(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(bool(r), False)
    
        r = requests.get('http://google.com/')
        self.assertEqual(bool(r), True)


    def test_request_ok_set(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(r.ok, False)


    def test_status_raising(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertRaises(requests.HTTPError, r.raise_for_status)

        r = requests.get('http://google.com/')
        self.assertFalse(r.error)
        r.raise_for_status()


if __name__ == '__main__':
    unittest.main()
","#!/usr/bin/env python
# -*- coding: utf-8 -*-

import unittest

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

import requests


class RequestsTestSuite(unittest.TestCase):
    """"""Requests test cases.""""""
    
    def setUp(self):
        pass

    def tearDown(self):
        """"""Teardown.""""""
        pass
        
    def test_invalid_url(self):
        self.assertRaises(ValueError, requests.get, 'hiwpefhipowhefopw')


    def test_HTTP_200_OK_GET(self):
        r = requests.get('http://google.com')
        self.assertEqual(r.status_code, 200)


    def test_HTTPS_200_OK_GET(self):
        r = requests.get('https://google.com')
        self.assertEqual(r.status_code, 200)


    def test_HTTP_200_OK_HEAD(self):
        r = requests.head('http://google.com')
        self.assertEqual(r.status_code, 200)


    def test_HTTPS_200_OK_HEAD(self):
        r = requests.head('https://google.com')
        self.assertEqual(r.status_code, 200)


    def test_AUTH_HTTPS_200_OK_GET(self):
        auth = requests.AuthObject('requeststest', 'requeststest')
        url = 'https://convore.com/api/account/verify.json'
        r = requests.get(url, auth=auth)

        self.assertEqual(r.status_code, 200)


    def test_POSTBIN_GET_POST_FILES(self):

        bin = requests.post('http://www.postbin.org/')
        self.assertEqual(bin.status_code, 200)

        post = requests.post(bin.url, data={'some': 'data'})
        self.assertEqual(post.status_code, 201)

        post2 = requests.post(bin.url, files={'some': StringIO('data')})
        self.assertEqual(post2.status_code, 201)


    def test_nonzero_evaluation(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(bool(r), False)
    
        r = requests.get('http://google.com/')
        self.assertEqual(bool(r), True)


    def test_request_ok_set(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(r.ok, False)


    def test_status_raising(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertRaises(requests.HTTPError, r.raise_for_status)

        r = requests.get('http://google.com/')
        self.assertFalse(r.error)
        r.raise_for_status()


if __name__ == '__main__':
    unittest.main()
","@@ -2,7 +2,11 @@
 # -*- coding: utf-8 -*-
 
 import unittest
-from cStringIO import StringIO
+
+try:
+    from cStringIO import StringIO
+except ImportError:
+    from StringIO import StringIO
 
 import requests
 
",add missing import,[test_requests.py] add missing import,67.35878248263157,0.0,87.0,66.39274911959212,0.0,91.0,-0.9660333630394432,0.0,4.0,0.9996576905250549,0.983023830816816,Minor,Minor,YES
fbe0393eb34e975022cd3bf884dc94a6f5aa886d,cstring io fix for py3,test_requests.py,"#!/usr/bin/env python
# -*- coding: utf-8 -*-

import unittest

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

import requests


class RequestsTestSuite(unittest.TestCase):
    """"""Requests test cases.""""""
    
    def setUp(self):
        pass

    def tearDown(self):
        """"""Teardown.""""""
        pass
        
    def test_invalid_url(self):
        self.assertRaises(ValueError, requests.get, 'hiwpefhipowhefopw')


    def test_HTTP_200_OK_GET(self):
        r = requests.get('http://google.com')
        self.assertEqual(r.status_code, 200)


    def test_HTTPS_200_OK_GET(self):
        r = requests.get('https://google.com')
        self.assertEqual(r.status_code, 200)


    def test_HTTP_200_OK_HEAD(self):
        r = requests.head('http://google.com')
        self.assertEqual(r.status_code, 200)


    def test_HTTPS_200_OK_HEAD(self):
        r = requests.head('https://google.com')
        self.assertEqual(r.status_code, 200)


    def test_AUTH_HTTPS_200_OK_GET(self):
        auth = requests.AuthObject('requeststest', 'requeststest')
        url = 'https://convore.com/api/account/verify.json'
        r = requests.get(url, auth=auth)

        self.assertEqual(r.status_code, 200)


    def test_POSTBIN_GET_POST_FILES(self):

        bin = requests.post('http://www.postbin.org/')
        self.assertEqual(bin.status_code, 200)

        post = requests.post(bin.url, data={'some': 'data'})
        self.assertEqual(post.status_code, 201)

        post2 = requests.post(bin.url, files={'some': StringIO('data')})
        self.assertEqual(post2.status_code, 201)


    def test_nonzero_evaluation(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(bool(r), False)
    
        r = requests.get('http://google.com/')
        self.assertEqual(bool(r), True)


    def test_request_ok_set(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(r.ok, False)


    def test_status_raising(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertRaises(requests.HTTPError, r.raise_for_status)

        r = requests.get('http://google.com/')
        self.assertFalse(r.error)
        r.raise_for_status()


if __name__ == '__main__':
    unittest.main()
","#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import unittest

if sys.version_info >= (3,0):
    from io import StringIO
else:
    try:
        from cStringIO import StringIO
    except ImportError:
        from StringIO import StringIO

import requests


class RequestsTestSuite(unittest.TestCase):
    """"""Requests test cases.""""""
    
    def setUp(self):
        pass

    def tearDown(self):
        """"""Teardown.""""""
        pass
        
    def test_invalid_url(self):
        self.assertRaises(ValueError, requests.get, 'hiwpefhipowhefopw')


    def test_HTTP_200_OK_GET(self):
        r = requests.get('http://google.com')
        self.assertEqual(r.status_code, 200)


    def test_HTTPS_200_OK_GET(self):
        r = requests.get('https://google.com')
        self.assertEqual(r.status_code, 200)


    def test_HTTP_200_OK_HEAD(self):
        r = requests.head('http://google.com')
        self.assertEqual(r.status_code, 200)


    def test_HTTPS_200_OK_HEAD(self):
        r = requests.head('https://google.com')
        self.assertEqual(r.status_code, 200)


    def test_AUTH_HTTPS_200_OK_GET(self):
        auth = requests.AuthObject('requeststest', 'requeststest')
        url = 'https://convore.com/api/account/verify.json'
        r = requests.get(url, auth=auth)

        self.assertEqual(r.status_code, 200)


    def test_POSTBIN_GET_POST_FILES(self):

        bin = requests.post('http://www.postbin.org/')
        self.assertEqual(bin.status_code, 200)

        post = requests.post(bin.url, data={'some': 'data'})
        self.assertEqual(post.status_code, 201)

        post2 = requests.post(bin.url, files={'some': StringIO('data')})
        self.assertEqual(post2.status_code, 201)


    def test_nonzero_evaluation(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(bool(r), False)
    
        r = requests.get('http://google.com/')
        self.assertEqual(bool(r), True)


    def test_request_ok_set(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(r.ok, False)


    def test_status_raising(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertRaises(requests.HTTPError, r.raise_for_status)

        r = requests.get('http://google.com/')
        self.assertFalse(r.error)
        r.raise_for_status()


if __name__ == '__main__':
    unittest.main()
","@@ -1,12 +1,16 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
 
+import sys
 import unittest
 
-try:
-    from cStringIO import StringIO
-except ImportError:
-    from StringIO import StringIO
+if sys.version_info >= (3,0):
+    from io import StringIO
+else:
+    try:
+        from cStringIO import StringIO
+    except ImportError:
+        from StringIO import StringIO
 
 import requests
 
",add missing import,[test_requests.py] add missing import,66.39274911959212,0.0,91.0,61.6323849760955,0.0,95.0,-4.760364143496624,0.0,4.0,0.9995205402374268,0.9663277487906343,Minor,Minor,YES
e8234a013752ee8bae05c142d1950023c4a9fa8b,import fix,requests/__init__.py,"# -*- coding: utf-8 -*-

import packages
from core import *



","# -*- coding: utf-8 -*-

from __future__ import absolute_import

from . import packages
from .core import *



","@@ -1,7 +1,9 @@
 # -*- coding: utf-8 -*-
 
-import packages
-from core import *
+from __future__ import absolute_import
+
+from . import packages
+from .core import *
 
 
 
",add missing import,[requests/__init__.py] add missing import,100.0,0.0,7.0,100.0,0.0,9.0,0.0,0.0,2.0,0.9910556077957153,0.37502289167669306,Minor,Major,NO
5072399f7af38ab14d638838a5e45818ca9ede41,Import fix for python2.5,requests/__init__.py,"# -*- coding: utf-8 -*-

from __future__ import absolute_import

from . import packages
from .core import *



","# -*- coding: utf-8 -*-

import packages
from core import *



","@@ -1,9 +1,7 @@
 # -*- coding: utf-8 -*-
 
-from __future__ import absolute_import
-
-from . import packages
-from .core import *
+import packages
+from core import *
 
 
 
",add missing import,[requests/__init__.py] add missing import,100.0,0.0,9.0,100.0,0.0,7.0,0.0,0.0,-2.0,0.9910556077957153,0.310235892664585,Minor,Major,NO
f96157d259e43d9dfa9adeae54a9779004d35cf6,Fix a syntax error on py2.5 and pypy,requests/core.py,"# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import
import urllib
import urllib2
from urllib2 import HTTPError

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers

__all__ = ['Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete', 'auth_manager', 'AuthObject',
           'RequestException', 'AuthenticationError', 'URLRequired', 'InvalidMethod', 'HTTPError']
__title__ = 'requests'
__version__ = '0.2.5'
__build__ = 0x000205
__author__ = 'Kenneth Reitz, Dj Gilcrease'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'

class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""

    def __init__(self, url, data=None, headers={}, origin_req_host=None,
                 unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""

    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')

    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 data=dict(), auth=None, cookiejar=None):
        self.url = url
        self.headers = headers
        self.files = files
        self.method = method

        # url encode data if it's a dict
        if isinstance(data, dict):
            self.data = urllib.urlencode(data)
        else:
            self.data = data

        self.response = Response()

        if isinstance(auth, (list, tuple)):
            auth = AuthObject(*auth)
        if not auth:
            auth = auth_manager.get_auth(self.url)
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False

    def __repr__(self):
        return '<Request [%s]>' % (self.method)

    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()

        object.__setattr__(self, name, value)

    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired

    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.auth:
            if not isinstance(self.auth.handler, (urllib2.AbstractBasicAuthHandler, urllib2.AbstractDigestAuthHandler)):
                auth_manager.add_password(self.auth.realm, self.url, self.auth.username, self.auth.password)
                self.auth.handler = self.auth.handler(auth_manager)
                auth_manager.add_auth(self.url, self.auth)

            _handlers.append(self.auth.handler)

        if self.cookiejar:
            cookie_handler = urllib2.HTTPCookieProcessor(cookiejar)
            _handlers.append(cookie_handler)
        if _handlers:
            opener = urllib2.build_opener(*_handlers)
            return opener.open
        else:
            return urllib2.urlopen


    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""

        self.response.status_code = resp.code
        self.response.headers = resp.info().dict or resp.headers
        self.response.content = resp.read()
        self.response.url = resp.url


    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""
        self._checks()
        success = False

        if self.method in ('GET', 'HEAD', 'DELETE'):
            req = _Request((""%s?%s"" % (self.url, self.data)), method=self.method)
        else:
            if self.files:
                register_openers()
                datagen, headers = multipart_encode(self.files)
                req = _Request(self.url, data=datagen, headers=headers, method=self.method)
            else:
                req = _Request(self.url, method=self.method)

            if self.data:
                req.data = self.data

        if self.headers:
            req.headers = self.headers

        if not self.sent or anyway:
            try:
                opener = self._get_opener()
                resp =  opener(req)
            except urllib2.HTTPError, why:
                self._build_response(why)
                self.response.error = why
            else:
                self._build_response(resp)
                self.response.ok = True

            self.response.cached = False
        else:
            self.response.cached = True


        self.sent = self.response.ok

        return self.sent


class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        self.cached = False

    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)

    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error

    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error

class AuthManager(object):
    def __new__(cls):
        singleton = cls.__dict__.get('__singleton__')
        if singleton is not None:
            return singleton

        cls.__singleton__ = singleton = object.__new__(cls)

        return singleton

    def __init__(self):
        self.passwd = {}
        self._auth = {}

    def add_auth(self, uri, auth):
        uri = self.reduce_uri(uri, False)
        self._auth[uri] = auth

    def add_password(self, realm, uri, user, passwd):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]
        reduced_uri = tuple([self.reduce_uri(u, False) for u in uri])
        if reduced_uri not in self.passwd:
            self.passwd[reduced_uri] = {}
        self.passwd[reduced_uri] = (user, passwd)

    def find_user_password(self, realm, authuri):
        for uris, authinfo in self.passwd.iteritems():
            reduced_authuri = self.reduce_uri(authuri, False)
            for uri in uris:
                if self.is_suburi(uri, reduced_authuri):
                    return authinfo

        return (None, None)

    def get_auth(self, uri):
        uri = self.reduce_uri(uri, False)
        return self._auth.get(uri, None)

    def reduce_uri(self, uri, default_port=True):
        """"""Accept authority or URI and extract only the authority and path.""""""
        # note HTTP URLs do not have a userinfo component
        parts = urllib2.urlparse.urlsplit(uri)
        if parts[1]:
            # URI
            scheme = parts[0]
            authority = parts[1]
            path = parts[2] or '/'
        else:
            # host or host:port
            scheme = None
            authority = uri
            path = '/'
        host, port = urllib2.splitport(authority)
        if default_port and port is None and scheme is not None:
            dport = {""http"": 80,
                     ""https"": 443,
                     }.get(scheme)
            if dport is not None:
                authority = ""%s:%d"" % (host, dport)
        return authority, path

    def is_suburi(self, base, test):
        """"""Check if test is below base in a URI tree

        Both args must be URIs in reduced form.
        """"""
        if base == test:
            return True
        if base[0] != test[0]:
            return False
        common = urllib2.posixpath.commonprefix((base[1], test[1]))
        if len(common) == len(base[1]):
            return True
        return False

    def empty(self):
        self.passwd = {}

    def remove(self, uri, realm=None):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        for default_port in True, False:
            reduced_uri = tuple([self.reduce_uri(u, default_port) for u in uri])
            del self.passwd[reduced_uri][realm]

    def __contains__(self, uri):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        uri = tuple([self.reduce_uri(u, False) for u in uri])

        if uri in self.passwd:
            return True

        return False

auth_manager = AuthManager()


class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.

    :param username: Username to authenticate with.
    :param password: Password for given username.
    :param realm: (optional) the realm this auth applies to
    :param handler: (optional) basic || digest || proxy_basic || proxy_digest
    """"""

    _handlers = {
        'basic': urllib2.HTTPBasicAuthHandler,
        'digest': urllib2.HTTPDigestAuthHandler,
        'proxy_basic': urllib2.ProxyBasicAuthHandler,
        'proxy_digest': urllib2.ProxyDigestAuthHandler
    }

    def __init__(self, username, password, handler='basic', realm=None):
        self.username = username
        self.password = password
        self.realm = realm

        if isinstance(handler, basestring):
            self.handler = self._handlers.get(handler.lower(), urllib2.HTTPBasicAuthHandler)
        else:
            self.handler = handler


def request(method, url, **kwargs):
    """"""Sends a `method` request. Returns :class:`Response` object.

    :param method: method for the new :class:`Request` object.
    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET/HEAD/DELETE Parameters to send with the :class:`Request`.
    :param data: (optional) Bytes/Dictionary of PUT/POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    data = kwargs.pop('data', {}) or kwargs.pop('params', {})

    r = Request(method=method, url=url, data=data, headers=kwargs.pop('headers', {}),
                cookiejar=kwargs.pop('cookies', None), files=kwargs.pop('files', None),
                auth=kwargs.pop('auth', auth_manager.get_auth(url)))
    r.send()

    return r.response

def get(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('GET', url, params=params, headers=headers, cookiejar=cookies, auth=auth)


def head(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('HEAD', url, params=params, headers=headers, cookiejar=cookies, auth=auth)


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('POST', url, data=data, headers=headers, files=files, cookiejar=cookies, auth=auth)


def put(url, data=b'', headers={}, files={}, cookies=None, auth=None):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('PUT', url, data=data, headers=headers, files=files, cookiejar=cookies, auth=auth)


def delete(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of DELETE Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('DELETE', url, params=params, headers=headers, cookiejar=cookies, auth=auth)

class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""

class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""

class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import
import urllib
import urllib2
from urllib2 import HTTPError

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers

__all__ = ['Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete', 'auth_manager', 'AuthObject',
           'RequestException', 'AuthenticationError', 'URLRequired', 'InvalidMethod', 'HTTPError']
__title__ = 'requests'
__version__ = '0.2.5'
__build__ = 0x000205
__author__ = 'Kenneth Reitz, Dj Gilcrease'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'

class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""

    def __init__(self, url, data=None, headers={}, origin_req_host=None,
                 unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""

    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')

    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 data=dict(), auth=None, cookiejar=None):
        self.url = url
        self.headers = headers
        self.files = files
        self.method = method

        # url encode data if it's a dict
        if isinstance(data, dict):
            self.data = urllib.urlencode(data)
        else:
            self.data = data

        self.response = Response()

        if isinstance(auth, (list, tuple)):
            auth = AuthObject(*auth)
        if not auth:
            auth = auth_manager.get_auth(self.url)
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False

    def __repr__(self):
        return '<Request [%s]>' % (self.method)

    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()

        object.__setattr__(self, name, value)

    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired

    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.auth:
            if not isinstance(self.auth.handler, (urllib2.AbstractBasicAuthHandler, urllib2.AbstractDigestAuthHandler)):
                auth_manager.add_password(self.auth.realm, self.url, self.auth.username, self.auth.password)
                self.auth.handler = self.auth.handler(auth_manager)
                auth_manager.add_auth(self.url, self.auth)

            _handlers.append(self.auth.handler)

        if self.cookiejar:
            cookie_handler = urllib2.HTTPCookieProcessor(cookiejar)
            _handlers.append(cookie_handler)
        if _handlers:
            opener = urllib2.build_opener(*_handlers)
            return opener.open
        else:
            return urllib2.urlopen


    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""

        self.response.status_code = resp.code
        self.response.headers = resp.info().dict or resp.headers
        self.response.content = resp.read()
        self.response.url = resp.url


    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""
        self._checks()
        success = False

        if self.method in ('GET', 'HEAD', 'DELETE'):
            req = _Request((""%s?%s"" % (self.url, self.data)), method=self.method)
        else:
            if self.files:
                register_openers()
                datagen, headers = multipart_encode(self.files)
                req = _Request(self.url, data=datagen, headers=headers, method=self.method)
            else:
                req = _Request(self.url, method=self.method)

            if self.data:
                req.data = self.data

        if self.headers:
            req.headers = self.headers

        if not self.sent or anyway:
            try:
                opener = self._get_opener()
                resp =  opener(req)
            except urllib2.HTTPError, why:
                self._build_response(why)
                self.response.error = why
            else:
                self._build_response(resp)
                self.response.ok = True

            self.response.cached = False
        else:
            self.response.cached = True


        self.sent = self.response.ok

        return self.sent


class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        self.cached = False

    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)

    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error

    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error

class AuthManager(object):
    def __new__(cls):
        singleton = cls.__dict__.get('__singleton__')
        if singleton is not None:
            return singleton

        cls.__singleton__ = singleton = object.__new__(cls)

        return singleton

    def __init__(self):
        self.passwd = {}
        self._auth = {}

    def add_auth(self, uri, auth):
        uri = self.reduce_uri(uri, False)
        self._auth[uri] = auth

    def add_password(self, realm, uri, user, passwd):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]
        reduced_uri = tuple([self.reduce_uri(u, False) for u in uri])
        if reduced_uri not in self.passwd:
            self.passwd[reduced_uri] = {}
        self.passwd[reduced_uri] = (user, passwd)

    def find_user_password(self, realm, authuri):
        for uris, authinfo in self.passwd.iteritems():
            reduced_authuri = self.reduce_uri(authuri, False)
            for uri in uris:
                if self.is_suburi(uri, reduced_authuri):
                    return authinfo

        return (None, None)

    def get_auth(self, uri):
        uri = self.reduce_uri(uri, False)
        return self._auth.get(uri, None)

    def reduce_uri(self, uri, default_port=True):
        """"""Accept authority or URI and extract only the authority and path.""""""
        # note HTTP URLs do not have a userinfo component
        parts = urllib2.urlparse.urlsplit(uri)
        if parts[1]:
            # URI
            scheme = parts[0]
            authority = parts[1]
            path = parts[2] or '/'
        else:
            # host or host:port
            scheme = None
            authority = uri
            path = '/'
        host, port = urllib2.splitport(authority)
        if default_port and port is None and scheme is not None:
            dport = {""http"": 80,
                     ""https"": 443,
                     }.get(scheme)
            if dport is not None:
                authority = ""%s:%d"" % (host, dport)
        return authority, path

    def is_suburi(self, base, test):
        """"""Check if test is below base in a URI tree

        Both args must be URIs in reduced form.
        """"""
        if base == test:
            return True
        if base[0] != test[0]:
            return False
        common = urllib2.posixpath.commonprefix((base[1], test[1]))
        if len(common) == len(base[1]):
            return True
        return False

    def empty(self):
        self.passwd = {}

    def remove(self, uri, realm=None):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        for default_port in True, False:
            reduced_uri = tuple([self.reduce_uri(u, default_port) for u in uri])
            del self.passwd[reduced_uri][realm]

    def __contains__(self, uri):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        uri = tuple([self.reduce_uri(u, False) for u in uri])

        if uri in self.passwd:
            return True

        return False

auth_manager = AuthManager()


class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.

    :param username: Username to authenticate with.
    :param password: Password for given username.
    :param realm: (optional) the realm this auth applies to
    :param handler: (optional) basic || digest || proxy_basic || proxy_digest
    """"""

    _handlers = {
        'basic': urllib2.HTTPBasicAuthHandler,
        'digest': urllib2.HTTPDigestAuthHandler,
        'proxy_basic': urllib2.ProxyBasicAuthHandler,
        'proxy_digest': urllib2.ProxyDigestAuthHandler
    }

    def __init__(self, username, password, handler='basic', realm=None):
        self.username = username
        self.password = password
        self.realm = realm

        if isinstance(handler, basestring):
            self.handler = self._handlers.get(handler.lower(), urllib2.HTTPBasicAuthHandler)
        else:
            self.handler = handler


def request(method, url, **kwargs):
    """"""Sends a `method` request. Returns :class:`Response` object.

    :param method: method for the new :class:`Request` object.
    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET/HEAD/DELETE Parameters to send with the :class:`Request`.
    :param data: (optional) Bytes/Dictionary of PUT/POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    data = kwargs.pop('data', {}) or kwargs.pop('params', {})

    r = Request(method=method, url=url, data=data, headers=kwargs.pop('headers', {}),
                cookiejar=kwargs.pop('cookies', None), files=kwargs.pop('files', None),
                auth=kwargs.pop('auth', auth_manager.get_auth(url)))
    r.send()

    return r.response

def get(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('GET', url, params=params, headers=headers, cookiejar=cookies, auth=auth)


def head(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('HEAD', url, params=params, headers=headers, cookiejar=cookies, auth=auth)


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('POST', url, data=data, headers=headers, files=files, cookiejar=cookies, auth=auth)


def put(url, data='', headers={}, files={}, cookies=None, auth=None):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('PUT', url, data=data, headers=headers, files=files, cookiejar=cookies, auth=auth)


def delete(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of DELETE Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('DELETE', url, params=params, headers=headers, cookiejar=cookies, auth=auth)

class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""

class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""

class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","@@ -394,7 +394,7 @@ def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
     return request('POST', url, data=data, headers=headers, files=files, cookiejar=cookies, auth=auth)
 
 
-def put(url, data=b'', headers={}, files={}, cookies=None, auth=None):
+def put(url, data='', headers={}, files={}, cookies=None, auth=None):
     """"""Sends a PUT request. Returns :class:`Response` object.
 
     :param url: URL for the new :class:`Request` object.
",add missing comment,[requests/core.py] add missing comment,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.9993035725336555,Minor,Minor,YES
e788ca7ee629f7ed8700d31bbdf7a2930c1a7398,Safer error response handling.,requests/core.py,"# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import
import urllib
import urllib2

from urllib2 import HTTPError

try:
    import eventlet
    eventlet.monkey_patch()
except ImportError:
    pass

if not 'eventlet' in locals():
    try:
        from gevent import monkey
        monkey.patch_all()
    except ImportError:
        pass

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers


__title__ = 'requests'
__version__ = '0.2.4'
__build__ = 0x000204
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []



class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""
    
    def __init__(self, url, data=None, headers={}, origin_req_host=None,
                 unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""
    
    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')
    
    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 params=dict(), data=dict(), auth=None, cookiejar=None):
        self.url = url
        self.headers = headers
        self.files = files
        self.method = method
        self.params = params
        self.data = data
        self.response = Response()
        
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False
        
        
    def __repr__(self):
        return '<Request [%s]>' % (self.method)
    
    
    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()
        
        object.__setattr__(self, name, value)
    
    
    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired

        
    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.auth or self.cookiejar:

            if self.auth:

                authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

                authr.add_password(None, self.url, self.auth.username, self.auth.password)
                auth_handler = urllib2.HTTPBasicAuthHandler(authr)

                _handlers.append(auth_handler)

            if self.cookiejar:

                cookie_handler = urllib2.HTTPCookieProcessor(cookiejar)
                _handlers.append(cookie_handler)

            opener = urllib2.build_opener(*_handlers)
            return opener.open

        else:
            return urllib2.urlopen


    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""
        
        self.response.status_code = resp.code
        self.response.headers = resp.info().dict
        self.response.content = resp.read()
        self.response.url = resp.url

    
    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""

        self._checks()

        success = False


        if self.method in ('GET', 'HEAD', 'DELETE'):
            if (not self.sent) or anyway:

                # url encode GET params if it's a dict
                if isinstance(self.params, dict):
                    params = urllib.urlencode(self.params)
                else:
                    params = self.params

                req = _Request((""%s?%s"" % (self.url, params)), method=self.method)

                if self.headers:
                    req.headers = self.headers

                opener = self._get_opener()

                try:
                    resp = opener(req)
                    self._build_response(resp)
                    self.response.ok = True

                except urllib2.HTTPError, why:
                    self._build_response(why)
                    self.response.error = why


        elif self.method == 'PUT':
            if (not self.sent) or anyway:

                if self.files:
                    register_openers()
                    datagen, headers = multipart_encode(self.files)
                    req = _Request(self.url, data=datagen, headers=headers, method='PUT')

                    if self.headers:
                        req.headers.update(self.headers)

                else:

                    req = _Request(self.url, method='PUT')

                    if self.headers:
                        req.headers = self.headers

                    req.data = self.data

                try:
                    opener = self._get_opener()
                    resp =  opener(req)

                    self._build_response(resp)
                    self.response.ok = True

                except urllib2.HTTPError, why:
                    self._build_response(why)
                    self.response.error = why


        elif self.method == 'POST':
            if (not self.sent) or anyway:

                if self.files:
                    register_openers()
                    datagen, headers = multipart_encode(self.files)
                    req = _Request(self.url, data=datagen, headers=headers, method='POST')

                    if self.headers:
                        req.headers.update(self.headers)
                
                else:
                    req = _Request(self.url, method='POST')
                    req.headers = self.headers

                    # url encode form data if it's a dict
                    if isinstance(self.data, dict):
                        req.data = urllib.urlencode(self.data)
                    else:
                        req.data = self.data

                try:
                    opener = self._get_opener()
                    resp =  opener(req)

                    self._build_response(resp)
                    self.response.ok = True

                except urllib2.HTTPError, why:
                    self._build_response(why)
                    self.response.error = why
        
        self.sent = self.response.ok
        
        return self.sent
        

class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        
    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)
        
    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error
        
    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error


    
class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.
    
    :param username: Username to authenticate with.
    :param password: Password for given username.
    """"""
    
    def __init__(self, username, password):
        self.username = username
        self.password = password



def get(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    
    r = Request(method='GET', url=url, params=params, headers=headers,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response


def head(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    r = Request(method='HEAD', url=url, params=params, headers=headers,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    
    r = Request(method='POST', url=url, data=data, headers=headers,
                files=files, cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response
    
    
def put(url, data='', headers={}, files={}, cookies=None, auth=None):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    r = Request(method='PUT', url=url, data=data, headers=headers, files=files,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response

    
def delete(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    
    r = Request(method='DELETE', url=url, params=params, headers=headers,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response


def add_autoauth(url, authobject):
    """"""Registers given AuthObject to given URL domain. for auto-activation.
    Once a URL is registered with an AuthObject, the configured HTTP
    Authentication will be used for all requests with URLS containing the given
    URL string.

    Example: ::
        >>> c_auth = requests.AuthObject('kennethreitz', 'xxxxxxx')
        >>> requests.add_autoauth('https://convore.com/api/', c_auth)
        >>> r = requests.get('https://convore.com/api/account/verify.json')
        # Automatically HTTP Authenticated! Wh00t!

    :param url: Base URL for given AuthObject to auto-activate for.
    :param authobject: AuthObject to auto-activate.
    """"""

    global AUTOAUTHS
    
    AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):
    """"""Returns registered AuthObject for given url if available, defaulting to
    given AuthObject.
    """"""

    return _get_autoauth(url) if not auth else auth

    
def _get_autoauth(url):
    """"""Returns registered AuthObject for given url if available.""""""
    
    for (autoauth_url, auth) in AUTOAUTHS:
        if autoauth_url in url: 
            return auth
            
    return None


class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""
    
class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""
    
class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import
import urllib
import urllib2

from urllib2 import HTTPError

try:
    import eventlet
    eventlet.monkey_patch()
except ImportError:
    pass

if not 'eventlet' in locals():
    try:
        from gevent import monkey
        monkey.patch_all()
    except ImportError:
        pass

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers


__title__ = 'requests'
__version__ = '0.2.4'
__build__ = 0x000204
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []



class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""
    
    def __init__(self, url, data=None, headers={}, origin_req_host=None,
                 unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""
    
    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')
    
    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 params=dict(), data=dict(), auth=None, cookiejar=None):
        self.url = url
        self.headers = headers
        self.files = files
        self.method = method
        self.params = params
        self.data = data
        self.response = Response()
        
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False
        
        
    def __repr__(self):
        return '<Request [%s]>' % (self.method)
    
    
    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()
        
        object.__setattr__(self, name, value)
    
    
    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired

        
    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.auth or self.cookiejar:

            if self.auth:

                authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

                authr.add_password(None, self.url, self.auth.username, self.auth.password)
                auth_handler = urllib2.HTTPBasicAuthHandler(authr)

                _handlers.append(auth_handler)

            if self.cookiejar:

                cookie_handler = urllib2.HTTPCookieProcessor(cookiejar)
                _handlers.append(cookie_handler)

            opener = urllib2.build_opener(*_handlers)
            return opener.open

        else:
            return urllib2.urlopen


    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""
        
        self.response.status_code = getattr(resp, 'code', None)
        self.response.headers = getattr(resp.info(), 'dict', None)
        self.response.url = getattr(resp, 'url', None)
        self.response.content = resp.read()

    
    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""

        self._checks()

        success = False


        if self.method in ('GET', 'HEAD', 'DELETE'):
            if (not self.sent) or anyway:

                # url encode GET params if it's a dict
                if isinstance(self.params, dict):
                    params = urllib.urlencode(self.params)
                else:
                    params = self.params

                req = _Request((""%s?%s"" % (self.url, params)), method=self.method)

                if self.headers:
                    req.headers = self.headers

                opener = self._get_opener()

                try:
                    resp = opener(req)
                    self._build_response(resp)
                    self.response.ok = True

                except urllib2.HTTPError, why:
                    self._build_response(why)
                    self.response.error = why


        elif self.method == 'PUT':
            if (not self.sent) or anyway:

                if self.files:
                    register_openers()
                    datagen, headers = multipart_encode(self.files)
                    req = _Request(self.url, data=datagen, headers=headers, method='PUT')

                    if self.headers:
                        req.headers.update(self.headers)

                else:

                    req = _Request(self.url, method='PUT')

                    if self.headers:
                        req.headers = self.headers

                    req.data = self.data

                try:
                    opener = self._get_opener()
                    resp =  opener(req)

                    self._build_response(resp)
                    self.response.ok = True

                except urllib2.HTTPError, why:
                    self._build_response(why)
                    self.response.error = why


        elif self.method == 'POST':
            if (not self.sent) or anyway:

                if self.files:
                    register_openers()
                    datagen, headers = multipart_encode(self.files)
                    req = _Request(self.url, data=datagen, headers=headers, method='POST')

                    if self.headers:
                        req.headers.update(self.headers)
                
                else:
                    req = _Request(self.url, method='POST')
                    req.headers = self.headers

                    # url encode form data if it's a dict
                    if isinstance(self.data, dict):
                        req.data = urllib.urlencode(self.data)
                    else:
                        req.data = self.data

                try:
                    opener = self._get_opener()
                    resp =  opener(req)

                    self._build_response(resp)
                    self.response.ok = True

                except urllib2.HTTPError, why:
                    self._build_response(why)
                    self.response.error = why
        
        self.sent = self.response.ok
        
        return self.sent
        

class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        
    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)
        
    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error
        
    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error


    
class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.
    
    :param username: Username to authenticate with.
    :param password: Password for given username.
    """"""
    
    def __init__(self, username, password):
        self.username = username
        self.password = password



def get(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    
    r = Request(method='GET', url=url, params=params, headers=headers,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response


def head(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    r = Request(method='HEAD', url=url, params=params, headers=headers,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    
    r = Request(method='POST', url=url, data=data, headers=headers,
                files=files, cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response
    
    
def put(url, data='', headers={}, files={}, cookies=None, auth=None):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    r = Request(method='PUT', url=url, data=data, headers=headers, files=files,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response

    
def delete(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    
    r = Request(method='DELETE', url=url, params=params, headers=headers,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response


def add_autoauth(url, authobject):
    """"""Registers given AuthObject to given URL domain. for auto-activation.
    Once a URL is registered with an AuthObject, the configured HTTP
    Authentication will be used for all requests with URLS containing the given
    URL string.

    Example: ::
        >>> c_auth = requests.AuthObject('kennethreitz', 'xxxxxxx')
        >>> requests.add_autoauth('https://convore.com/api/', c_auth)
        >>> r = requests.get('https://convore.com/api/account/verify.json')
        # Automatically HTTP Authenticated! Wh00t!

    :param url: Base URL for given AuthObject to auto-activate for.
    :param authobject: AuthObject to auto-activate.
    """"""

    global AUTOAUTHS
    
    AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):
    """"""Returns registered AuthObject for given url if available, defaulting to
    given AuthObject.
    """"""

    return _get_autoauth(url) if not auth else auth

    
def _get_autoauth(url):
    """"""Returns registered AuthObject for given url if available.""""""
    
    for (autoauth_url, auth) in AUTOAUTHS:
        if autoauth_url in url: 
            return auth
            
    return None


class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""
    
class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""
    
class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","@@ -134,10 +134,10 @@ class Request(object):
     def _build_response(self, resp):
         """"""Build internal Response object from given response.""""""
         
-        self.response.status_code = resp.code
-        self.response.headers = resp.info().dict
+        self.response.status_code = getattr(resp, 'code', None)
+        self.response.headers = getattr(resp.info(), 'dict', None)
+        self.response.url = getattr(resp, 'url', None)
         self.response.content = resp.read()
-        self.response.url = resp.url
 
     
     def send(self, anyway=False):
",add missing attributes to request class,[requests/core.py] add missing attributes to request class,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.9902716093706408,Minor,Minor,YES
6f5b64bca68489c31c7f5a62a31024bf0ddd8aa9,small workaround for issue #7,requests/core.py,"# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import
import urllib
import urllib2

from urllib2 import HTTPError

try:
    import eventlet
    eventlet.monkey_patch()
except ImportError:
    pass

if not 'eventlet' in locals():
    try:
        from gevent import monkey
        monkey.patch_all()
    except ImportError:
        pass

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers


__title__ = 'requests'
__version__ = '0.2.4'
__build__ = 0x000204
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []



class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""
    
    def __init__(self, url, data=None, headers={}, origin_req_host=None,
                 unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""
    
    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')
    
    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 params=dict(), data=dict(), auth=None, cookiejar=None):
        self.url = url
        self.headers = headers
        self.files = files
        self.method = method
        self.params = params
        self.data = data
        self.response = Response()
        
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False
        
        
    def __repr__(self):
        return '<Request [%s]>' % (self.method)
    
    
    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()
        
        object.__setattr__(self, name, value)
    
    
    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired

        
    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.auth or self.cookiejar:

            if self.auth:

                authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

                authr.add_password(None, self.url, self.auth.username, self.auth.password)
                auth_handler = urllib2.HTTPBasicAuthHandler(authr)

                _handlers.append(auth_handler)

            if self.cookiejar:

                cookie_handler = urllib2.HTTPCookieProcessor(cookiejar)
                _handlers.append(cookie_handler)

            opener = urllib2.build_opener(*_handlers)
            return opener.open

        else:
            return urllib2.urlopen


    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""
        
        self.response.status_code = getattr(resp, 'code', None)
        self.response.headers = getattr(resp.info(), 'dict', None)
        self.response.url = getattr(resp, 'url', None)
        self.response.content = resp.read()

    
    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""

        self._checks()

        success = False


        if self.method in ('GET', 'HEAD', 'DELETE'):
            if (not self.sent) or anyway:

                # url encode GET params if it's a dict
                if isinstance(self.params, dict):
                    params = urllib.urlencode(self.params)
                else:
                    params = self.params

                req = _Request((""%s?%s"" % (self.url, params)), method=self.method)

                if self.headers:
                    req.headers = self.headers

                opener = self._get_opener()

                try:
                    resp = opener(req)
                    self._build_response(resp)
                    self.response.ok = True

                except urllib2.HTTPError, why:
                    self._build_response(why)
                    self.response.error = why


        elif self.method == 'PUT':
            if (not self.sent) or anyway:

                if self.files:
                    register_openers()
                    datagen, headers = multipart_encode(self.files)
                    req = _Request(self.url, data=datagen, headers=headers, method='PUT')

                    if self.headers:
                        req.headers.update(self.headers)

                else:

                    req = _Request(self.url, method='PUT')

                    if self.headers:
                        req.headers = self.headers

                    req.data = self.data

                try:
                    opener = self._get_opener()
                    resp =  opener(req)

                    self._build_response(resp)
                    self.response.ok = True

                except urllib2.HTTPError, why:
                    self._build_response(why)
                    self.response.error = why


        elif self.method == 'POST':
            if (not self.sent) or anyway:

                if self.files:
                    register_openers()
                    datagen, headers = multipart_encode(self.files)
                    req = _Request(self.url, data=datagen, headers=headers, method='POST')

                    if self.headers:
                        req.headers.update(self.headers)
                
                else:
                    req = _Request(self.url, method='POST')
                    req.headers = self.headers

                    # url encode form data if it's a dict
                    if isinstance(self.data, dict):
                        req.data = urllib.urlencode(self.data)
                    else:
                        req.data = self.data

                try:
                    opener = self._get_opener()
                    resp =  opener(req)

                    self._build_response(resp)
                    self.response.ok = True

                except urllib2.HTTPError, why:
                    self._build_response(why)
                    self.response.error = why
        
        self.sent = self.response.ok
        
        return self.sent
        

class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        
    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)
        
    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error
        
    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error


    
class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.
    
    :param username: Username to authenticate with.
    :param password: Password for given username.
    """"""
    
    def __init__(self, username, password):
        self.username = username
        self.password = password



def get(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    
    r = Request(method='GET', url=url, params=params, headers=headers,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response


def head(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    r = Request(method='HEAD', url=url, params=params, headers=headers,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    
    r = Request(method='POST', url=url, data=data, headers=headers,
                files=files, cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response
    
    
def put(url, data='', headers={}, files={}, cookies=None, auth=None):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    r = Request(method='PUT', url=url, data=data, headers=headers, files=files,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response

    
def delete(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    
    r = Request(method='DELETE', url=url, params=params, headers=headers,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response


def add_autoauth(url, authobject):
    """"""Registers given AuthObject to given URL domain. for auto-activation.
    Once a URL is registered with an AuthObject, the configured HTTP
    Authentication will be used for all requests with URLS containing the given
    URL string.

    Example: ::
        >>> c_auth = requests.AuthObject('kennethreitz', 'xxxxxxx')
        >>> requests.add_autoauth('https://convore.com/api/', c_auth)
        >>> r = requests.get('https://convore.com/api/account/verify.json')
        # Automatically HTTP Authenticated! Wh00t!

    :param url: Base URL for given AuthObject to auto-activate for.
    :param authobject: AuthObject to auto-activate.
    """"""

    global AUTOAUTHS
    
    AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):
    """"""Returns registered AuthObject for given url if available, defaulting to
    given AuthObject.
    """"""

    return _get_autoauth(url) if not auth else auth

    
def _get_autoauth(url):
    """"""Returns registered AuthObject for given url if available.""""""
    
    for (autoauth_url, auth) in AUTOAUTHS:
        if autoauth_url in url: 
            return auth
            
    return None


class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""
    
class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""
    
class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import
import urllib
import urllib2

from urllib2 import HTTPError

try:
    import eventlet
    eventlet.monkey_patch()
except ImportError:
    pass

if not 'eventlet' in locals():
    try:
        from gevent import monkey
        monkey.patch_all()
    except ImportError:
        pass

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers, get_handlers


__title__ = 'requests'
__version__ = '0.2.4'
__build__ = 0x000204
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'


AUTOAUTHS = []



class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""
    
    def __init__(self, url, data=None, headers={}, origin_req_host=None,
                 unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""
    
    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')
    
    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 params=dict(), data=dict(), auth=None, cookiejar=None):
        self.url = url
        self.headers = headers
        self.files = files
        self.method = method
        self.params = params
        self.data = data
        self.response = Response()
        
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False
        
        
    def __repr__(self):
        return '<Request [%s]>' % (self.method)
    
    
    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()
        
        object.__setattr__(self, name, value)
    
    
    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired

        
    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.auth or self.cookiejar:

            if self.auth:

                authr = urllib2.HTTPPasswordMgrWithDefaultRealm()

                authr.add_password(None, self.url, self.auth.username, self.auth.password)
                auth_handler = urllib2.HTTPBasicAuthHandler(authr)

                _handlers.append(auth_handler)

            if self.cookiejar:

                cookie_handler = urllib2.HTTPCookieProcessor(cookiejar)
                _handlers.append(cookie_handler)

            _handlers += get_handlers()
            opener = urllib2.build_opener(*_handlers)
            return opener.open

        else:
            return urllib2.urlopen


    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""
        
        self.response.status_code = getattr(resp, 'code', None)
        self.response.headers = getattr(resp.info(), 'dict', None)
        self.response.url = getattr(resp, 'url', None)
        self.response.content = resp.read()

    
    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""

        self._checks()

        success = False


        if self.method in ('GET', 'HEAD', 'DELETE'):
            if (not self.sent) or anyway:

                # url encode GET params if it's a dict
                if isinstance(self.params, dict):
                    params = urllib.urlencode(self.params)
                else:
                    params = self.params

                req = _Request((""%s?%s"" % (self.url, params)), method=self.method)

                if self.headers:
                    req.headers = self.headers

                opener = self._get_opener()

                try:
                    resp = opener(req)
                    self._build_response(resp)
                    self.response.ok = True

                except urllib2.HTTPError, why:
                    self._build_response(why)
                    self.response.error = why


        elif self.method == 'PUT':
            if (not self.sent) or anyway:

                if self.files:
                    register_openers()
                    datagen, headers = multipart_encode(self.files)
                    req = _Request(self.url, data=datagen, headers=headers, method='PUT')

                    if self.headers:
                        req.headers.update(self.headers)

                else:

                    req = _Request(self.url, method='PUT')

                    if self.headers:
                        req.headers = self.headers

                    req.data = self.data

                try:
                    opener = self._get_opener()
                    resp =  opener(req)

                    self._build_response(resp)
                    self.response.ok = True

                except urllib2.HTTPError, why:
                    self._build_response(why)
                    self.response.error = why


        elif self.method == 'POST':
            if (not self.sent) or anyway:

                if self.files:
                    register_openers()
                    datagen, headers = multipart_encode(self.files)
                    req = _Request(self.url, data=datagen, headers=headers, method='POST')

                    if self.headers:
                        req.headers.update(self.headers)
                
                else:
                    req = _Request(self.url, method='POST')
                    req.headers = self.headers

                    # url encode form data if it's a dict
                    if isinstance(self.data, dict):
                        req.data = urllib.urlencode(self.data)
                    else:
                        req.data = self.data

                try:
                    opener = self._get_opener()
                    resp =  opener(req)

                    self._build_response(resp)
                    self.response.ok = True

                except urllib2.HTTPError, why:
                    self._build_response(why)
                    self.response.error = why
        
        self.sent = self.response.ok
        
        return self.sent
        

class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        
    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)
        
    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error
        
    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error


    
class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.
    
    :param username: Username to authenticate with.
    :param password: Password for given username.
    """"""
    
    def __init__(self, username, password):
        self.username = username
        self.password = password



def get(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    
    r = Request(method='GET', url=url, params=params, headers=headers,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response


def head(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    r = Request(method='HEAD', url=url, params=params, headers=headers,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    
    r = Request(method='POST', url=url, data=data, headers=headers,
                files=files, cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response
    
    
def put(url, data='', headers={}, files={}, cookies=None, auth=None):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    r = Request(method='PUT', url=url, data=data, headers=headers, files=files,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response

    
def delete(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    
    r = Request(method='DELETE', url=url, params=params, headers=headers,
                cookiejar=cookies, auth=_detect_auth(url, auth))
    r.send()
    
    return r.response


def add_autoauth(url, authobject):
    """"""Registers given AuthObject to given URL domain. for auto-activation.
    Once a URL is registered with an AuthObject, the configured HTTP
    Authentication will be used for all requests with URLS containing the given
    URL string.

    Example: ::
        >>> c_auth = requests.AuthObject('kennethreitz', 'xxxxxxx')
        >>> requests.add_autoauth('https://convore.com/api/', c_auth)
        >>> r = requests.get('https://convore.com/api/account/verify.json')
        # Automatically HTTP Authenticated! Wh00t!

    :param url: Base URL for given AuthObject to auto-activate for.
    :param authobject: AuthObject to auto-activate.
    """"""

    global AUTOAUTHS
    
    AUTOAUTHS.append((url, authobject))


def _detect_auth(url, auth):
    """"""Returns registered AuthObject for given url if available, defaulting to
    given AuthObject.
    """"""

    return _get_autoauth(url) if not auth else auth

    
def _get_autoauth(url):
    """"""Returns registered AuthObject for given url if available.""""""
    
    for (autoauth_url, auth) in AUTOAUTHS:
        if autoauth_url in url: 
            return auth
            
    return None


class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""
    
class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""
    
class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","@@ -30,7 +30,7 @@ if not 'eventlet' in locals():
         pass
 
 from .packages.poster.encode import multipart_encode
-from .packages.poster.streaminghttp import register_openers
+from .packages.poster.streaminghttp import register_openers, get_handlers
 
 
 __title__ = 'requests'
@@ -124,6 +124,7 @@ class Request(object):
                 cookie_handler = urllib2.HTTPCookieProcessor(cookiejar)
                 _handlers.append(cookie_handler)
 
+            _handlers += get_handlers()
             opener = urllib2.build_opener(*_handlers)
             return opener.open
 
",add missing __title__,[requests/core.py] add missing __title__,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.9999210834503174,0.9949507290542834,Minor,Minor,YES
6f5b64bca68489c31c7f5a62a31024bf0ddd8aa9,small workaround for issue #7,requests/packages/poster/streaminghttp.py,"""""""Streaming HTTP uploads module.

This module extends the standard httplib and urllib2 objects so that
iterable objects can be used in the body of HTTP requests.

In most cases all one should have to do is call :func:`register_openers()`
to register the new streaming http handlers which will take priority over
the default handlers, and then you can use iterable objects in the body
of HTTP requests.

**N.B.** You must specify a Content-Length header if using an iterable object
since there is no way to determine in advance the total size that will be
yielded, and there is no way to reset an interator.

Example usage:

>>> from StringIO import StringIO
>>> import urllib2, poster.streaminghttp

>>> opener = poster.streaminghttp.register_openers()

>>> s = ""Test file data""
>>> f = StringIO(s)

>>> req = urllib2.Request(""http://localhost:5000"", f,
...                       {'Content-Length': str(len(s))})
""""""

import httplib, urllib2, socket
from httplib import NotConnected

__all__ = ['StreamingHTTPConnection', 'StreamingHTTPRedirectHandler',
        'StreamingHTTPHandler', 'register_openers']

if hasattr(httplib, 'HTTPS'):
    __all__.extend(['StreamingHTTPSHandler', 'StreamingHTTPSConnection'])

class _StreamingHTTPMixin:
    """"""Mixin class for HTTP and HTTPS connections that implements a streaming
    send method.""""""
    def send(self, value):
        """"""Send ``value`` to the server.

        ``value`` can be a string object, a file-like object that supports
        a .read() method, or an iterable object that supports a .next()
        method.
        """"""
        # Based on python 2.6's httplib.HTTPConnection.send()
        if self.sock is None:
            if self.auto_open:
                self.connect()
            else:
                raise NotConnected()

        # send the data to the server. if we get a broken pipe, then close
        # the socket. we want to reconnect when somebody tries to send again.
        #
        # NOTE: we DO propagate the error, though, because we cannot simply
        #       ignore the error... the caller will know if they can retry.
        if self.debuglevel > 0:
            print ""send:"", repr(value)
        try:
            blocksize = 8192
            if hasattr(value, 'read') :
                if hasattr(value, 'seek'):
                    value.seek(0)
                if self.debuglevel > 0:
                    print ""sendIng a read()able""
                data = value.read(blocksize)
                while data:
                    self.sock.sendall(data)
                    data = value.read(blocksize)
            elif hasattr(value, 'next'):
                if hasattr(value, 'reset'):
                    value.reset()
                if self.debuglevel > 0:
                    print ""sendIng an iterable""
                for data in value:
                    self.sock.sendall(data)
            else:
                self.sock.sendall(value)
        except socket.error, v:
            if v[0] == 32:      # Broken pipe
                self.close()
            raise

class StreamingHTTPConnection(_StreamingHTTPMixin, httplib.HTTPConnection):
    """"""Subclass of `httplib.HTTPConnection` that overrides the `send()` method
    to support iterable body objects""""""

class StreamingHTTPRedirectHandler(urllib2.HTTPRedirectHandler):
    """"""Subclass of `urllib2.HTTPRedirectHandler` that overrides the
    `redirect_request` method to properly handle redirected POST requests

    This class is required because python 2.5's HTTPRedirectHandler does
    not remove the Content-Type or Content-Length headers when requesting
    the new resource, but the body of the original request is not preserved.
    """"""

    handler_order = urllib2.HTTPRedirectHandler.handler_order - 1

    # From python2.6 urllib2's HTTPRedirectHandler
    def redirect_request(self, req, fp, code, msg, headers, newurl):
        """"""Return a Request or None in response to a redirect.

        This is called by the http_error_30x methods when a
        redirection response is received.  If a redirection should
        take place, return a new Request to allow http_error_30x to
        perform the redirect.  Otherwise, raise HTTPError if no-one
        else should try to handle this url.  Return None if you can't
        but another Handler might.
        """"""
        m = req.get_method()
        if (code in (301, 302, 303, 307) and m in (""GET"", ""HEAD"")
            or code in (301, 302, 303) and m == ""POST""):
            # Strictly (according to RFC 2616), 301 or 302 in response
            # to a POST MUST NOT cause a redirection without confirmation
            # from the user (of urllib2, in this case).  In practice,
            # essentially all clients do redirect in this case, so we
            # do the same.
            # be conciliant with URIs containing a space
            newurl = newurl.replace(' ', '%20')
            newheaders = dict((k, v) for k, v in req.headers.items()
                              if k.lower() not in (
                                  ""content-length"", ""content-type"")
                             )
            return urllib2.Request(newurl,
                           headers=newheaders,
                           origin_req_host=req.get_origin_req_host(),
                           unverifiable=True)
        else:
            raise urllib2.HTTPError(req.get_full_url(), code, msg, headers, fp)

class StreamingHTTPHandler(urllib2.HTTPHandler):
    """"""Subclass of `urllib2.HTTPHandler` that uses
    StreamingHTTPConnection as its http connection class.""""""

    handler_order = urllib2.HTTPHandler.handler_order - 1

    def http_open(self, req):
        """"""Open a StreamingHTTPConnection for the given request""""""
        return self.do_open(StreamingHTTPConnection, req)

    def http_request(self, req):
        """"""Handle a HTTP request.  Make sure that Content-Length is specified
        if we're using an interable value""""""
        # Make sure that if we're using an iterable object as the request
        # body, that we've also specified Content-Length
        if req.has_data():
            data = req.get_data()
            if hasattr(data, 'read') or hasattr(data, 'next'):
                if not req.has_header('Content-length'):
                    raise ValueError(
                            ""No Content-Length specified for iterable body"")
        return urllib2.HTTPHandler.do_request_(self, req)

if hasattr(httplib, 'HTTPS'):
    class StreamingHTTPSConnection(_StreamingHTTPMixin,
            httplib.HTTPSConnection):
        """"""Subclass of `httplib.HTTSConnection` that overrides the `send()`
        method to support iterable body objects""""""

    class StreamingHTTPSHandler(urllib2.HTTPSHandler):
        """"""Subclass of `urllib2.HTTPSHandler` that uses
        StreamingHTTPSConnection as its http connection class.""""""

        handler_order = urllib2.HTTPSHandler.handler_order - 1

        def https_open(self, req):
            return self.do_open(StreamingHTTPSConnection, req)

        def https_request(self, req):
            # Make sure that if we're using an iterable object as the request
            # body, that we've also specified Content-Length
            if req.has_data():
                data = req.get_data()
                if hasattr(data, 'read') or hasattr(data, 'next'):
                    if not req.has_header('Content-length'):
                        raise ValueError(
                                ""No Content-Length specified for iterable body"")
            return urllib2.HTTPSHandler.do_request_(self, req)


def register_openers():
    """"""Register the streaming http handlers in the global urllib2 default
    opener object.

    Returns the created OpenerDirector object.""""""
    handlers = [StreamingHTTPHandler, StreamingHTTPRedirectHandler]
    if hasattr(httplib, ""HTTPS""):
        handlers.append(StreamingHTTPSHandler)

    opener = urllib2.build_opener(*handlers)

    urllib2.install_opener(opener)

    return opener
","""""""Streaming HTTP uploads module.

This module extends the standard httplib and urllib2 objects so that
iterable objects can be used in the body of HTTP requests.

In most cases all one should have to do is call :func:`register_openers()`
to register the new streaming http handlers which will take priority over
the default handlers, and then you can use iterable objects in the body
of HTTP requests.

**N.B.** You must specify a Content-Length header if using an iterable object
since there is no way to determine in advance the total size that will be
yielded, and there is no way to reset an interator.

Example usage:

>>> from StringIO import StringIO
>>> import urllib2, poster.streaminghttp

>>> opener = poster.streaminghttp.register_openers()

>>> s = ""Test file data""
>>> f = StringIO(s)

>>> req = urllib2.Request(""http://localhost:5000"", f,
...                       {'Content-Length': str(len(s))})
""""""

import httplib, urllib2, socket
from httplib import NotConnected

__all__ = ['StreamingHTTPConnection', 'StreamingHTTPRedirectHandler',
        'StreamingHTTPHandler', 'register_openers']

if hasattr(httplib, 'HTTPS'):
    __all__.extend(['StreamingHTTPSHandler', 'StreamingHTTPSConnection'])

class _StreamingHTTPMixin:
    """"""Mixin class for HTTP and HTTPS connections that implements a streaming
    send method.""""""
    def send(self, value):
        """"""Send ``value`` to the server.

        ``value`` can be a string object, a file-like object that supports
        a .read() method, or an iterable object that supports a .next()
        method.
        """"""
        # Based on python 2.6's httplib.HTTPConnection.send()
        if self.sock is None:
            if self.auto_open:
                self.connect()
            else:
                raise NotConnected()

        # send the data to the server. if we get a broken pipe, then close
        # the socket. we want to reconnect when somebody tries to send again.
        #
        # NOTE: we DO propagate the error, though, because we cannot simply
        #       ignore the error... the caller will know if they can retry.
        if self.debuglevel > 0:
            print ""send:"", repr(value)
        try:
            blocksize = 8192
            if hasattr(value, 'read') :
                if hasattr(value, 'seek'):
                    value.seek(0)
                if self.debuglevel > 0:
                    print ""sendIng a read()able""
                data = value.read(blocksize)
                while data:
                    self.sock.sendall(data)
                    data = value.read(blocksize)
            elif hasattr(value, 'next'):
                if hasattr(value, 'reset'):
                    value.reset()
                if self.debuglevel > 0:
                    print ""sendIng an iterable""
                for data in value:
                    self.sock.sendall(data)
            else:
                self.sock.sendall(value)
        except socket.error, v:
            if v[0] == 32:      # Broken pipe
                self.close()
            raise

class StreamingHTTPConnection(_StreamingHTTPMixin, httplib.HTTPConnection):
    """"""Subclass of `httplib.HTTPConnection` that overrides the `send()` method
    to support iterable body objects""""""

class StreamingHTTPRedirectHandler(urllib2.HTTPRedirectHandler):
    """"""Subclass of `urllib2.HTTPRedirectHandler` that overrides the
    `redirect_request` method to properly handle redirected POST requests

    This class is required because python 2.5's HTTPRedirectHandler does
    not remove the Content-Type or Content-Length headers when requesting
    the new resource, but the body of the original request is not preserved.
    """"""

    handler_order = urllib2.HTTPRedirectHandler.handler_order - 1

    # From python2.6 urllib2's HTTPRedirectHandler
    def redirect_request(self, req, fp, code, msg, headers, newurl):
        """"""Return a Request or None in response to a redirect.

        This is called by the http_error_30x methods when a
        redirection response is received.  If a redirection should
        take place, return a new Request to allow http_error_30x to
        perform the redirect.  Otherwise, raise HTTPError if no-one
        else should try to handle this url.  Return None if you can't
        but another Handler might.
        """"""
        m = req.get_method()
        if (code in (301, 302, 303, 307) and m in (""GET"", ""HEAD"")
            or code in (301, 302, 303) and m == ""POST""):
            # Strictly (according to RFC 2616), 301 or 302 in response
            # to a POST MUST NOT cause a redirection without confirmation
            # from the user (of urllib2, in this case).  In practice,
            # essentially all clients do redirect in this case, so we
            # do the same.
            # be conciliant with URIs containing a space
            newurl = newurl.replace(' ', '%20')
            newheaders = dict((k, v) for k, v in req.headers.items()
                              if k.lower() not in (
                                  ""content-length"", ""content-type"")
                             )
            return urllib2.Request(newurl,
                           headers=newheaders,
                           origin_req_host=req.get_origin_req_host(),
                           unverifiable=True)
        else:
            raise urllib2.HTTPError(req.get_full_url(), code, msg, headers, fp)

class StreamingHTTPHandler(urllib2.HTTPHandler):
    """"""Subclass of `urllib2.HTTPHandler` that uses
    StreamingHTTPConnection as its http connection class.""""""

    handler_order = urllib2.HTTPHandler.handler_order - 1

    def http_open(self, req):
        """"""Open a StreamingHTTPConnection for the given request""""""
        return self.do_open(StreamingHTTPConnection, req)

    def http_request(self, req):
        """"""Handle a HTTP request.  Make sure that Content-Length is specified
        if we're using an interable value""""""
        # Make sure that if we're using an iterable object as the request
        # body, that we've also specified Content-Length
        if req.has_data():
            data = req.get_data()
            if hasattr(data, 'read') or hasattr(data, 'next'):
                if not req.has_header('Content-length'):
                    raise ValueError(
                            ""No Content-Length specified for iterable body"")
        return urllib2.HTTPHandler.do_request_(self, req)

if hasattr(httplib, 'HTTPS'):
    class StreamingHTTPSConnection(_StreamingHTTPMixin,
            httplib.HTTPSConnection):
        """"""Subclass of `httplib.HTTSConnection` that overrides the `send()`
        method to support iterable body objects""""""

    class StreamingHTTPSHandler(urllib2.HTTPSHandler):
        """"""Subclass of `urllib2.HTTPSHandler` that uses
        StreamingHTTPSConnection as its http connection class.""""""

        handler_order = urllib2.HTTPSHandler.handler_order - 1

        def https_open(self, req):
            return self.do_open(StreamingHTTPSConnection, req)

        def https_request(self, req):
            # Make sure that if we're using an iterable object as the request
            # body, that we've also specified Content-Length
            if req.has_data():
                data = req.get_data()
                if hasattr(data, 'read') or hasattr(data, 'next'):
                    if not req.has_header('Content-length'):
                        raise ValueError(
                                ""No Content-Length specified for iterable body"")
            return urllib2.HTTPSHandler.do_request_(self, req)


def get_handlers():
    handlers = [StreamingHTTPHandler, StreamingHTTPRedirectHandler]
    if hasattr(httplib, ""HTTPS""):
        handlers.append(StreamingHTTPSHandler)
    return handlers
    
def register_openers():
    """"""Register the streaming http handlers in the global urllib2 default
    opener object.

    Returns the created OpenerDirector object.""""""
    opener = urllib2.build_opener(*get_handlers())

    urllib2.install_opener(opener)

    return opener
","@@ -181,16 +181,18 @@ if hasattr(httplib, 'HTTPS'):
             return urllib2.HTTPSHandler.do_request_(self, req)
 
 
+def get_handlers():
+    handlers = [StreamingHTTPHandler, StreamingHTTPRedirectHandler]
+    if hasattr(httplib, ""HTTPS""):
+        handlers.append(StreamingHTTPSHandler)
+    return handlers
+    
 def register_openers():
     """"""Register the streaming http handlers in the global urllib2 default
     opener object.
 
     Returns the created OpenerDirector object.""""""
-    handlers = [StreamingHTTPHandler, StreamingHTTPRedirectHandler]
-    if hasattr(httplib, ""HTTPS""):
-        handlers.append(StreamingHTTPSHandler)
-
-    opener = urllib2.build_opener(*handlers)
+    opener = urllib2.build_opener(*get_handlers())
 
     urllib2.install_opener(opener)
 
",add function to register streaming http handlers,[requests/packages/poster/streaminghttp.py] add function to register streaming http handlers,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.9879495186580276,Minor,Minor,YES
e7b8e9371a0ee9bb9bb8e2269474ca67088cdc86,merge changes,requests/async.py,"# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import
import urllib
import urllib2
from urllib2 import HTTPError

try:
    import eventlet
    eventlet.monkey_patch()
except ImportError:
    pass

if not 'eventlet' in locals():
    try:
        from gevent import monkey
        monkey.patch_all()
    except ImportError:
        pass

if not 'eventlet' in locals():
    raise ImportError('No Async adaptations of urllib2 found!')

from .core import *

__all__ = ['Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete', 'auth_manager', 'AuthObject',
           'RequestException', 'AuthenticationError', 'URLRequired', 'InvalidMethod', 'HTTPError']
__title__ = 'requests'
__version__ = '0.0.1'
__build__ = 0x000001
__author__ = 'Dj Gilcrease'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'
","# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""


from __future__ import absolute_import
import urllib
import urllib2
from urllib2 import HTTPError


try:
    import eventlet
    eventlet.monkey_patch()
except ImportError:
    pass

if not 'eventlet' in locals():
    try:
        from gevent import monkey
        monkey.patch_all()
    except ImportError:
        pass


if not 'eventlet' in locals():
    raise ImportError('No Async adaptations of urllib2 found!')


from .core import *


__all__ = [
    'Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete', 
    'auth_manager', 'AuthObject','RequestException', 'AuthenticationError', 
    'URLRequired', 'InvalidMethod', 'HTTPError'
]
","@@ -10,11 +10,13 @@
     :license: ISC, see LICENSE for more details.
 """"""
 
+
 from __future__ import absolute_import
 import urllib
 import urllib2
 from urllib2 import HTTPError
 
+
 try:
     import eventlet
     eventlet.monkey_patch()
@@ -28,16 +30,16 @@ if not 'eventlet' in locals():
     except ImportError:
         pass
 
+
 if not 'eventlet' in locals():
     raise ImportError('No Async adaptations of urllib2 found!')
 
+
 from .core import *
 
-__all__ = ['Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete', 'auth_manager', 'AuthObject',
-           'RequestException', 'AuthenticationError', 'URLRequired', 'InvalidMethod', 'HTTPError']
-__title__ = 'requests'
-__version__ = '0.0.1'
-__build__ = 0x000001
-__author__ = 'Dj Gilcrease'
-__license__ = 'ISC'
-__copyright__ = 'Copyright 2011 Kenneth Reitz'
+
+__all__ = [
+    'Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete', 
+    'auth_manager', 'AuthObject','RequestException', 'AuthenticationError', 
+    'URLRequired', 'InvalidMethod', 'HTTPError'
+]
",add support for eventlet in requests.py,[requests/async.py] add support for eventlet in requests.py,85.00193355757837,0.0,43.0,88.28540664778356,0.0,45.0,3.283473090205192,0.0,2.0,0.9962365031242371,0.7777375739764808,Minor,Minor,YES
e7b8e9371a0ee9bb9bb8e2269474ca67088cdc86,merge changes,requests/core.py,"# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import
import urllib
import urllib2
from urllib2 import HTTPError

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers

__all__ = ['Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete', 'auth_manager', 'AuthObject',
           'RequestException', 'AuthenticationError', 'URLRequired', 'InvalidMethod', 'HTTPError']
__title__ = 'requests'
__version__ = '0.2.5'
__build__ = 0x000205
__author__ = 'Kenneth Reitz, Dj Gilcrease'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'

class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""

    def __init__(self, url, data=None, headers={}, origin_req_host=None,
                 unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""

    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')

    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 data=dict(), auth=None, cookiejar=None):
        self.url = url
        self.headers = headers
        self.files = files
        self.method = method

        # url encode data if it's a dict
        if isinstance(data, dict):
            self.data = urllib.urlencode(data)
        else:
            self.data = data

        self.response = Response()

        if isinstance(auth, (list, tuple)):
            auth = AuthObject(*auth)
        if not auth:
            auth = auth_manager.get_auth(self.url)
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False

    def __repr__(self):
        return '<Request [%s]>' % (self.method)

    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()

        object.__setattr__(self, name, value)

    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired

    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.auth:
            if not isinstance(self.auth.handler, (urllib2.AbstractBasicAuthHandler, urllib2.AbstractDigestAuthHandler)):
                auth_manager.add_password(self.auth.realm, self.url, self.auth.username, self.auth.password)
                self.auth.handler = self.auth.handler(auth_manager)
                auth_manager.add_auth(self.url, self.auth)

            _handlers.append(self.auth.handler)

        if self.cookiejar:
            cookie_handler = urllib2.HTTPCookieProcessor(cookiejar)
            _handlers.append(cookie_handler)
        if _handlers:
            opener = urllib2.build_opener(*_handlers)
            return opener.open
        else:
            return urllib2.urlopen


    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""

        self.response.status_code = resp.code
        self.response.headers = resp.info().dict or resp.headers
        self.response.content = resp.read()
        self.response.url = resp.url


    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""
        self._checks()
        success = False

        if self.method in ('GET', 'HEAD', 'DELETE'):
            req = _Request((""%s?%s"" % (self.url, self.data)), method=self.method)
        else:
            if self.files:
                register_openers()
                datagen, headers = multipart_encode(self.files)
                req = _Request(self.url, data=datagen, headers=headers, method=self.method)
            else:
                req = _Request(self.url, method=self.method)

            if self.data:
                req.data = self.data

        if self.headers:
            req.headers = self.headers

        if not self.sent or anyway:
            try:
                opener = self._get_opener()
                resp =  opener(req)
            except urllib2.HTTPError, why:
                self._build_response(why)
                self.response.error = why
            else:
                self._build_response(resp)
                self.response.ok = True

            self.response.cached = False
        else:
            self.response.cached = True


        self.sent = self.response.ok

        return self.sent


class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        self.cached = False

    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)

    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error

    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error

class AuthManager(object):
    def __new__(cls):
        singleton = cls.__dict__.get('__singleton__')
        if singleton is not None:
            return singleton

        cls.__singleton__ = singleton = object.__new__(cls)

        return singleton

    def __init__(self):
        self.passwd = {}
        self._auth = {}

    def add_auth(self, uri, auth):
        uri = self.reduce_uri(uri, False)
        self._auth[uri] = auth

    def add_password(self, realm, uri, user, passwd):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]
        reduced_uri = tuple([self.reduce_uri(u, False) for u in uri])
        if reduced_uri not in self.passwd:
            self.passwd[reduced_uri] = {}
        self.passwd[reduced_uri] = (user, passwd)

    def find_user_password(self, realm, authuri):
        for uris, authinfo in self.passwd.iteritems():
            reduced_authuri = self.reduce_uri(authuri, False)
            for uri in uris:
                if self.is_suburi(uri, reduced_authuri):
                    return authinfo

        return (None, None)

    def get_auth(self, uri):
        uri = self.reduce_uri(uri, False)
        return self._auth.get(uri, None)

    def reduce_uri(self, uri, default_port=True):
        """"""Accept authority or URI and extract only the authority and path.""""""
        # note HTTP URLs do not have a userinfo component
        parts = urllib2.urlparse.urlsplit(uri)
        if parts[1]:
            # URI
            scheme = parts[0]
            authority = parts[1]
            path = parts[2] or '/'
        else:
            # host or host:port
            scheme = None
            authority = uri
            path = '/'
        host, port = urllib2.splitport(authority)
        if default_port and port is None and scheme is not None:
            dport = {""http"": 80,
                     ""https"": 443,
                     }.get(scheme)
            if dport is not None:
                authority = ""%s:%d"" % (host, dport)
        return authority, path

    def is_suburi(self, base, test):
        """"""Check if test is below base in a URI tree

        Both args must be URIs in reduced form.
        """"""
        if base == test:
            return True
        if base[0] != test[0]:
            return False
        common = urllib2.posixpath.commonprefix((base[1], test[1]))
        if len(common) == len(base[1]):
            return True
        return False

    def empty(self):
        self.passwd = {}

    def remove(self, uri, realm=None):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        for default_port in True, False:
            reduced_uri = tuple([self.reduce_uri(u, default_port) for u in uri])
            del self.passwd[reduced_uri][realm]

    def __contains__(self, uri):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        uri = tuple([self.reduce_uri(u, False) for u in uri])

        if uri in self.passwd:
            return True

        return False

auth_manager = AuthManager()


class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.

    :param username: Username to authenticate with.
    :param password: Password for given username.
    :param realm: (optional) the realm this auth applies to
    :param handler: (optional) basic || digest || proxy_basic || proxy_digest
    """"""

    _handlers = {
        'basic': urllib2.HTTPBasicAuthHandler,
        'digest': urllib2.HTTPDigestAuthHandler,
        'proxy_basic': urllib2.ProxyBasicAuthHandler,
        'proxy_digest': urllib2.ProxyDigestAuthHandler
    }

    def __init__(self, username, password, handler='basic', realm=None):
        self.username = username
        self.password = password
        self.realm = realm

        if isinstance(handler, basestring):
            self.handler = self._handlers.get(handler.lower(), urllib2.HTTPBasicAuthHandler)
        else:
            self.handler = handler


def request(method, url, **kwargs):
    """"""Sends a `method` request. Returns :class:`Response` object.

    :param method: method for the new :class:`Request` object.
    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET/HEAD/DELETE Parameters to send with the :class:`Request`.
    :param data: (optional) Bytes/Dictionary of PUT/POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    data = kwargs.pop('data', {}) or kwargs.pop('params', {})

    r = Request(method=method, url=url, data=data, headers=kwargs.pop('headers', {}),
                cookiejar=kwargs.pop('cookies', None), files=kwargs.pop('files', None),
                auth=kwargs.pop('auth', auth_manager.get_auth(url)))
    r.send()

    return r.response

def get(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('GET', url, params=params, headers=headers, cookiejar=cookies, auth=auth)


def head(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('HEAD', url, params=params, headers=headers, cookiejar=cookies, auth=auth)


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('POST', url, data=data, headers=headers, files=files, cookiejar=cookies, auth=auth)


def put(url, data='', headers={}, files={}, cookies=None, auth=None):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('PUT', url, data=data, headers=headers, files=files, cookiejar=cookies, auth=auth)


def delete(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of DELETE Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('DELETE', url, params=params, headers=headers, cookiejar=cookies, auth=auth)

class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""

class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""

class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import
import urllib
import urllib2
from urllib2 import HTTPError

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers


__title__ = 'requests'
__version__ = '0.2.5'
__build__ = 0x000205
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'

__all__ = [
    'Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete', 
    'auth_manager', 'AuthObject','RequestException', 'AuthenticationError', 
    'URLRequired', 'InvalidMethod', 'HTTPError'
]


class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""

    def __init__(self, url, data=None, headers={}, origin_req_host=None,
                 unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""

    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')

    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 data=dict(), auth=None, cookiejar=None):
        self.url = url
        self.headers = headers
        self.files = files
        self.method = method

        # url encode data if it's a dict
        if isinstance(data, dict):
            self.data = urllib.urlencode(data)
        else:
            self.data = data

        self.response = Response()

        if isinstance(auth, (list, tuple)):
            auth = AuthObject(*auth)
        if not auth:
            auth = auth_manager.get_auth(self.url)
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False

    def __repr__(self):
        return '<Request [%s]>' % (self.method)

    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()

        object.__setattr__(self, name, value)

    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired

    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.auth:
            if not isinstance(self.auth.handler, (urllib2.AbstractBasicAuthHandler, urllib2.AbstractDigestAuthHandler)):
                auth_manager.add_password(self.auth.realm, self.url, self.auth.username, self.auth.password)
                self.auth.handler = self.auth.handler(auth_manager)
                auth_manager.add_auth(self.url, self.auth)

            _handlers.append(self.auth.handler)

        if self.cookiejar:
            cookie_handler = urllib2.HTTPCookieProcessor(cookiejar)
            _handlers.append(cookie_handler)
        if _handlers:
            opener = urllib2.build_opener(*_handlers)
            return opener.open
        else:
            return urllib2.urlopen


    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""

        self.response.status_code = resp.code
        self.response.headers = resp.info().dict or resp.headers
        self.response.content = resp.read()
        self.response.url = resp.url


    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""
        self._checks()
        success = False

        if self.method in ('GET', 'HEAD', 'DELETE'):
            req = _Request((""%s?%s"" % (self.url, self.data)), method=self.method)
        else:
            if self.files:
                register_openers()
                datagen, headers = multipart_encode(self.files)
                req = _Request(self.url, data=datagen, headers=headers, method=self.method)
            else:
                req = _Request(self.url, method=self.method)

            if self.data:
                req.data = self.data

        if self.headers:
            req.headers = self.headers

        if not self.sent or anyway:
            try:
                opener = self._get_opener()
                resp =  opener(req)
            except urllib2.HTTPError, why:
                self._build_response(why)
                self.response.error = why
            else:
                self._build_response(resp)
                self.response.ok = True

            self.response.cached = False
        else:
            self.response.cached = True


        self.sent = self.response.ok

        return self.sent


class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        self.cached = False

    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)

    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error

    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error



class AuthManager(object):
    def __new__(cls):
        singleton = cls.__dict__.get('__singleton__')
        if singleton is not None:
            return singleton

        cls.__singleton__ = singleton = object.__new__(cls)

        return singleton

    def __init__(self):
        self.passwd = {}
        self._auth = {}

    def add_auth(self, uri, auth):
        uri = self.reduce_uri(uri, False)
        self._auth[uri] = auth

    def add_password(self, realm, uri, user, passwd):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]
        reduced_uri = tuple([self.reduce_uri(u, False) for u in uri])
        if reduced_uri not in self.passwd:
            self.passwd[reduced_uri] = {}
        self.passwd[reduced_uri] = (user, passwd)

    def find_user_password(self, realm, authuri):
        for uris, authinfo in self.passwd.iteritems():
            reduced_authuri = self.reduce_uri(authuri, False)
            for uri in uris:
                if self.is_suburi(uri, reduced_authuri):
                    return authinfo

        return (None, None)

    def get_auth(self, uri):
        uri = self.reduce_uri(uri, False)
        return self._auth.get(uri, None)

    def reduce_uri(self, uri, default_port=True):
        """"""Accept authority or URI and extract only the authority and path.""""""
        # note HTTP URLs do not have a userinfo component
        parts = urllib2.urlparse.urlsplit(uri)
        if parts[1]:
            # URI
            scheme = parts[0]
            authority = parts[1]
            path = parts[2] or '/'
        else:
            # host or host:port
            scheme = None
            authority = uri
            path = '/'
        host, port = urllib2.splitport(authority)
        if default_port and port is None and scheme is not None:
            dport = {""http"": 80,
                     ""https"": 443,
                     }.get(scheme)
            if dport is not None:
                authority = ""%s:%d"" % (host, dport)
        return authority, path

    def is_suburi(self, base, test):
        """"""Check if test is below base in a URI tree

        Both args must be URIs in reduced form.
        """"""
        if base == test:
            return True
        if base[0] != test[0]:
            return False
        common = urllib2.posixpath.commonprefix((base[1], test[1]))
        if len(common) == len(base[1]):
            return True
        return False

    def empty(self):
        self.passwd = {}

    def remove(self, uri, realm=None):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        for default_port in True, False:
            reduced_uri = tuple([self.reduce_uri(u, default_port) for u in uri])
            del self.passwd[reduced_uri][realm]

    def __contains__(self, uri):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        uri = tuple([self.reduce_uri(u, False) for u in uri])

        if uri in self.passwd:
            return True

        return False

auth_manager = AuthManager()


class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.

    :param username: Username to authenticate with.
    :param password: Password for given username.
    :param realm: (optional) the realm this auth applies to
    :param handler: (optional) basic || digest || proxy_basic || proxy_digest
    """"""

    _handlers = {
        'basic': urllib2.HTTPBasicAuthHandler,
        'digest': urllib2.HTTPDigestAuthHandler,
        'proxy_basic': urllib2.ProxyBasicAuthHandler,
        'proxy_digest': urllib2.ProxyDigestAuthHandler
    }

    def __init__(self, username, password, handler='basic', realm=None):
        self.username = username
        self.password = password
        self.realm = realm

        if isinstance(handler, basestring):
            self.handler = self._handlers.get(handler.lower(), urllib2.HTTPBasicAuthHandler)
        else:
            self.handler = handler


def request(method, url, **kwargs):
    """"""Sends a `method` request. Returns :class:`Response` object.

    :param method: method for the new :class:`Request` object.
    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET/HEAD/DELETE Parameters to send with the :class:`Request`.
    :param data: (optional) Bytes/Dictionary of PUT/POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    data = kwargs.pop('data', {}) or kwargs.pop('params', {})

    r = Request(method=method, url=url, data=data, headers=kwargs.pop('headers', {}),
                cookiejar=kwargs.pop('cookies', None), files=kwargs.pop('files', None),
                auth=kwargs.pop('auth', auth_manager.get_auth(url)))
    r.send()

    return r.response


def get(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('GET', url, params=params, headers=headers, cookiejar=cookies, auth=auth)


def head(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('HEAD', url, params=params, headers=headers, cookiejar=cookies, auth=auth)


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('POST', url, data=data, headers=headers, files=files, cookiejar=cookies, auth=auth)


def put(url, data='', headers={}, files={}, cookies=None, auth=None):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('PUT', url, data=data, headers=headers, files=files, cookiejar=cookies, auth=auth)


def delete(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of DELETE Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('DELETE', url, params=params, headers=headers, cookiejar=cookies, auth=auth)



class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""

class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""

class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","@@ -18,15 +18,21 @@ from urllib2 import HTTPError
 from .packages.poster.encode import multipart_encode
 from .packages.poster.streaminghttp import register_openers
 
-__all__ = ['Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete', 'auth_manager', 'AuthObject',
-           'RequestException', 'AuthenticationError', 'URLRequired', 'InvalidMethod', 'HTTPError']
+
 __title__ = 'requests'
 __version__ = '0.2.5'
 __build__ = 0x000205
-__author__ = 'Kenneth Reitz, Dj Gilcrease'
+__author__ = 'Kenneth Reitz'
 __license__ = 'ISC'
 __copyright__ = 'Copyright 2011 Kenneth Reitz'
 
+__all__ = [
+    'Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete', 
+    'auth_manager', 'AuthObject','RequestException', 'AuthenticationError', 
+    'URLRequired', 'InvalidMethod', 'HTTPError'
+]
+
+
 class _Request(urllib2.Request):
     """"""Hidden wrapper around the urllib2.Request object. Allows for manual
     setting of HTTP methods.
@@ -199,6 +205,8 @@ class Response(object):
         if self.error:
             raise self.error
 
+
+
 class AuthManager(object):
     def __new__(cls):
         singleton = cls.__dict__.get('__singleton__')
@@ -354,6 +362,7 @@ def request(method, url, **kwargs):
 
     return r.response
 
+
 def get(url, params={}, headers={}, cookies=None, auth=None):
     """"""Sends a GET request. Returns :class:`Response` object.
 
@@ -420,6 +429,8 @@ def delete(url, params={}, headers={}, cookies=None, auth=None):
 
     return request('DELETE', url, params=params, headers=headers, cookiejar=cookies, auth=auth)
 
+
+
 class RequestException(Exception):
     """"""There was an ambiguous exception that occured while handling your
     request.""""""
",add missing docstrings,[requests/core.py] add missing docstrings,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.9980332851409912,0.9975621603786196,Minor,Minor,YES
839c8cf150be3ebe80cbcb6e67f955405665c9e2,postbin tests were broken,test_requests.py,"#!/usr/bin/env python
# -*- coding: utf-8 -*-

import unittest

import requests


class RequestsTestSuite(unittest.TestCase):
    """"""Requests test cases.""""""

    def setUp(self):
        pass

    def tearDown(self):
        """"""Teardown.""""""
        pass

    def test_invalid_url(self):
        self.assertRaises(ValueError, requests.get, 'hiwpefhipowhefopw')

    def test_HTTP_200_OK_GET(self):
        r = requests.get('http://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTPS_200_OK_GET(self):
        r = requests.get('https://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTP_200_OK_GET_WITH_PARAMS(self):

        heads = {'User-agent': 'Mozilla/5.0'}
        
        r = requests.get('http://www.google.com/search', params={'q': 'test'}, headers=heads)
        self.assertEqual(r.status_code, 200)

    def test_HTTP_200_OK_GET_WITH_MIXED_PARAMS(self):

        heads = {'User-agent': 'Mozilla/5.0'}

        r = requests.get('http://google.com/search?test=true', params={'q': 'test'}, headers=heads)
        self.assertEqual(r.status_code, 200)
        
    def test_HTTP_200_OK_HEAD(self):
        r = requests.head('http://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTPS_200_OK_HEAD(self):
        r = requests.head('https://google.com')
        self.assertEqual(r.status_code, 200)

    def test_AUTH_HTTPS_200_OK_GET(self):
        auth = ('requeststest', 'requeststest')
        url = 'https://convore.com/api/account/verify.json'
        r = requests.get(url, auth=auth)

        self.assertEqual(r.status_code, 200)

        r = requests.get(url)
        self.assertEqual(r.status_code, 200)

        # reset auto authentication
        requests.auth_manager.empty()

    def test_POSTBIN_GET_POST_FILES(self):
        h = {'Content-type': 'application/x-www-form-urlencoded'}
        
        bin = requests.post('http://www.postbin.org/', headers=h)
        # self.assertEqual(bin.status_code, 200)
        
        print bin.url
        print bin.status_code
    
        # post = requests.post(bin.url, data={'some': 'data'})
        # self.assertEqual(post.status_code, 200)
    
        # post2 = requests.post(bin.url, files={'some': open('test_requests.py')})
        # self.assertEqual(post2.status_code, 200)
        
        
    def test_POSTBIN_GET_POST_FILES_WITH_PARAMS(self):
        # TODO: postbin w/ params
        bin = requests.get('http://www.postbin.org/')
        self.assertEqual(bin.status_code, 200)
    
        post = requests.post(bin.url, data={'some': 'data'})
        self.assertEqual(post.status_code, 200)
    
        post2 = requests.post(bin.url, files={'some': open('test_requests.py')}, data={'some': 'data'})
        # self.assertEqual(post2.status_code, 200)

    def test_nonzero_evaluation(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(bool(r), False)
    
        r = requests.get('http://google.com/')
        self.assertEqual(bool(r), True)
    
    def test_request_ok_set(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(r.ok, False)
    
    def test_status_raising(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertRaises(requests.HTTPError, r.raise_for_status)
    
        r = requests.get('http://google.com/')
        self.assertFalse(r.error)
        r.raise_for_status()
        



if __name__ == '__main__':
    unittest.main()
","#!/usr/bin/env python
# -*- coding: utf-8 -*-

import unittest

import requests


class RequestsTestSuite(unittest.TestCase):
    """"""Requests test cases.""""""

    def setUp(self):
        pass

    def tearDown(self):
        """"""Teardown.""""""
        pass

    def test_invalid_url(self):
        self.assertRaises(ValueError, requests.get, 'hiwpefhipowhefopw')

    def test_HTTP_200_OK_GET(self):
        r = requests.get('http://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTPS_200_OK_GET(self):
        r = requests.get('https://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTP_200_OK_GET_WITH_PARAMS(self):

        heads = {'User-agent': 'Mozilla/5.0'}
        
        r = requests.get('http://www.google.com/search', params={'q': 'test'}, headers=heads)
        self.assertEqual(r.status_code, 200)

    def test_HTTP_200_OK_GET_WITH_MIXED_PARAMS(self):

        heads = {'User-agent': 'Mozilla/5.0'}

        r = requests.get('http://google.com/search?test=true', params={'q': 'test'}, headers=heads)
        self.assertEqual(r.status_code, 200)
        
    def test_HTTP_200_OK_HEAD(self):
        r = requests.head('http://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTPS_200_OK_HEAD(self):
        r = requests.head('https://google.com')
        self.assertEqual(r.status_code, 200)

    def test_AUTH_HTTPS_200_OK_GET(self):
        auth = ('requeststest', 'requeststest')
        url = 'https://convore.com/api/account/verify.json'
        r = requests.get(url, auth=auth)

        self.assertEqual(r.status_code, 200)

        r = requests.get(url)
        self.assertEqual(r.status_code, 200)

        # reset auto authentication
        requests.auth_manager.empty()

    def test_POSTBIN_GET_POST_FILES(self):

        bin = requests.post('http://www.postbin.org/')
        print bin.url
        self.assertEqual(bin.status_code, 200)
        
        post = requests.post(bin.url, data={'some': 'data'})
        self.assertEqual(post.status_code, 201)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')})
        self.assertEqual(post2.status_code, 201)

    def test_POSTBIN_GET_POST_FILES_WITH_PARAMS(self):
        # TODO: postbin w/ params
        bin = requests.post('http://www.postbin.org/')
        print bin.url
        self.assertEqual(bin.status_code, 200)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')}, data={'some': 'data'})
        self.assertEqual(post2.status_code, 201)

    def test_nonzero_evaluation(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(bool(r), False)
    
        r = requests.get('http://google.com/')
        self.assertEqual(bool(r), True)
    
    def test_request_ok_set(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(r.ok, False)
    
    def test_status_raising(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertRaises(requests.HTTPError, r.raise_for_status)
    
        r = requests.get('http://google.com/')
        self.assertFalse(r.error)
        r.raise_for_status()
        



if __name__ == '__main__':
    unittest.main()
","@@ -63,31 +63,25 @@ class RequestsTestSuite(unittest.TestCase):
         requests.auth_manager.empty()
 
     def test_POSTBIN_GET_POST_FILES(self):
-        h = {'Content-type': 'application/x-www-form-urlencoded'}
-        
-        bin = requests.post('http://www.postbin.org/', headers=h)
-        # self.assertEqual(bin.status_code, 200)
-        
+
+        bin = requests.post('http://www.postbin.org/')
         print bin.url
-        print bin.status_code
-    
-        # post = requests.post(bin.url, data={'some': 'data'})
-        # self.assertEqual(post.status_code, 200)
-    
-        # post2 = requests.post(bin.url, files={'some': open('test_requests.py')})
-        # self.assertEqual(post2.status_code, 200)
-        
+        self.assertEqual(bin.status_code, 200)
         
+        post = requests.post(bin.url, data={'some': 'data'})
+        self.assertEqual(post.status_code, 201)
+
+        post2 = requests.post(bin.url, files={'some': open('test_requests.py')})
+        self.assertEqual(post2.status_code, 201)
+
     def test_POSTBIN_GET_POST_FILES_WITH_PARAMS(self):
         # TODO: postbin w/ params
-        bin = requests.get('http://www.postbin.org/')
+        bin = requests.post('http://www.postbin.org/')
+        print bin.url
         self.assertEqual(bin.status_code, 200)
-    
-        post = requests.post(bin.url, data={'some': 'data'})
-        self.assertEqual(post.status_code, 200)
-    
+
         post2 = requests.post(bin.url, files={'some': open('test_requests.py')}, data={'some': 'data'})
-        # self.assertEqual(post2.status_code, 200)
+        self.assertEqual(post2.status_code, 201)
 
     def test_nonzero_evaluation(self):
         r = requests.get('http://google.com/some-404-url')
",add tests for postbin.org,[test_requests.py] add tests for postbin.org,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.9253016013932112,Minor,Minor,YES
9fdee250de7e1aa0c92db5fb435cf1f2f8efe7e7,Better POSTER header compatibility (Fixes #13),requests/core.py,"# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import

import urllib
import urllib2

from urllib2 import HTTPError
from urlparse import urlparse

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers, get_handlers



__title__ = 'requests'
__version__ = '0.3.0'
__build__ = 0x000300
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'

__all__ = [
    'Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete', 
    'auth_manager', 'AuthObject','RequestException', 'AuthenticationError', 
    'URLRequired', 'InvalidMethod', 'HTTPError'
]



class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""

    def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""

    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')

    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 data=dict(), auth=None, cookiejar=None):
        
        self.url = url
        self.headers = headers
        self.files = files
        self.method = method
        self.data = data

        # url encode data if it's a dict
        if hasattr(data, 'items'):
            self._enc_data = urllib.urlencode(data)
        else:
            self._enc_data = data

        self.response = Response()

        if isinstance(auth, (list, tuple)):
            auth = AuthObject(*auth)
        if not auth:
            auth = auth_manager.get_auth(self.url)
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False


    def __repr__(self):
        return '<Request [%s]>' % (self.method)


    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()

        object.__setattr__(self, name, value)


    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired


    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.auth:
            if not isinstance(self.auth.handler, (urllib2.AbstractBasicAuthHandler, urllib2.AbstractDigestAuthHandler)):
                auth_manager.add_password(self.auth.realm, self.url, self.auth.username, self.auth.password)
                self.auth.handler = self.auth.handler(auth_manager)
                auth_manager.add_auth(self.url, self.auth)

            _handlers.append(self.auth.handler)

            _handlers.extend(get_handlers())
            opener = urllib2.build_opener(*_handlers)
            return opener.open
        else:
            return urllib2.urlopen


    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""
        
        self.response.status_code = getattr(resp, 'code', None)
        self.response.headers = getattr(resp.info(), 'dict', None)
        self.response.url = getattr(resp, 'url', None)
        self.response.content = resp.read()


    @staticmethod
    def _build_url(url, data):
        """"""Build URLs.""""""
        
        if urlparse(url).query:
            return '%s&%s' % (url, data)
        else:
            if data:
                return '%s?%s' % (url, data)
            else:
                return url


    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""
        self._checks()
        success = False

        if self.method in ('GET', 'HEAD', 'DELETE'):
            req = _Request(self._build_url(self.url, self._enc_data), method=self.method)
        else:

            if self.files:
                register_openers()

                if self.data:
                    self.files.update(self.data)
                    
                datagen, headers = multipart_encode(self.files)
                req = _Request(self.url, data=datagen, headers=headers, method=self.method)
                
            else:
                req = _Request(self.url, data=self._enc_data, method=self.method)

        if self.headers:
            req.headers = self.headers

        if not self.sent or anyway:
            try:
                opener = self._get_opener()
                resp =  opener(req)
            except urllib2.HTTPError, why:
                self._build_response(why)
                self.response.error = why
            else:
                self._build_response(resp)
                self.response.ok = True

            self.response.cached = False
        else:
            self.response.cached = True


        self.sent = self.response.ok

        return self.sent


    
class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        self.cached = False


    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)


    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error


    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error



class AuthManager(object):
    """"""Authentication Manager.""""""
    
    def __new__(cls):
        singleton = cls.__dict__.get('__singleton__')
        if singleton is not None:
            return singleton

        cls.__singleton__ = singleton = object.__new__(cls)

        return singleton


    def __init__(self):
        self.passwd = {}
        self._auth = {}


    def __repr__(self):
        return '<AuthManager [%s]>' % (self.method)


    def add_auth(self, uri, auth):
        """"""Registers AuthObject to AuthManager.""""""
        
        uri = self.reduce_uri(uri, False)
        self._auth[uri] = auth

    def add_password(self, realm, uri, user, passwd):
        """"""Adds password to AuthManager.""""""
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]
            
        reduced_uri = tuple([self.reduce_uri(u, False) for u in uri])
        
        if reduced_uri not in self.passwd:
            self.passwd[reduced_uri] = {}
        self.passwd[reduced_uri] = (user, passwd)


    def find_user_password(self, realm, authuri):
        for uris, authinfo in self.passwd.iteritems():
            reduced_authuri = self.reduce_uri(authuri, False)
            for uri in uris:
                if self.is_suburi(uri, reduced_authuri):
                    return authinfo

        return (None, None)


    def get_auth(self, uri):
        uri = self.reduce_uri(uri, False)
        return self._auth.get(uri, None)


    def reduce_uri(self, uri, default_port=True):
        """"""Accept authority or URI and extract only the authority and path.""""""
        # note HTTP URLs do not have a userinfo component
        parts = urllib2.urlparse.urlsplit(uri)
        if parts[1]:
            # URI
            scheme = parts[0]
            authority = parts[1]
            path = parts[2] or '/'
        else:
            # host or host:port
            scheme = None
            authority = uri
            path = '/'
        host, port = urllib2.splitport(authority)
        if default_port and port is None and scheme is not None:
            dport = {""http"": 80,
                     ""https"": 443,
                     }.get(scheme)
            if dport is not None:
                authority = ""%s:%d"" % (host, dport)
        return authority, path

    
    def is_suburi(self, base, test):
        """"""Check if test is below base in a URI tree

        Both args must be URIs in reduced form.
        """"""
        if base == test:
            return True
        if base[0] != test[0]:
            return False
        common = urllib2.posixpath.commonprefix((base[1], test[1]))
        if len(common) == len(base[1]):
            return True
        return False


    def empty(self):
        self.passwd = {}


    def remove(self, uri, realm=None):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        for default_port in True, False:
            reduced_uri = tuple([self.reduce_uri(u, default_port) for u in uri])
            del self.passwd[reduced_uri][realm]


    def __contains__(self, uri):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        uri = tuple([self.reduce_uri(u, False) for u in uri])

        if uri in self.passwd:
            return True

        return False

auth_manager = AuthManager()



class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.

    :param username: Username to authenticate with.
    :param password: Password for given username.
    :param realm: (optional) the realm this auth applies to
    :param handler: (optional) basic || digest || proxy_basic || proxy_digest
    """"""

    _handlers = {
        'basic': urllib2.HTTPBasicAuthHandler,
        'digest': urllib2.HTTPDigestAuthHandler,
        'proxy_basic': urllib2.ProxyBasicAuthHandler,
        'proxy_digest': urllib2.ProxyDigestAuthHandler
    }

    def __init__(self, username, password, handler='basic', realm=None):
        self.username = username
        self.password = password
        self.realm = realm

        if isinstance(handler, basestring):
            self.handler = self._handlers.get(handler.lower(), urllib2.HTTPBasicAuthHandler)
        else:
            self.handler = handler




def request(method, url, **kwargs):
    """"""Sends a `method` request. Returns :class:`Response` object.

    :param method: method for the new :class:`Request` object.
    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET/HEAD/DELETE Parameters to send with the :class:`Request`.
    :param data: (optional) Bytes/Dictionary of PUT/POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    data = kwargs.pop('data', dict()) or kwargs.pop('params', dict())

    r = Request(method=method, url=url, data=data, headers=kwargs.pop('headers', {}),
                cookiejar=kwargs.pop('cookies', None), files=kwargs.pop('files', None),
                auth=kwargs.pop('auth', auth_manager.get_auth(url)))
    r.send()

    return r.response


def get(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    
    return request('GET', url, params=params, headers=headers, cookiejar=cookies, auth=auth)


def head(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('HEAD', url, params=params, headers=headers, cookiejar=cookies, auth=auth)


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('POST', url, data=data, headers=headers, files=files, cookiejar=cookies, auth=auth)


def put(url, data='', headers={}, files={}, cookies=None, auth=None):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('PUT', url, data=data, headers=headers, files=files, cookiejar=cookies, auth=auth)


def delete(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of DELETE Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('DELETE', url, params=params, headers=headers, cookiejar=cookies, auth=auth)



class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""

class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""

class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import

import urllib
import urllib2

from urllib2 import HTTPError
from urlparse import urlparse

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers, get_handlers



__title__ = 'requests'
__version__ = '0.3.0'
__build__ = 0x000300
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'

__all__ = [
    'Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete', 
    'auth_manager', 'AuthObject','RequestException', 'AuthenticationError', 
    'URLRequired', 'InvalidMethod', 'HTTPError'
]



class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""

    def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""

    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')

    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 data=dict(), auth=None, cookiejar=None):
        
        self.url = url
        self.headers = headers
        self.files = files
        self.method = method
        self.data = data

        # url encode data if it's a dict
        if hasattr(data, 'items'):
            self._enc_data = urllib.urlencode(data)
        else:
            self._enc_data = data

        self.response = Response()

        if isinstance(auth, (list, tuple)):
            auth = AuthObject(*auth)
        if not auth:
            auth = auth_manager.get_auth(self.url)
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False


    def __repr__(self):
        return '<Request [%s]>' % (self.method)


    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()

        object.__setattr__(self, name, value)


    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired


    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.auth:
            if not isinstance(self.auth.handler, (urllib2.AbstractBasicAuthHandler, urllib2.AbstractDigestAuthHandler)):
                auth_manager.add_password(self.auth.realm, self.url, self.auth.username, self.auth.password)
                self.auth.handler = self.auth.handler(auth_manager)
                auth_manager.add_auth(self.url, self.auth)

            _handlers.append(self.auth.handler)

            _handlers.extend(get_handlers())
            opener = urllib2.build_opener(*_handlers)
            return opener.open
        else:
            return urllib2.urlopen


    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""
        
        self.response.status_code = getattr(resp, 'code', None)
        self.response.headers = getattr(resp.info(), 'dict', None)
        self.response.url = getattr(resp, 'url', None)
        self.response.content = resp.read()


    @staticmethod
    def _build_url(url, data):
        """"""Build URLs.""""""
        
        if urlparse(url).query:
            return '%s&%s' % (url, data)
        else:
            if data:
                return '%s?%s' % (url, data)
            else:
                return url


    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""
        self._checks()
        success = False

        if self.method in ('GET', 'HEAD', 'DELETE'):
            req = _Request(self._build_url(self.url, self._enc_data), method=self.method)
        else:

            if self.files:
                register_openers()

                if self.data:
                    self.files.update(self.data)
                    
                datagen, headers = multipart_encode(self.files)
                req = _Request(self.url, data=datagen, headers=headers, method=self.method)
                
            else:
                req = _Request(self.url, data=self._enc_data, method=self.method)

        if self.headers:
            req.headers.update(self.headers)

        if not self.sent or anyway:
            try:
                opener = self._get_opener()
                resp =  opener(req)
            except urllib2.HTTPError, why:
                self._build_response(why)
                self.response.error = why
            else:
                self._build_response(resp)
                self.response.ok = True

            self.response.cached = False
        else:
            self.response.cached = True


        self.sent = self.response.ok

        return self.sent


    
class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        self.cached = False


    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)


    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error


    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error



class AuthManager(object):
    """"""Authentication Manager.""""""
    
    def __new__(cls):
        singleton = cls.__dict__.get('__singleton__')
        if singleton is not None:
            return singleton

        cls.__singleton__ = singleton = object.__new__(cls)

        return singleton


    def __init__(self):
        self.passwd = {}
        self._auth = {}


    def __repr__(self):
        return '<AuthManager [%s]>' % (self.method)


    def add_auth(self, uri, auth):
        """"""Registers AuthObject to AuthManager.""""""
        
        uri = self.reduce_uri(uri, False)
        self._auth[uri] = auth

    def add_password(self, realm, uri, user, passwd):
        """"""Adds password to AuthManager.""""""
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]
            
        reduced_uri = tuple([self.reduce_uri(u, False) for u in uri])
        
        if reduced_uri not in self.passwd:
            self.passwd[reduced_uri] = {}
        self.passwd[reduced_uri] = (user, passwd)


    def find_user_password(self, realm, authuri):
        for uris, authinfo in self.passwd.iteritems():
            reduced_authuri = self.reduce_uri(authuri, False)
            for uri in uris:
                if self.is_suburi(uri, reduced_authuri):
                    return authinfo

        return (None, None)


    def get_auth(self, uri):
        uri = self.reduce_uri(uri, False)
        return self._auth.get(uri, None)


    def reduce_uri(self, uri, default_port=True):
        """"""Accept authority or URI and extract only the authority and path.""""""
        # note HTTP URLs do not have a userinfo component
        parts = urllib2.urlparse.urlsplit(uri)
        if parts[1]:
            # URI
            scheme = parts[0]
            authority = parts[1]
            path = parts[2] or '/'
        else:
            # host or host:port
            scheme = None
            authority = uri
            path = '/'
        host, port = urllib2.splitport(authority)
        if default_port and port is None and scheme is not None:
            dport = {""http"": 80,
                     ""https"": 443,
                     }.get(scheme)
            if dport is not None:
                authority = ""%s:%d"" % (host, dport)
        return authority, path

    
    def is_suburi(self, base, test):
        """"""Check if test is below base in a URI tree

        Both args must be URIs in reduced form.
        """"""
        if base == test:
            return True
        if base[0] != test[0]:
            return False
        common = urllib2.posixpath.commonprefix((base[1], test[1]))
        if len(common) == len(base[1]):
            return True
        return False


    def empty(self):
        self.passwd = {}


    def remove(self, uri, realm=None):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        for default_port in True, False:
            reduced_uri = tuple([self.reduce_uri(u, default_port) for u in uri])
            del self.passwd[reduced_uri][realm]


    def __contains__(self, uri):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        uri = tuple([self.reduce_uri(u, False) for u in uri])

        if uri in self.passwd:
            return True

        return False

auth_manager = AuthManager()



class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.

    :param username: Username to authenticate with.
    :param password: Password for given username.
    :param realm: (optional) the realm this auth applies to
    :param handler: (optional) basic || digest || proxy_basic || proxy_digest
    """"""

    _handlers = {
        'basic': urllib2.HTTPBasicAuthHandler,
        'digest': urllib2.HTTPDigestAuthHandler,
        'proxy_basic': urllib2.ProxyBasicAuthHandler,
        'proxy_digest': urllib2.ProxyDigestAuthHandler
    }

    def __init__(self, username, password, handler='basic', realm=None):
        self.username = username
        self.password = password
        self.realm = realm

        if isinstance(handler, basestring):
            self.handler = self._handlers.get(handler.lower(), urllib2.HTTPBasicAuthHandler)
        else:
            self.handler = handler




def request(method, url, **kwargs):
    """"""Sends a `method` request. Returns :class:`Response` object.

    :param method: method for the new :class:`Request` object.
    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET/HEAD/DELETE Parameters to send with the :class:`Request`.
    :param data: (optional) Bytes/Dictionary of PUT/POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    data = kwargs.pop('data', dict()) or kwargs.pop('params', dict())

    r = Request(method=method, url=url, data=data, headers=kwargs.pop('headers', {}),
                cookiejar=kwargs.pop('cookies', None), files=kwargs.pop('files', None),
                auth=kwargs.pop('auth', auth_manager.get_auth(url)))
    r.send()

    return r.response


def get(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    
    return request('GET', url, params=params, headers=headers, cookiejar=cookies, auth=auth)


def head(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('HEAD', url, params=params, headers=headers, cookiejar=cookies, auth=auth)


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('POST', url, data=data, headers=headers, files=files, cookiejar=cookies, auth=auth)


def put(url, data='', headers={}, files={}, cookies=None, auth=None):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('PUT', url, data=data, headers=headers, files=files, cookiejar=cookies, auth=auth)


def delete(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of DELETE Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('DELETE', url, params=params, headers=headers, cookiejar=cookies, auth=auth)



class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""

class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""

class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","@@ -178,7 +178,7 @@ class Request(object):
                 req = _Request(self.url, data=self._enc_data, method=self.method)
 
         if self.headers:
-            req.headers = self.headers
+            req.headers.update(self.headers)
 
         if not self.sent or anyway:
             try:
",fix issue #178,[requests/core.py] fix issue #178,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.9981272326946343,Minor,Minor,YES
2401f149750337970300383634f3942e9da3c68f,Fixing User-agent header problem introduced with Python 2.7.1,requests/core.py,"# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import

import urllib
import urllib2

from urllib2 import HTTPError
from urlparse import urlparse

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers, get_handlers



__title__ = 'requests'
__version__ = '0.3.0'
__build__ = 0x000300
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'

__all__ = [
    'Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete', 
    'auth_manager', 'AuthObject','RequestException', 'AuthenticationError', 
    'URLRequired', 'InvalidMethod', 'HTTPError'
]



class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""

    def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""

    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')

    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 data=dict(), auth=None, cookiejar=None):
        
        self.url = url
        self.headers = headers
        self.files = files
        self.method = method
        self.data = data

        # url encode data if it's a dict
        if hasattr(data, 'items'):
            self._enc_data = urllib.urlencode(data)
        else:
            self._enc_data = data

        self.response = Response()

        if isinstance(auth, (list, tuple)):
            auth = AuthObject(*auth)
        if not auth:
            auth = auth_manager.get_auth(self.url)
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False


    def __repr__(self):
        return '<Request [%s]>' % (self.method)


    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()

        object.__setattr__(self, name, value)


    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired


    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.cookiejar is not None:
            _handlers.append(urllib2.HTTPCookieProcessor(self.cookiejar))

        if self.auth:
            if not isinstance(self.auth.handler, (urllib2.AbstractBasicAuthHandler, urllib2.AbstractDigestAuthHandler)):
                auth_manager.add_password(self.auth.realm, self.url, self.auth.username, self.auth.password)
                self.auth.handler = self.auth.handler(auth_manager)
                auth_manager.add_auth(self.url, self.auth)

            _handlers.append(self.auth.handler)

        if _handlers:
            _handlers.extend(get_handlers())
            opener = urllib2.build_opener(*_handlers)
            return opener.open
        else:
            return urllib2.urlopen


    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""
        
        self.response.status_code = getattr(resp, 'code', None)
        self.response.headers = getattr(resp.info(), 'dict', None)
        self.response.url = getattr(resp, 'url', None)
        self.response.content = resp.read()


    @staticmethod
    def _build_url(url, data):
        """"""Build URLs.""""""
        
        if urlparse(url).query:
            return '%s&%s' % (url, data)
        else:
            if data:
                return '%s?%s' % (url, data)
            else:
                return url


    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""
        self._checks()
        success = False

        if self.method in ('GET', 'HEAD', 'DELETE'):
            req = _Request(self._build_url(self.url, self._enc_data), method=self.method)
        else:

            if self.files:
                register_openers()

                if self.data:
                    self.files.update(self.data)
                    
                datagen, headers = multipart_encode(self.files)
                req = _Request(self.url, data=datagen, headers=headers, method=self.method)
                
            else:
                req = _Request(self.url, data=self._enc_data, method=self.method)

        if self.headers:
            req.headers.update(self.headers)

        if not self.sent or anyway:
            try:
                opener = self._get_opener()
                resp = opener(req)

                if self.cookiejar is not None:
                    self.cookiejar.extract_cookies(resp, req)
                    
            except urllib2.HTTPError, why:
                self._build_response(why)
                self.response.error = why
            else:
                self._build_response(resp)
                self.response.ok = True

            self.response.cached = False
        else:
            self.response.cached = True

        self.sent = self.response.ok

        return self.sent


    
class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        self.cached = False


    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)


    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error


    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error



class AuthManager(object):
    """"""Authentication Manager.""""""
    
    def __new__(cls):
        singleton = cls.__dict__.get('__singleton__')
        if singleton is not None:
            return singleton

        cls.__singleton__ = singleton = object.__new__(cls)

        return singleton


    def __init__(self):
        self.passwd = {}
        self._auth = {}


    def __repr__(self):
        return '<AuthManager [%s]>' % (self.method)


    def add_auth(self, uri, auth):
        """"""Registers AuthObject to AuthManager.""""""
        
        uri = self.reduce_uri(uri, False)
        self._auth[uri] = auth

    def add_password(self, realm, uri, user, passwd):
        """"""Adds password to AuthManager.""""""
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]
            
        reduced_uri = tuple([self.reduce_uri(u, False) for u in uri])
        
        if reduced_uri not in self.passwd:
            self.passwd[reduced_uri] = {}
        self.passwd[reduced_uri] = (user, passwd)


    def find_user_password(self, realm, authuri):
        for uris, authinfo in self.passwd.iteritems():
            reduced_authuri = self.reduce_uri(authuri, False)
            for uri in uris:
                if self.is_suburi(uri, reduced_authuri):
                    return authinfo

        return (None, None)


    def get_auth(self, uri):
        uri = self.reduce_uri(uri, False)
        return self._auth.get(uri, None)


    def reduce_uri(self, uri, default_port=True):
        """"""Accept authority or URI and extract only the authority and path.""""""
        # note HTTP URLs do not have a userinfo component
        parts = urllib2.urlparse.urlsplit(uri)
        if parts[1]:
            # URI
            scheme = parts[0]
            authority = parts[1]
            path = parts[2] or '/'
        else:
            # host or host:port
            scheme = None
            authority = uri
            path = '/'
        host, port = urllib2.splitport(authority)
        if default_port and port is None and scheme is not None:
            dport = {""http"": 80,
                     ""https"": 443,
                     }.get(scheme)
            if dport is not None:
                authority = ""%s:%d"" % (host, dport)
        return authority, path

    
    def is_suburi(self, base, test):
        """"""Check if test is below base in a URI tree

        Both args must be URIs in reduced form.
        """"""
        if base == test:
            return True
        if base[0] != test[0]:
            return False
        common = urllib2.posixpath.commonprefix((base[1], test[1]))
        if len(common) == len(base[1]):
            return True
        return False


    def empty(self):
        self.passwd = {}


    def remove(self, uri, realm=None):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        for default_port in True, False:
            reduced_uri = tuple([self.reduce_uri(u, default_port) for u in uri])
            del self.passwd[reduced_uri][realm]


    def __contains__(self, uri):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        uri = tuple([self.reduce_uri(u, False) for u in uri])

        if uri in self.passwd:
            return True

        return False

auth_manager = AuthManager()



class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.

    :param username: Username to authenticate with.
    :param password: Password for given username.
    :param realm: (optional) the realm this auth applies to
    :param handler: (optional) basic || digest || proxy_basic || proxy_digest
    """"""

    _handlers = {
        'basic': urllib2.HTTPBasicAuthHandler,
        'digest': urllib2.HTTPDigestAuthHandler,
        'proxy_basic': urllib2.ProxyBasicAuthHandler,
        'proxy_digest': urllib2.ProxyDigestAuthHandler
    }

    def __init__(self, username, password, handler='basic', realm=None):
        self.username = username
        self.password = password
        self.realm = realm

        if isinstance(handler, basestring):
            self.handler = self._handlers.get(handler.lower(), urllib2.HTTPBasicAuthHandler)
        else:
            self.handler = handler




def request(method, url, **kwargs):
    """"""Sends a `method` request. Returns :class:`Response` object.

    :param method: method for the new :class:`Request` object.
    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET/HEAD/DELETE Parameters to send with the :class:`Request`.
    :param data: (optional) Bytes/Dictionary of PUT/POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    data = kwargs.pop('data', dict()) or kwargs.pop('params', dict())

    r = Request(method=method, url=url, data=data, headers=kwargs.pop('headers', {}),
                cookiejar=kwargs.pop('cookies', None), files=kwargs.pop('files', None),
                auth=kwargs.pop('auth', auth_manager.get_auth(url)))
    r.send()

    return r.response


def get(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    
    return request('GET', url, params=params, headers=headers, cookies=cookies, auth=auth)


def head(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('HEAD', url, params=params, headers=headers, cookies=cookies, auth=auth)


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('POST', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth)


def put(url, data='', headers={}, files={}, cookies=None, auth=None):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('PUT', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth)


def delete(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of DELETE Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('DELETE', url, params=params, headers=headers, cookies=cookies, auth=auth)



class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""

class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""

class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import

import urllib
import urllib2

from urllib2 import HTTPError
from urlparse import urlparse

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers, get_handlers



__title__ = 'requests'
__version__ = '0.3.0'
__build__ = 0x000300
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'

__all__ = [
    'Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete', 
    'auth_manager', 'AuthObject','RequestException', 'AuthenticationError', 
    'URLRequired', 'InvalidMethod', 'HTTPError'
]



class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""

    def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""

    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')

    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 data=dict(), auth=None, cookiejar=None):
        
        self.url = url
        self.headers = headers
        self.files = files
        self.method = method
        self.data = data

        # url encode data if it's a dict
        if hasattr(data, 'items'):
            self._enc_data = urllib.urlencode(data)
        else:
            self._enc_data = data

        self.response = Response()

        if isinstance(auth, (list, tuple)):
            auth = AuthObject(*auth)
        if not auth:
            auth = auth_manager.get_auth(self.url)
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False


    def __repr__(self):
        return '<Request [%s]>' % (self.method)


    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()

        object.__setattr__(self, name, value)


    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired


    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.cookiejar is not None:
            _handlers.append(urllib2.HTTPCookieProcessor(self.cookiejar))

        if self.auth:
            if not isinstance(self.auth.handler, (urllib2.AbstractBasicAuthHandler, urllib2.AbstractDigestAuthHandler)):
                auth_manager.add_password(self.auth.realm, self.url, self.auth.username, self.auth.password)
                self.auth.handler = self.auth.handler(auth_manager)
                auth_manager.add_auth(self.url, self.auth)

            _handlers.append(self.auth.handler)

        if not _handlers:
            return urllib2.urlopen

        _handlers.extend(get_handlers())
        opener = urllib2.build_opener(*_handlers)

        if self.headers:
            # Allow default headers in the opener to be overloaded
            normal_keys = [k.capitalize() for k in self.headers]
            for key, val in opener.addheaders[:]:
                if key not in normal_keys:
                    continue
                # Remove it, we have a value to take its place
                opener.addheaders.remove((key, val))

        return opener.open

    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""
        
        self.response.status_code = getattr(resp, 'code', None)
        self.response.headers = getattr(resp.info(), 'dict', None)
        self.response.url = getattr(resp, 'url', None)
        self.response.content = resp.read()


    @staticmethod
    def _build_url(url, data):
        """"""Build URLs.""""""
        
        if urlparse(url).query:
            return '%s&%s' % (url, data)
        else:
            if data:
                return '%s?%s' % (url, data)
            else:
                return url


    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""
        self._checks()
        success = False

        if self.method in ('GET', 'HEAD', 'DELETE'):
            req = _Request(self._build_url(self.url, self._enc_data), method=self.method)
        else:

            if self.files:
                register_openers()

                if self.data:
                    self.files.update(self.data)
                    
                datagen, headers = multipart_encode(self.files)
                req = _Request(self.url, data=datagen, headers=headers, method=self.method)
                
            else:
                req = _Request(self.url, data=self._enc_data, method=self.method)

        if self.headers:
            req.headers.update(self.headers)

        if not self.sent or anyway:
            try:
                opener = self._get_opener()
                resp = opener(req)

                if self.cookiejar is not None:
                    self.cookiejar.extract_cookies(resp, req)
                    
            except urllib2.HTTPError, why:
                self._build_response(why)
                self.response.error = why
            else:
                self._build_response(resp)
                self.response.ok = True

            self.response.cached = False
        else:
            self.response.cached = True

        self.sent = self.response.ok

        return self.sent


    
class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        self.cached = False


    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)


    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error


    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error



class AuthManager(object):
    """"""Authentication Manager.""""""
    
    def __new__(cls):
        singleton = cls.__dict__.get('__singleton__')
        if singleton is not None:
            return singleton

        cls.__singleton__ = singleton = object.__new__(cls)

        return singleton


    def __init__(self):
        self.passwd = {}
        self._auth = {}


    def __repr__(self):
        return '<AuthManager [%s]>' % (self.method)


    def add_auth(self, uri, auth):
        """"""Registers AuthObject to AuthManager.""""""
        
        uri = self.reduce_uri(uri, False)
        self._auth[uri] = auth

    def add_password(self, realm, uri, user, passwd):
        """"""Adds password to AuthManager.""""""
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]
            
        reduced_uri = tuple([self.reduce_uri(u, False) for u in uri])
        
        if reduced_uri not in self.passwd:
            self.passwd[reduced_uri] = {}
        self.passwd[reduced_uri] = (user, passwd)


    def find_user_password(self, realm, authuri):
        for uris, authinfo in self.passwd.iteritems():
            reduced_authuri = self.reduce_uri(authuri, False)
            for uri in uris:
                if self.is_suburi(uri, reduced_authuri):
                    return authinfo

        return (None, None)


    def get_auth(self, uri):
        uri = self.reduce_uri(uri, False)
        return self._auth.get(uri, None)


    def reduce_uri(self, uri, default_port=True):
        """"""Accept authority or URI and extract only the authority and path.""""""
        # note HTTP URLs do not have a userinfo component
        parts = urllib2.urlparse.urlsplit(uri)
        if parts[1]:
            # URI
            scheme = parts[0]
            authority = parts[1]
            path = parts[2] or '/'
        else:
            # host or host:port
            scheme = None
            authority = uri
            path = '/'
        host, port = urllib2.splitport(authority)
        if default_port and port is None and scheme is not None:
            dport = {""http"": 80,
                     ""https"": 443,
                     }.get(scheme)
            if dport is not None:
                authority = ""%s:%d"" % (host, dport)
        return authority, path

    
    def is_suburi(self, base, test):
        """"""Check if test is below base in a URI tree

        Both args must be URIs in reduced form.
        """"""
        if base == test:
            return True
        if base[0] != test[0]:
            return False
        common = urllib2.posixpath.commonprefix((base[1], test[1]))
        if len(common) == len(base[1]):
            return True
        return False


    def empty(self):
        self.passwd = {}


    def remove(self, uri, realm=None):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        for default_port in True, False:
            reduced_uri = tuple([self.reduce_uri(u, default_port) for u in uri])
            del self.passwd[reduced_uri][realm]


    def __contains__(self, uri):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        uri = tuple([self.reduce_uri(u, False) for u in uri])

        if uri in self.passwd:
            return True

        return False

auth_manager = AuthManager()



class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.

    :param username: Username to authenticate with.
    :param password: Password for given username.
    :param realm: (optional) the realm this auth applies to
    :param handler: (optional) basic || digest || proxy_basic || proxy_digest
    """"""

    _handlers = {
        'basic': urllib2.HTTPBasicAuthHandler,
        'digest': urllib2.HTTPDigestAuthHandler,
        'proxy_basic': urllib2.ProxyBasicAuthHandler,
        'proxy_digest': urllib2.ProxyDigestAuthHandler
    }

    def __init__(self, username, password, handler='basic', realm=None):
        self.username = username
        self.password = password
        self.realm = realm

        if isinstance(handler, basestring):
            self.handler = self._handlers.get(handler.lower(), urllib2.HTTPBasicAuthHandler)
        else:
            self.handler = handler




def request(method, url, **kwargs):
    """"""Sends a `method` request. Returns :class:`Response` object.

    :param method: method for the new :class:`Request` object.
    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET/HEAD/DELETE Parameters to send with the :class:`Request`.
    :param data: (optional) Bytes/Dictionary of PUT/POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    data = kwargs.pop('data', dict()) or kwargs.pop('params', dict())

    r = Request(method=method, url=url, data=data, headers=kwargs.pop('headers', {}),
                cookiejar=kwargs.pop('cookies', None), files=kwargs.pop('files', None),
                auth=kwargs.pop('auth', auth_manager.get_auth(url)))
    r.send()

    return r.response


def get(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    
    return request('GET', url, params=params, headers=headers, cookies=cookies, auth=auth)


def head(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('HEAD', url, params=params, headers=headers, cookies=cookies, auth=auth)


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('POST', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth)


def put(url, data='', headers={}, files={}, cookies=None, auth=None):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('PUT', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth)


def delete(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of DELETE Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('DELETE', url, params=params, headers=headers, cookies=cookies, auth=auth)



class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""

class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""

class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","@@ -122,13 +122,22 @@ class Request(object):
 
             _handlers.append(self.auth.handler)
 
-        if _handlers:
-            _handlers.extend(get_handlers())
-            opener = urllib2.build_opener(*_handlers)
-            return opener.open
-        else:
+        if not _handlers:
             return urllib2.urlopen
 
+        _handlers.extend(get_handlers())
+        opener = urllib2.build_opener(*_handlers)
+
+        if self.headers:
+            # Allow default headers in the opener to be overloaded
+            normal_keys = [k.capitalize() for k in self.headers]
+            for key, val in opener.addheaders[:]:
+                if key not in normal_keys:
+                    continue
+                # Remove it, we have a value to take its place
+                opener.addheaders.remove((key, val))
+
+        return opener.open
 
     def _build_response(self, resp):
         """"""Build internal Response object from given response.""""""
",fix bug in urllib2 request class,[requests/core.py] fix bug in urllib2 request class,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.9783045644981612,Minor,Minor,YES
2401f149750337970300383634f3942e9da3c68f,Fixing User-agent header problem introduced with Python 2.7.1,test_requests.py,"#!/usr/bin/env python
# -*- coding: utf-8 -*-

import unittest
import cookielib

import requests


class RequestsTestSuite(unittest.TestCase):
    """"""Requests test cases.""""""

    def setUp(self):
        pass

    def tearDown(self):
        """"""Teardown.""""""
        pass

    def test_invalid_url(self):
        self.assertRaises(ValueError, requests.get, 'hiwpefhipowhefopw')

    def test_HTTP_200_OK_GET(self):
        r = requests.get('http://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTPS_200_OK_GET(self):
        r = requests.get('https://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTP_200_OK_GET_WITH_PARAMS(self):

        heads = {'User-agent': 'Mozilla/5.0'}
        
        r = requests.get('http://www.google.com/search', params={'q': 'test'}, headers=heads)
        self.assertEqual(r.status_code, 200)


    def test_HTTP_200_OK_GET_WITH_MIXED_PARAMS(self):

        heads = {'User-agent': 'Mozilla/5.0'}

        r = requests.get('http://google.com/search?test=true', params={'q': 'test'}, headers=heads)
        self.assertEqual(r.status_code, 200)
        
    def test_HTTP_200_OK_HEAD(self):
        r = requests.head('http://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTPS_200_OK_HEAD(self):
        r = requests.head('https://google.com')
        self.assertEqual(r.status_code, 200)

    def test_AUTH_HTTPS_200_OK_GET(self):
        auth = ('requeststest', 'requeststest')
        url = 'https://convore.com/api/account/verify.json'
        r = requests.get(url, auth=auth)

        self.assertEqual(r.status_code, 200)

        r = requests.get(url)
        self.assertEqual(r.status_code, 200)

        # reset auto authentication
        requests.auth_manager.empty()

    def test_POSTBIN_GET_POST_FILES(self):

        bin = requests.post('http://www.postbin.org/')
        print bin.url
        self.assertEqual(bin.status_code, 200)
        
        post = requests.post(bin.url, data={'some': 'data'})
        self.assertEqual(post.status_code, 201)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')})
        self.assertEqual(post2.status_code, 201)

    def test_POSTBIN_GET_POST_FILES_WITH_PARAMS(self):

        bin = requests.post('http://www.postbin.org/')
        
        self.assertEqual(bin.status_code, 200)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')}, data={'some': 'data'})
        self.assertEqual(post2.status_code, 201)


    def test_POSTBIN_GET_POST_FILES_WITH_HEADERS(self):

        bin = requests.post('http://www.postbin.org/')
        self.assertEqual(bin.status_code, 200)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')},
        headers={'User-Agent': 'requests-tests'})

        self.assertEqual(post2.status_code, 201)
  
    def test_nonzero_evaluation(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(bool(r), False)
    
        r = requests.get('http://google.com/')
        self.assertEqual(bool(r), True)
    
    def test_request_ok_set(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(r.ok, False)
    
    def test_status_raising(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertRaises(requests.HTTPError, r.raise_for_status)
    
        r = requests.get('http://google.com/')
        self.assertFalse(r.error)
        r.raise_for_status()
        
    def test_cookie_jar(self):
        """"""
        .. todo:: This really doesn't test to make sure the cookie is working
        """"""
        jar = cookielib.CookieJar()
        self.assertFalse(jar)

        requests.get('http://google.com', cookies=jar)
        self.assertTrue(jar)



if __name__ == '__main__':
    unittest.main()
","#!/usr/bin/env python
# -*- coding: utf-8 -*-

import unittest
import cookielib

import requests


class RequestsTestSuite(unittest.TestCase):
    """"""Requests test cases.""""""

    def setUp(self):
        pass

    def tearDown(self):
        """"""Teardown.""""""
        pass

    def test_invalid_url(self):
        self.assertRaises(ValueError, requests.get, 'hiwpefhipowhefopw')

    def test_HTTP_200_OK_GET(self):
        r = requests.get('http://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTPS_200_OK_GET(self):
        r = requests.get('https://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTP_200_OK_GET_WITH_PARAMS(self):
        heads = {'User-agent': 'Mozilla/5.0'}
        
        r = requests.get('http://www.google.com/search', params={'q': 'test'}, headers=heads)
        self.assertEqual(r.status_code, 200)

    def test_HTTP_200_OK_GET_WITH_MIXED_PARAMS(self):
        heads = {'User-agent': 'Mozilla/5.0'}

        r = requests.get('http://google.com/search?test=true', params={'q': 'test'}, headers=heads)
        self.assertEqual(r.status_code, 200)

    def test_user_agent_transfers(self):
        """"""Issue XX""""""
        heads = {'User-agent':
                 'Mozilla/5.0 (github.com/kennethreitz/requests)'}

        r = requests.get('http://whatsmyua.com', headers=heads);
        self.assertTrue(heads['User-agent'] in r.content)
        
    def test_HTTP_200_OK_HEAD(self):
        r = requests.head('http://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTPS_200_OK_HEAD(self):
        r = requests.head('https://google.com')
        self.assertEqual(r.status_code, 200)

    def test_AUTH_HTTPS_200_OK_GET(self):
        auth = ('requeststest', 'requeststest')
        url = 'https://convore.com/api/account/verify.json'
        r = requests.get(url, auth=auth)

        self.assertEqual(r.status_code, 200)

        r = requests.get(url)
        self.assertEqual(r.status_code, 200)

        # reset auto authentication
        requests.auth_manager.empty()

    def test_POSTBIN_GET_POST_FILES(self):
        bin = requests.post('http://www.postbin.org/')
        print bin.url
        self.assertEqual(bin.status_code, 200)
        
        post = requests.post(bin.url, data={'some': 'data'})
        self.assertEqual(post.status_code, 201)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')})
        self.assertEqual(post2.status_code, 201)

    def test_POSTBIN_GET_POST_FILES_WITH_PARAMS(self):
        bin = requests.post('http://www.postbin.org/')
        
        self.assertEqual(bin.status_code, 200)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')}, data={'some': 'data'})
        self.assertEqual(post2.status_code, 201)


    def test_POSTBIN_GET_POST_FILES_WITH_HEADERS(self):
        bin = requests.post('http://www.postbin.org/')
        self.assertEqual(bin.status_code, 200)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')},
        headers={'User-Agent': 'requests-tests'})

        self.assertEqual(post2.status_code, 201)
  
    def test_nonzero_evaluation(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(bool(r), False)
    
        r = requests.get('http://google.com/')
        self.assertEqual(bool(r), True)
    
    def test_request_ok_set(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(r.ok, False)
    
    def test_status_raising(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertRaises(requests.HTTPError, r.raise_for_status)
    
        r = requests.get('http://google.com/')
        self.assertFalse(r.error)
        r.raise_for_status()
        
    def test_cookie_jar(self):
        """"""
        .. todo:: This really doesn't test to make sure the cookie is working
        """"""
        jar = cookielib.CookieJar()
        self.assertFalse(jar)

        requests.get('http://google.com', cookies=jar)
        self.assertTrue(jar)



if __name__ == '__main__':
    unittest.main()
","@@ -29,19 +29,24 @@ class RequestsTestSuite(unittest.TestCase):
         self.assertEqual(r.status_code, 200)
 
     def test_HTTP_200_OK_GET_WITH_PARAMS(self):
-
         heads = {'User-agent': 'Mozilla/5.0'}
         
         r = requests.get('http://www.google.com/search', params={'q': 'test'}, headers=heads)
         self.assertEqual(r.status_code, 200)
 
-
     def test_HTTP_200_OK_GET_WITH_MIXED_PARAMS(self):
-
         heads = {'User-agent': 'Mozilla/5.0'}
 
         r = requests.get('http://google.com/search?test=true', params={'q': 'test'}, headers=heads)
         self.assertEqual(r.status_code, 200)
+
+    def test_user_agent_transfers(self):
+        """"""Issue XX""""""
+        heads = {'User-agent':
+                 'Mozilla/5.0 (github.com/kennethreitz/requests)'}
+
+        r = requests.get('http://whatsmyua.com', headers=heads);
+        self.assertTrue(heads['User-agent'] in r.content)
         
     def test_HTTP_200_OK_HEAD(self):
         r = requests.head('http://google.com')
@@ -65,7 +70,6 @@ class RequestsTestSuite(unittest.TestCase):
         requests.auth_manager.empty()
 
     def test_POSTBIN_GET_POST_FILES(self):
-
         bin = requests.post('http://www.postbin.org/')
         print bin.url
         self.assertEqual(bin.status_code, 200)
@@ -77,7 +81,6 @@ class RequestsTestSuite(unittest.TestCase):
         self.assertEqual(post2.status_code, 201)
 
     def test_POSTBIN_GET_POST_FILES_WITH_PARAMS(self):
-
         bin = requests.post('http://www.postbin.org/')
         
         self.assertEqual(bin.status_code, 200)
@@ -87,7 +90,6 @@ class RequestsTestSuite(unittest.TestCase):
 
 
     def test_POSTBIN_GET_POST_FILES_WITH_HEADERS(self):
-
         bin = requests.post('http://www.postbin.org/')
         self.assertEqual(bin.status_code, 200)
 
",add more test cases,[test_requests.py] add more test cases,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.9998484253883362,0.9369728608174284,Minor,Minor,YES
7a62b10ff2fb5091d77aaf63d1ab091713ead332,Automatically decompress gzipped responses if content-type is set. fixes #19,requests/core.py,"# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import

import urllib
import urllib2

from urllib2 import HTTPError
from urlparse import urlparse

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers, get_handlers



__title__ = 'requests'
__version__ = '0.3.1'
__build__ = 0x000301
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'

__all__ = [
    'Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete',
    'auth_manager', 'AuthObject','RequestException', 'AuthenticationError',
    'URLRequired', 'InvalidMethod', 'HTTPError'
]



class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""

    def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""

    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')

    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 data=dict(), auth=None, cookiejar=None):

        self.url = url
        self.headers = headers
        self.files = files
        self.method = method
        self.data = data

        # url encode data if it's a dict
        if hasattr(data, 'items'):
            self._enc_data = urllib.urlencode(data)
        else:
            self._enc_data = data

        self.response = Response()

        if isinstance(auth, (list, tuple)):
            auth = AuthObject(*auth)
        if not auth:
            auth = auth_manager.get_auth(self.url)
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False


    def __repr__(self):
        return '<Request [%s]>' % (self.method)


    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()

        object.__setattr__(self, name, value)


    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired


    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.cookiejar is not None:
            _handlers.append(urllib2.HTTPCookieProcessor(self.cookiejar))

        if self.auth:
            if not isinstance(self.auth.handler, (urllib2.AbstractBasicAuthHandler, urllib2.AbstractDigestAuthHandler)):
                auth_manager.add_password(self.auth.realm, self.url, self.auth.username, self.auth.password)
                self.auth.handler = self.auth.handler(auth_manager)
                auth_manager.add_auth(self.url, self.auth)

            _handlers.append(self.auth.handler)

        if not _handlers:
            return urllib2.urlopen

        _handlers.extend(get_handlers())
        opener = urllib2.build_opener(*_handlers)

        if self.headers:
            # Allow default headers in the opener to be overloaded
            normal_keys = [k.capitalize() for k in self.headers]
            for key, val in opener.addheaders[:]:
                if key not in normal_keys:
                    continue
                # Remove it, we have a value to take its place
                opener.addheaders.remove((key, val))

        return opener.open

    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""

        self.response.status_code = getattr(resp, 'code', None)
        self.response.headers = getattr(resp.info(), 'dict', None)
        self.response.url = getattr(resp, 'url', None)
        self.response.content = resp.read()


    @staticmethod
    def _build_url(url, data):
        """"""Build URLs.""""""

        if urlparse(url).query:
            return '%s&%s' % (url, data)
        else:
            if data:
                return '%s?%s' % (url, data)
            else:
                return url

    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""
        self._checks()
        success = False

        if self.method in ('GET', 'HEAD', 'DELETE'):
            req = _Request(self._build_url(self.url, self._enc_data), method=self.method)
        else:

            if self.files:
                register_openers()

                if self.data:
                    self.files.update(self.data)

                datagen, headers = multipart_encode(self.files)
                req = _Request(self.url, data=datagen, headers=headers, method=self.method)

            else:
                req = _Request(self.url, data=self._enc_data, method=self.method)

        if self.headers:
            req.headers.update(self.headers)

        if not self.sent or anyway:
            try:
                opener = self._get_opener()
                resp = opener(req)

                if self.cookiejar is not None:
                    self.cookiejar.extract_cookies(resp, req)

            except urllib2.HTTPError, why:
                self._build_response(why)
                self.response.error = why
            else:
                self._build_response(resp)
                self.response.ok = True

            self.response.cached = False
        else:
            self.response.cached = True

        self.sent = self.response.ok

        return self.sent


    def read(self, *args):
        return self.response.read()

class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        self.cached = False


    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)


    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error


    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error

    def read(self, *args):
        return self.content


class AuthManager(object):
    """"""Authentication Manager.""""""

    def __new__(cls):
        singleton = cls.__dict__.get('__singleton__')
        if singleton is not None:
            return singleton

        cls.__singleton__ = singleton = object.__new__(cls)

        return singleton


    def __init__(self):
        self.passwd = {}
        self._auth = {}


    def __repr__(self):
        return '<AuthManager [%s]>' % (self.method)


    def add_auth(self, uri, auth):
        """"""Registers AuthObject to AuthManager.""""""

        uri = self.reduce_uri(uri, False)
        self._auth[uri] = auth

    def add_password(self, realm, uri, user, passwd):
        """"""Adds password to AuthManager.""""""
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        reduced_uri = tuple([self.reduce_uri(u, False) for u in uri])

        if reduced_uri not in self.passwd:
            self.passwd[reduced_uri] = {}
        self.passwd[reduced_uri] = (user, passwd)


    def find_user_password(self, realm, authuri):
        for uris, authinfo in self.passwd.iteritems():
            reduced_authuri = self.reduce_uri(authuri, False)
            for uri in uris:
                if self.is_suburi(uri, reduced_authuri):
                    return authinfo

        return (None, None)


    def get_auth(self, uri):
        uri = self.reduce_uri(uri, False)
        return self._auth.get(uri, None)


    def reduce_uri(self, uri, default_port=True):
        """"""Accept authority or URI and extract only the authority and path.""""""
        # note HTTP URLs do not have a userinfo component
        parts = urllib2.urlparse.urlsplit(uri)
        if parts[1]:
            # URI
            scheme = parts[0]
            authority = parts[1]
            path = parts[2] or '/'
        else:
            # host or host:port
            scheme = None
            authority = uri
            path = '/'
        host, port = urllib2.splitport(authority)
        if default_port and port is None and scheme is not None:
            dport = {""http"": 80,
                     ""https"": 443,
                     }.get(scheme)
            if dport is not None:
                authority = ""%s:%d"" % (host, dport)
        return authority, path


    def is_suburi(self, base, test):
        """"""Check if test is below base in a URI tree

        Both args must be URIs in reduced form.
        """"""
        if base == test:
            return True
        if base[0] != test[0]:
            return False
        common = urllib2.posixpath.commonprefix((base[1], test[1]))
        if len(common) == len(base[1]):
            return True
        return False


    def empty(self):
        self.passwd = {}


    def remove(self, uri, realm=None):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        for default_port in True, False:
            reduced_uri = tuple([self.reduce_uri(u, default_port) for u in uri])
            del self.passwd[reduced_uri][realm]


    def __contains__(self, uri):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        uri = tuple([self.reduce_uri(u, False) for u in uri])

        if uri in self.passwd:
            return True

        return False

auth_manager = AuthManager()



class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.

    :param username: Username to authenticate with.
    :param password: Password for given username.
    :param realm: (optional) the realm this auth applies to
    :param handler: (optional) basic || digest || proxy_basic || proxy_digest
    """"""

    _handlers = {
        'basic': urllib2.HTTPBasicAuthHandler,
        'digest': urllib2.HTTPDigestAuthHandler,
        'proxy_basic': urllib2.ProxyBasicAuthHandler,
        'proxy_digest': urllib2.ProxyDigestAuthHandler
    }

    def __init__(self, username, password, handler='basic', realm=None):
        self.username = username
        self.password = password
        self.realm = realm

        if isinstance(handler, basestring):
            self.handler = self._handlers.get(handler.lower(), urllib2.HTTPBasicAuthHandler)
        else:
            self.handler = handler




def request(method, url, **kwargs):
    """"""Sends a `method` request. Returns :class:`Response` object.

    :param method: method for the new :class:`Request` object.
    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET/HEAD/DELETE Parameters to send with the :class:`Request`.
    :param data: (optional) Bytes/Dictionary of PUT/POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    data = kwargs.pop('data', dict()) or kwargs.pop('params', dict())

    r = Request(method=method, url=url, data=data, headers=kwargs.pop('headers', {}),
                cookiejar=kwargs.pop('cookies', None), files=kwargs.pop('files', None),
                auth=kwargs.pop('auth', auth_manager.get_auth(url)))
    r.send()

    return r.response


def get(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('GET', url, params=params, headers=headers, cookies=cookies, auth=auth)


def head(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('HEAD', url, params=params, headers=headers, cookies=cookies, auth=auth)


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('POST', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth)


def put(url, data='', headers={}, files={}, cookies=None, auth=None):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('PUT', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth)


def delete(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of DELETE Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('DELETE', url, params=params, headers=headers, cookies=cookies, auth=auth)



class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""

class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""

class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import

import urllib
import urllib2
import zlib

from urllib2 import HTTPError
from urlparse import urlparse

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers, get_handlers



__title__ = 'requests'
__version__ = '0.3.1'
__build__ = 0x000301
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'

__all__ = [
    'Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete',
    'auth_manager', 'AuthObject','RequestException', 'AuthenticationError',
    'URLRequired', 'InvalidMethod', 'HTTPError'
]



class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""

    def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""

    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')

    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 data=dict(), auth=None, cookiejar=None):

        self.url = url
        self.headers = headers
        self.files = files
        self.method = method
        self.data = data

        # url encode data if it's a dict
        if hasattr(data, 'items'):
            self._enc_data = urllib.urlencode(data)
        else:
            self._enc_data = data

        self.response = Response()

        if isinstance(auth, (list, tuple)):
            auth = AuthObject(*auth)
        if not auth:
            auth = auth_manager.get_auth(self.url)
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False


    def __repr__(self):
        return '<Request [%s]>' % (self.method)


    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()

        object.__setattr__(self, name, value)


    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired


    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.cookiejar is not None:
            _handlers.append(urllib2.HTTPCookieProcessor(self.cookiejar))

        if self.auth:
            if not isinstance(self.auth.handler, (urllib2.AbstractBasicAuthHandler, urllib2.AbstractDigestAuthHandler)):
                auth_manager.add_password(self.auth.realm, self.url, self.auth.username, self.auth.password)
                self.auth.handler = self.auth.handler(auth_manager)
                auth_manager.add_auth(self.url, self.auth)

            _handlers.append(self.auth.handler)

        if not _handlers:
            return urllib2.urlopen

        _handlers.extend(get_handlers())
        opener = urllib2.build_opener(*_handlers)

        if self.headers:
            # Allow default headers in the opener to be overloaded
            normal_keys = [k.capitalize() for k in self.headers]
            for key, val in opener.addheaders[:]:
                if key not in normal_keys:
                    continue
                # Remove it, we have a value to take its place
                opener.addheaders.remove((key, val))

        return opener.open

    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""

        self.response.status_code = getattr(resp, 'code', None)
        self.response.headers = getattr(resp.info(), 'dict', None)
        self.response.content = resp.read()

        if self.response.headers.get('content-encoding', None) == 'gzip':
            try:
                self.response.content = zlib.decompress(self.response.content, 16+zlib.MAX_WBITS)
            except zlib.error:
                pass

        self.response.url = getattr(resp, 'url', None)

    @staticmethod
    def _build_url(url, data):
        """"""Build URLs.""""""

        if urlparse(url).query:
            return '%s&%s' % (url, data)
        else:
            if data:
                return '%s?%s' % (url, data)
            else:
                return url

    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""
        self._checks()
        success = False

        if self.method in ('GET', 'HEAD', 'DELETE'):
            req = _Request(self._build_url(self.url, self._enc_data), method=self.method)
        else:

            if self.files:
                register_openers()

                if self.data:
                    self.files.update(self.data)

                datagen, headers = multipart_encode(self.files)
                req = _Request(self.url, data=datagen, headers=headers, method=self.method)

            else:
                req = _Request(self.url, data=self._enc_data, method=self.method)

        if self.headers:
            req.headers.update(self.headers)

        if not self.sent or anyway:
            try:
                opener = self._get_opener()
                resp = opener(req)

                if self.cookiejar is not None:
                    self.cookiejar.extract_cookies(resp, req)

            except urllib2.HTTPError, why:
                self._build_response(why)
                self.response.error = why
            else:
                self._build_response(resp)
                self.response.ok = True

            self.response.cached = False
        else:
            self.response.cached = True

        self.sent = self.response.ok

        return self.sent


    def read(self, *args):
        return self.response.read()

class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        self.cached = False


    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)


    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error


    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error

    def read(self, *args):
        return self.content


class AuthManager(object):
    """"""Authentication Manager.""""""

    def __new__(cls):
        singleton = cls.__dict__.get('__singleton__')
        if singleton is not None:
            return singleton

        cls.__singleton__ = singleton = object.__new__(cls)

        return singleton


    def __init__(self):
        self.passwd = {}
        self._auth = {}


    def __repr__(self):
        return '<AuthManager [%s]>' % (self.method)


    def add_auth(self, uri, auth):
        """"""Registers AuthObject to AuthManager.""""""

        uri = self.reduce_uri(uri, False)
        self._auth[uri] = auth

    def add_password(self, realm, uri, user, passwd):
        """"""Adds password to AuthManager.""""""
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        reduced_uri = tuple([self.reduce_uri(u, False) for u in uri])

        if reduced_uri not in self.passwd:
            self.passwd[reduced_uri] = {}
        self.passwd[reduced_uri] = (user, passwd)


    def find_user_password(self, realm, authuri):
        for uris, authinfo in self.passwd.iteritems():
            reduced_authuri = self.reduce_uri(authuri, False)
            for uri in uris:
                if self.is_suburi(uri, reduced_authuri):
                    return authinfo

        return (None, None)


    def get_auth(self, uri):
        uri = self.reduce_uri(uri, False)
        return self._auth.get(uri, None)


    def reduce_uri(self, uri, default_port=True):
        """"""Accept authority or URI and extract only the authority and path.""""""
        # note HTTP URLs do not have a userinfo component
        parts = urllib2.urlparse.urlsplit(uri)
        if parts[1]:
            # URI
            scheme = parts[0]
            authority = parts[1]
            path = parts[2] or '/'
        else:
            # host or host:port
            scheme = None
            authority = uri
            path = '/'
        host, port = urllib2.splitport(authority)
        if default_port and port is None and scheme is not None:
            dport = {""http"": 80,
                     ""https"": 443,
                     }.get(scheme)
            if dport is not None:
                authority = ""%s:%d"" % (host, dport)
        return authority, path


    def is_suburi(self, base, test):
        """"""Check if test is below base in a URI tree

        Both args must be URIs in reduced form.
        """"""
        if base == test:
            return True
        if base[0] != test[0]:
            return False
        common = urllib2.posixpath.commonprefix((base[1], test[1]))
        if len(common) == len(base[1]):
            return True
        return False


    def empty(self):
        self.passwd = {}


    def remove(self, uri, realm=None):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        for default_port in True, False:
            reduced_uri = tuple([self.reduce_uri(u, default_port) for u in uri])
            del self.passwd[reduced_uri][realm]


    def __contains__(self, uri):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        uri = tuple([self.reduce_uri(u, False) for u in uri])

        if uri in self.passwd:
            return True

        return False

auth_manager = AuthManager()



class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.

    :param username: Username to authenticate with.
    :param password: Password for given username.
    :param realm: (optional) the realm this auth applies to
    :param handler: (optional) basic || digest || proxy_basic || proxy_digest
    """"""

    _handlers = {
        'basic': urllib2.HTTPBasicAuthHandler,
        'digest': urllib2.HTTPDigestAuthHandler,
        'proxy_basic': urllib2.ProxyBasicAuthHandler,
        'proxy_digest': urllib2.ProxyDigestAuthHandler
    }

    def __init__(self, username, password, handler='basic', realm=None):
        self.username = username
        self.password = password
        self.realm = realm

        if isinstance(handler, basestring):
            self.handler = self._handlers.get(handler.lower(), urllib2.HTTPBasicAuthHandler)
        else:
            self.handler = handler




def request(method, url, **kwargs):
    """"""Sends a `method` request. Returns :class:`Response` object.

    :param method: method for the new :class:`Request` object.
    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET/HEAD/DELETE Parameters to send with the :class:`Request`.
    :param data: (optional) Bytes/Dictionary of PUT/POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    data = kwargs.pop('data', dict()) or kwargs.pop('params', dict())

    r = Request(method=method, url=url, data=data, headers=kwargs.pop('headers', {}),
                cookiejar=kwargs.pop('cookies', None), files=kwargs.pop('files', None),
                auth=kwargs.pop('auth', auth_manager.get_auth(url)))
    r.send()

    return r.response


def get(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('GET', url, params=params, headers=headers, cookies=cookies, auth=auth)


def head(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('HEAD', url, params=params, headers=headers, cookies=cookies, auth=auth)


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('POST', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth)


def put(url, data='', headers={}, files={}, cookies=None, auth=None):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('PUT', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth)


def delete(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of DELETE Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('DELETE', url, params=params, headers=headers, cookies=cookies, auth=auth)



class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""

class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""

class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","@@ -14,6 +14,7 @@ from __future__ import absolute_import
 
 import urllib
 import urllib2
+import zlib
 
 from urllib2 import HTTPError
 from urlparse import urlparse
@@ -144,9 +145,15 @@ class Request(object):
 
         self.response.status_code = getattr(resp, 'code', None)
         self.response.headers = getattr(resp.info(), 'dict', None)
-        self.response.url = getattr(resp, 'url', None)
         self.response.content = resp.read()
 
+        if self.response.headers.get('content-encoding', None) == 'gzip':
+            try:
+                self.response.content = zlib.decompress(self.response.content, 16+zlib.MAX_WBITS)
+            except zlib.error:
+                pass
+
+        self.response.url = getattr(resp, 'url', None)
 
     @staticmethod
     def _build_url(url, data):
",add missing code in request.py,[requests/core.py] add missing code in request.py,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.9998888373374939,0.986108827885396,Minor,Minor,YES
2814664e91d9a7516f0f5f156fb482b9109a8b5b,Fixes #20.,requests/core.py,"# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import

import urllib
import urllib2
import zlib

from urllib2 import HTTPError
from urlparse import urlparse

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers, get_handlers



__title__ = 'requests'
__version__ = '0.3.1'
__build__ = 0x000301
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'

__all__ = [
    'Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete',
    'auth_manager', 'AuthObject','RequestException', 'AuthenticationError',
    'URLRequired', 'InvalidMethod', 'HTTPError'
]



class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""

    def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""

    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')

    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 data=dict(), auth=None, cookiejar=None):

        self.url = url
        self.headers = headers
        self.files = files
        self.method = method
        self.data = data

        # url encode data if it's a dict
        if hasattr(data, 'items'):
            self._enc_data = urllib.urlencode(data)
        else:
            self._enc_data = data

        self.response = Response()

        if isinstance(auth, (list, tuple)):
            auth = AuthObject(*auth)
        if not auth:
            auth = auth_manager.get_auth(self.url)
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False


    def __repr__(self):
        return '<Request [%s]>' % (self.method)


    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()

        object.__setattr__(self, name, value)


    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired


    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.cookiejar is not None:
            _handlers.append(urllib2.HTTPCookieProcessor(self.cookiejar))

        if self.auth:
            if not isinstance(self.auth.handler, (urllib2.AbstractBasicAuthHandler, urllib2.AbstractDigestAuthHandler)):
                auth_manager.add_password(self.auth.realm, self.url, self.auth.username, self.auth.password)
                self.auth.handler = self.auth.handler(auth_manager)
                auth_manager.add_auth(self.url, self.auth)

            _handlers.append(self.auth.handler)

        if not _handlers:
            return urllib2.urlopen

        _handlers.extend(get_handlers())
        opener = urllib2.build_opener(*_handlers)

        if self.headers:
            # Allow default headers in the opener to be overloaded
            normal_keys = [k.capitalize() for k in self.headers]
            for key, val in opener.addheaders[:]:
                if key not in normal_keys:
                    continue
                # Remove it, we have a value to take its place
                opener.addheaders.remove((key, val))

        return opener.open

    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""

        self.response.status_code = getattr(resp, 'code', None)
        self.response.headers = getattr(resp.info(), 'dict', None)
        self.response.content = resp.read()

        if self.response.headers.get('content-encoding', None) == 'gzip':
            try:
                self.response.content = zlib.decompress(self.response.content, 16+zlib.MAX_WBITS)
            except zlib.error:
                pass

        self.response.url = getattr(resp, 'url', None)

    @staticmethod
    def _build_url(url, data):
        """"""Build URLs.""""""

        if urlparse(url).query:
            return '%s&%s' % (url, data)
        else:
            if data:
                return '%s?%s' % (url, data)
            else:
                return url

    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""
        self._checks()
        success = False

        if self.method in ('GET', 'HEAD', 'DELETE'):
            req = _Request(self._build_url(self.url, self._enc_data), method=self.method)
        else:

            if self.files:
                register_openers()

                if self.data:
                    self.files.update(self.data)

                datagen, headers = multipart_encode(self.files)
                req = _Request(self.url, data=datagen, headers=headers, method=self.method)

            else:
                req = _Request(self.url, data=self._enc_data, method=self.method)

        if self.headers:
            req.headers.update(self.headers)

        if not self.sent or anyway:
            try:
                opener = self._get_opener()
                resp = opener(req)

                if self.cookiejar is not None:
                    self.cookiejar.extract_cookies(resp, req)

            except urllib2.HTTPError, why:
                self._build_response(why)
                self.response.error = why
            else:
                self._build_response(resp)
                self.response.ok = True

            self.response.cached = False
        else:
            self.response.cached = True

        self.sent = self.response.ok

        return self.sent


    def read(self, *args):
        return self.response.read()

class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        self.cached = False


    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)


    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error


    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error

    def read(self, *args):
        return self.content


class AuthManager(object):
    """"""Authentication Manager.""""""

    def __new__(cls):
        singleton = cls.__dict__.get('__singleton__')
        if singleton is not None:
            return singleton

        cls.__singleton__ = singleton = object.__new__(cls)

        return singleton


    def __init__(self):
        self.passwd = {}
        self._auth = {}


    def __repr__(self):
        return '<AuthManager [%s]>' % (self.method)


    def add_auth(self, uri, auth):
        """"""Registers AuthObject to AuthManager.""""""

        uri = self.reduce_uri(uri, False)
        self._auth[uri] = auth

    def add_password(self, realm, uri, user, passwd):
        """"""Adds password to AuthManager.""""""
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        reduced_uri = tuple([self.reduce_uri(u, False) for u in uri])

        if reduced_uri not in self.passwd:
            self.passwd[reduced_uri] = {}
        self.passwd[reduced_uri] = (user, passwd)


    def find_user_password(self, realm, authuri):
        for uris, authinfo in self.passwd.iteritems():
            reduced_authuri = self.reduce_uri(authuri, False)
            for uri in uris:
                if self.is_suburi(uri, reduced_authuri):
                    return authinfo

        return (None, None)


    def get_auth(self, uri):
        uri = self.reduce_uri(uri, False)
        return self._auth.get(uri, None)


    def reduce_uri(self, uri, default_port=True):
        """"""Accept authority or URI and extract only the authority and path.""""""
        # note HTTP URLs do not have a userinfo component
        parts = urllib2.urlparse.urlsplit(uri)
        if parts[1]:
            # URI
            scheme = parts[0]
            authority = parts[1]
            path = parts[2] or '/'
        else:
            # host or host:port
            scheme = None
            authority = uri
            path = '/'
        host, port = urllib2.splitport(authority)
        if default_port and port is None and scheme is not None:
            dport = {""http"": 80,
                     ""https"": 443,
                     }.get(scheme)
            if dport is not None:
                authority = ""%s:%d"" % (host, dport)
        return authority, path


    def is_suburi(self, base, test):
        """"""Check if test is below base in a URI tree

        Both args must be URIs in reduced form.
        """"""
        if base == test:
            return True
        if base[0] != test[0]:
            return False
        common = urllib2.posixpath.commonprefix((base[1], test[1]))
        if len(common) == len(base[1]):
            return True
        return False


    def empty(self):
        self.passwd = {}


    def remove(self, uri, realm=None):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        for default_port in True, False:
            reduced_uri = tuple([self.reduce_uri(u, default_port) for u in uri])
            del self.passwd[reduced_uri][realm]


    def __contains__(self, uri):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        uri = tuple([self.reduce_uri(u, False) for u in uri])

        if uri in self.passwd:
            return True

        return False

auth_manager = AuthManager()



class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.

    :param username: Username to authenticate with.
    :param password: Password for given username.
    :param realm: (optional) the realm this auth applies to
    :param handler: (optional) basic || digest || proxy_basic || proxy_digest
    """"""

    _handlers = {
        'basic': urllib2.HTTPBasicAuthHandler,
        'digest': urllib2.HTTPDigestAuthHandler,
        'proxy_basic': urllib2.ProxyBasicAuthHandler,
        'proxy_digest': urllib2.ProxyDigestAuthHandler
    }

    def __init__(self, username, password, handler='basic', realm=None):
        self.username = username
        self.password = password
        self.realm = realm

        if isinstance(handler, basestring):
            self.handler = self._handlers.get(handler.lower(), urllib2.HTTPBasicAuthHandler)
        else:
            self.handler = handler




def request(method, url, **kwargs):
    """"""Sends a `method` request. Returns :class:`Response` object.

    :param method: method for the new :class:`Request` object.
    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET/HEAD/DELETE Parameters to send with the :class:`Request`.
    :param data: (optional) Bytes/Dictionary of PUT/POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    data = kwargs.pop('data', dict()) or kwargs.pop('params', dict())

    r = Request(method=method, url=url, data=data, headers=kwargs.pop('headers', {}),
                cookiejar=kwargs.pop('cookies', None), files=kwargs.pop('files', None),
                auth=kwargs.pop('auth', auth_manager.get_auth(url)))
    r.send()

    return r.response


def get(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('GET', url, params=params, headers=headers, cookies=cookies, auth=auth)


def head(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('HEAD', url, params=params, headers=headers, cookies=cookies, auth=auth)


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('POST', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth)


def put(url, data='', headers={}, files={}, cookies=None, auth=None):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('PUT', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth)


def delete(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of DELETE Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('DELETE', url, params=params, headers=headers, cookies=cookies, auth=auth)



class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""

class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""

class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import

import urllib
import urllib2
import zlib

from urllib2 import HTTPError
from urlparse import urlparse

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers, get_handlers



__title__ = 'requests'
__version__ = '0.3.1'
__build__ = 0x000301
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'

__all__ = [
    'Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete',
    'auth_manager', 'AuthObject','RequestException', 'AuthenticationError',
    'URLRequired', 'InvalidMethod', 'HTTPError'
]



class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""

    def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""

    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')

    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 data=dict(), auth=None, cookiejar=None):

        self.url = url
        self.headers = headers
        self.files = files
        self.method = method
        self.data = data

        # url encode data if it's a dict
        if hasattr(data, 'items'):
            self._enc_data = urllib.urlencode(data)
        else:
            self._enc_data = data

        self.response = Response()

        if isinstance(auth, (list, tuple)):
            auth = AuthObject(*auth)
        if not auth:
            auth = auth_manager.get_auth(self.url)
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False


    def __repr__(self):
        return '<Request [%s]>' % (self.method)


    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()

        object.__setattr__(self, name, value)


    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired


    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.cookiejar is not None:
            _handlers.append(urllib2.HTTPCookieProcessor(self.cookiejar))

        if self.auth:
            if not isinstance(self.auth.handler, (urllib2.AbstractBasicAuthHandler, urllib2.AbstractDigestAuthHandler)):
                auth_manager.add_password(self.auth.realm, self.url, self.auth.username, self.auth.password)
                self.auth.handler = self.auth.handler(auth_manager)
                auth_manager.add_auth(self.url, self.auth)

            _handlers.append(self.auth.handler)

        if not _handlers:
            return urllib2.urlopen

        _handlers.extend(get_handlers())
        opener = urllib2.build_opener(*_handlers)

        if self.headers:
            # Allow default headers in the opener to be overloaded
            normal_keys = [k.capitalize() for k in self.headers]
            for key, val in opener.addheaders[:]:
                if key not in normal_keys:
                    continue
                # Remove it, we have a value to take its place
                opener.addheaders.remove((key, val))

        return opener.open

    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""

        self.response.status_code = getattr(resp, 'code', None)
        self.response.headers = getattr(resp.info(), 'dict', None)
        self.response.content = resp.read()

        if self.response.headers.get('content-encoding', None) == 'gzip':
            try:
                self.response.content = zlib.decompress(self.response.content, 16+zlib.MAX_WBITS)
            except zlib.error:
                pass

        self.response.url = getattr(resp, 'url', None)

    @staticmethod
    def _build_url(url, data):
        """"""Build URLs.""""""

        if urlparse(url).query:
            return '%s&%s' % (url, data)
        else:
            if data:
                return '%s?%s' % (url, data)
            else:
                return url

    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""
        self._checks()
        success = False

        if self.method in ('GET', 'HEAD', 'DELETE'):
            req = _Request(self._build_url(self.url, self._enc_data), method=self.method)
        else:

            if self.files:
                register_openers()

                if self.data:
                    self.files.update(self.data)

                datagen, headers = multipart_encode(self.files)
                req = _Request(self.url, data=datagen, headers=headers, method=self.method)

            else:
                req = _Request(self.url, data=self._enc_data, method=self.method)

        if self.headers:
            req.headers.update(self.headers)

        if not self.sent or anyway:
            try:
                opener = self._get_opener()
                resp = opener(req)

                if self.cookiejar is not None:
                    self.cookiejar.extract_cookies(resp, req)

            except urllib2.HTTPError, why:
                self._build_response(why)
                self.response.error = why
            else:
                self._build_response(resp)
                self.response.ok = True

            self.response.cached = False
        else:
            self.response.cached = True

        self.sent = self.response.ok

        return self.sent


    def read(self, *args):
        return self.response.read()

class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        self.cached = False


    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)


    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error


    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error

    def read(self, *args):
        return self.content


class AuthManager(object):
    """"""Authentication Manager.""""""

    def __new__(cls):
        singleton = cls.__dict__.get('__singleton__')
        if singleton is not None:
            return singleton

        cls.__singleton__ = singleton = object.__new__(cls)

        return singleton


    def __init__(self):
        self.passwd = {}
        self._auth = {}


    def __repr__(self):
        return '<AuthManager [%s]>' % (self.method)


    def add_auth(self, uri, auth):
        """"""Registers AuthObject to AuthManager.""""""

        uri = self.reduce_uri(uri, False)

        # try to make it an AuthObject
        if not isinstance(auth, AuthObject):
            try:
                auth = AuthObject(*auth)
            except TypeError:
                pass

        self._auth[uri] = auth

    def add_password(self, realm, uri, user, passwd):
        """"""Adds password to AuthManager.""""""
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        reduced_uri = tuple([self.reduce_uri(u, False) for u in uri])

        if reduced_uri not in self.passwd:
            self.passwd[reduced_uri] = {}
        self.passwd[reduced_uri] = (user, passwd)


    def find_user_password(self, realm, authuri):
        for uris, authinfo in self.passwd.iteritems():
            reduced_authuri = self.reduce_uri(authuri, False)
            for uri in uris:
                if self.is_suburi(uri, reduced_authuri):
                    return authinfo

        return (None, None)


    def get_auth(self, uri):
        (in_domain, in_path) = self.reduce_uri(uri, False)

        for domain, path, authority in (
            (i[0][0], i[0][1], i[1]) for i in self._auth.iteritems()
        ):
            if in_domain == domain:
                if path in in_path:
                    return authority


    def reduce_uri(self, uri, default_port=True):
        """"""Accept authority or URI and extract only the authority and path.""""""
        # note HTTP URLs do not have a userinfo component
        parts = urllib2.urlparse.urlsplit(uri)
        if parts[1]:
            # URI
            scheme = parts[0]
            authority = parts[1]
            path = parts[2] or '/'
        else:
            # host or host:port
            scheme = None
            authority = uri
            path = '/'
        host, port = urllib2.splitport(authority)
        if default_port and port is None and scheme is not None:
            dport = {""http"": 80,
                     ""https"": 443,
                     }.get(scheme)
            if dport is not None:
                authority = ""%s:%d"" % (host, dport)

        return authority, path


    def is_suburi(self, base, test):
        """"""Check if test is below base in a URI tree

        Both args must be URIs in reduced form.
        """"""
        if base == test:
            return True
        if base[0] != test[0]:
            return False
        common = urllib2.posixpath.commonprefix((base[1], test[1]))
        if len(common) == len(base[1]):
            return True
        return False


    def empty(self):
        self.passwd = {}


    def remove(self, uri, realm=None):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        for default_port in True, False:
            reduced_uri = tuple([self.reduce_uri(u, default_port) for u in uri])
            del self.passwd[reduced_uri][realm]


    def __contains__(self, uri):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        uri = tuple([self.reduce_uri(u, False) for u in uri])

        if uri in self.passwd:
            return True

        return False

auth_manager = AuthManager()



class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.

    :param username: Username to authenticate with.
    :param password: Password for given username.
    :param realm: (optional) the realm this auth applies to
    :param handler: (optional) basic || digest || proxy_basic || proxy_digest
    """"""

    _handlers = {
        'basic': urllib2.HTTPBasicAuthHandler,
        'digest': urllib2.HTTPDigestAuthHandler,
        'proxy_basic': urllib2.ProxyBasicAuthHandler,
        'proxy_digest': urllib2.ProxyDigestAuthHandler
    }

    def __init__(self, username, password, handler='basic', realm=None):
        self.username = username
        self.password = password
        self.realm = realm

        if isinstance(handler, basestring):
            self.handler = self._handlers.get(handler.lower(), urllib2.HTTPBasicAuthHandler)
        else:
            self.handler = handler




def request(method, url, **kwargs):
    """"""Sends a `method` request. Returns :class:`Response` object.

    :param method: method for the new :class:`Request` object.
    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET/HEAD/DELETE Parameters to send with the :class:`Request`.
    :param data: (optional) Bytes/Dictionary of PUT/POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    data = kwargs.pop('data', dict()) or kwargs.pop('params', dict())

    r = Request(method=method, url=url, data=data, headers=kwargs.pop('headers', {}),
                cookiejar=kwargs.pop('cookies', None), files=kwargs.pop('files', None),
                auth=kwargs.pop('auth', auth_manager.get_auth(url)))
    r.send()

    return r.response


def get(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('GET', url, params=params, headers=headers, cookies=cookies, auth=auth)


def head(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('HEAD', url, params=params, headers=headers, cookies=cookies, auth=auth)


def post(url, data={}, headers={}, files=None, cookies=None, auth=None):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('POST', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth)


def put(url, data='', headers={}, files={}, cookies=None, auth=None):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('PUT', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth)


def delete(url, params={}, headers={}, cookies=None, auth=None):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of DELETE Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('DELETE', url, params=params, headers=headers, cookies=cookies, auth=auth)



class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""

class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""

class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","@@ -286,6 +286,14 @@ class AuthManager(object):
         """"""Registers AuthObject to AuthManager.""""""
 
         uri = self.reduce_uri(uri, False)
+
+        # try to make it an AuthObject
+        if not isinstance(auth, AuthObject):
+            try:
+                auth = AuthObject(*auth)
+            except TypeError:
+                pass
+
         self._auth[uri] = auth
 
     def add_password(self, realm, uri, user, passwd):
@@ -312,8 +320,14 @@ class AuthManager(object):
 
 
     def get_auth(self, uri):
-        uri = self.reduce_uri(uri, False)
-        return self._auth.get(uri, None)
+        (in_domain, in_path) = self.reduce_uri(uri, False)
+
+        for domain, path, authority in (
+            (i[0][0], i[0][1], i[1]) for i in self._auth.iteritems()
+        ):
+            if in_domain == domain:
+                if path in in_path:
+                    return authority
 
 
     def reduce_uri(self, uri, default_port=True):
@@ -337,6 +351,7 @@ class AuthManager(object):
                      }.get(scheme)
             if dport is not None:
                 authority = ""%s:%d"" % (host, dport)
+
         return authority, path
 
 
",add missing docstrings,[requests/core.py] add missing docstrings,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.9756597257807278,Minor,Minor,YES
64d6c3074f2e1bd5ae5f5d786f83d592a5a56ead,sphinx extension fix,docs/conf.py,"# -*- coding: utf-8 -*-
#
# Requests documentation build configuration file, created by
# sphinx-quickstart on Sun Feb 13 23:54:25 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.todo', 'sphinx.ext.coverage', 'sphinx.ext.pngmath', 'sphinx.ext.jsmath', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Requests'
copyright = u'2011, Kenneth Reitz'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.3.2'
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# ""<project> v<release> documentation"".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named ""default.css"" will overwrite the builtin ""default.css"".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. "".xhtml"").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Requestsdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Requests.tex', u'Requests Documentation',
   u'Kenneth Reitz', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For ""manual"" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'requests', u'Requests Documentation',
     [u'Kenneth Reitz'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False

# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'Requests', u'Requests Documentation', u'Kenneth Reitz',
   'Requests', 'One line description of project.', 'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
texinfo_appendices = []
","# -*- coding: utf-8 -*-
#
# Requests documentation build configuration file, created by
# sphinx-quickstart on Sun Feb 13 23:54:25 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Requests'
copyright = u'2011, Kenneth Reitz'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.3.2'
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# ""<project> v<release> documentation"".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named ""default.css"" will overwrite the builtin ""default.css"".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. "".xhtml"").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Requestsdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Requests.tex', u'Requests Documentation',
   u'Kenneth Reitz', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For ""manual"" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'requests', u'Requests Documentation',
     [u'Kenneth Reitz'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False

# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'Requests', u'Requests Documentation', u'Kenneth Reitz',
   'Requests', 'One line description of project.', 'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
texinfo_appendices = []
","@@ -25,7 +25,7 @@ import sys, os
 
 # Add any Sphinx extension module names here, as strings. They can be extensions
 # coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
-extensions = ['sphinx.ext.autodoc', 'sphinx.ext.todo', 'sphinx.ext.coverage', 'sphinx.ext.pngmath', 'sphinx.ext.jsmath', 'sphinx.ext.viewcode']
+extensions = ['sphinx.ext.autodoc']
 
 # Add any paths that contain templates here, relative to this directory.
 templates_path = ['_templates']
",add documentation extensions to setup.py,[docs/conf.py] add documentation extensions to setup.py,100.0,0.0,232.0,100.0,0.0,232.0,0.0,0.0,0.0,0.9995690584182739,0.9817880251689322,Minor,Minor,YES
8a4a05aac071095ff26d5cf3b4949cbcd01b3cef,test for unicode url issues,test_requests.py,"#!/usr/bin/env python
# -*- coding: utf-8 -*-

import unittest
import cookielib

import requests


class RequestsTestSuite(unittest.TestCase):
    """"""Requests test cases.""""""

    def setUp(self):
        pass

    def tearDown(self):
        """"""Teardown.""""""
        pass

    def test_invalid_url(self):
        self.assertRaises(ValueError, requests.get, 'hiwpefhipowhefopw')

    def test_HTTP_200_OK_GET(self):
        r = requests.get('http://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTPS_200_OK_GET(self):
        r = requests.get('https://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTP_200_OK_GET_WITH_PARAMS(self):
        heads = {'User-agent': 'Mozilla/5.0'}

        r = requests.get('http://www.google.com/search', params={'q': 'test'}, headers=heads)
        self.assertEqual(r.status_code, 200)

    def test_HTTP_200_OK_GET_WITH_MIXED_PARAMS(self):
        heads = {'User-agent': 'Mozilla/5.0'}

        r = requests.get('http://google.com/search?test=true', params={'q': 'test'}, headers=heads)
        self.assertEqual(r.status_code, 200)

    def test_user_agent_transfers(self):
        """"""Issue XX""""""
        heads = {'User-agent':
                 'Mozilla/5.0 (github.com/kennethreitz/requests)'}

        r = requests.get('http://whatsmyua.com', headers=heads);
        self.assertTrue(heads['User-agent'] in r.content)

    def test_HTTP_200_OK_HEAD(self):
        r = requests.head('http://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTPS_200_OK_HEAD(self):
        r = requests.head('https://google.com')
        self.assertEqual(r.status_code, 200)

    def test_AUTH_HTTPS_200_OK_GET(self):
        auth = ('requeststest', 'requeststest')
        url = 'https://convore.com/api/account/verify.json'
        r = requests.get(url, auth=auth)

        self.assertEqual(r.status_code, 200)

        r = requests.get(url)
        self.assertEqual(r.status_code, 200)

        # reset auto authentication
        requests.auth_manager.empty()

    def test_POSTBIN_GET_POST_FILES(self):
        bin = requests.post('http://www.postbin.org/')
        self.assertEqual(bin.status_code, 200)

        post = requests.post(bin.url, data={'some': 'data'})
        self.assertEqual(post.status_code, 201)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')})
        self.assertEqual(post2.status_code, 201)

    def test_POSTBIN_GET_POST_FILES_WITH_PARAMS(self):
        bin = requests.post('http://www.postbin.org/')

        self.assertEqual(bin.status_code, 200)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')}, data={'some': 'data'})
        self.assertEqual(post2.status_code, 201)


    def test_POSTBIN_GET_POST_FILES_WITH_HEADERS(self):
        bin = requests.post('http://www.postbin.org/')
        self.assertEqual(bin.status_code, 200)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')},
        headers={'User-Agent': 'requests-tests'})

        self.assertEqual(post2.status_code, 201)

    def test_nonzero_evaluation(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(bool(r), False)

        r = requests.get('http://google.com/')
        self.assertEqual(bool(r), True)

    def test_request_ok_set(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(r.ok, False)

    def test_status_raising(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertRaises(requests.HTTPError, r.raise_for_status)

        r = requests.get('http://google.com/')
        self.assertFalse(r.error)
        r.raise_for_status()

    def test_cookie_jar(self):
        """"""
        .. todo:: This really doesn't test to make sure the cookie is working
        """"""
        jar = cookielib.CookieJar()
        self.assertFalse(jar)

        requests.get('http://google.com', cookies=jar)
        self.assertTrue(jar)

    def test_decompress_gzip(self):

        r = requests.get('http://api.stackoverflow.com/1.1/users/495995/top-answer-tags')
        r.content.decode('ascii')

    def test_autoauth(self):

        conv_auth = ('requeststest', 'requeststest')
        requests.auth_manager.add_auth('convore.com', conv_auth)

        r = requests.get('https://convore.com/api/account/verify.json')
        self.assertEquals(r.status_code, 200)

if __name__ == '__main__':
    unittest.main()
","#!/usr/bin/env python
# -*- coding: utf-8 -*-

import unittest
import cookielib

import requests


class RequestsTestSuite(unittest.TestCase):
    """"""Requests test cases.""""""

    def setUp(self):
        pass

    def tearDown(self):
        """"""Teardown.""""""
        pass

    def test_invalid_url(self):
        self.assertRaises(ValueError, requests.get, 'hiwpefhipowhefopw')

    def test_HTTP_200_OK_GET(self):
        r = requests.get('http://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTPS_200_OK_GET(self):
        r = requests.get('https://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTP_200_OK_GET_WITH_PARAMS(self):
        heads = {'User-agent': 'Mozilla/5.0'}

        r = requests.get('http://www.google.com/search', params={'q': 'test'}, headers=heads)
        self.assertEqual(r.status_code, 200)

    def test_HTTP_200_OK_GET_WITH_MIXED_PARAMS(self):
        heads = {'User-agent': 'Mozilla/5.0'}

        r = requests.get('http://google.com/search?test=true', params={'q': 'test'}, headers=heads)
        self.assertEqual(r.status_code, 200)

    def test_user_agent_transfers(self):
        """"""Issue XX""""""
        heads = {'User-agent':
                 'Mozilla/5.0 (github.com/kennethreitz/requests)'}

        r = requests.get('http://whatsmyua.com', headers=heads);
        self.assertTrue(heads['User-agent'] in r.content)

    def test_HTTP_200_OK_HEAD(self):
        r = requests.head('http://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTPS_200_OK_HEAD(self):
        r = requests.head('https://google.com')
        self.assertEqual(r.status_code, 200)

    def test_AUTH_HTTPS_200_OK_GET(self):
        auth = ('requeststest', 'requeststest')
        url = 'https://convore.com/api/account/verify.json'
        r = requests.get(url, auth=auth)

        self.assertEqual(r.status_code, 200)

        r = requests.get(url)
        self.assertEqual(r.status_code, 200)

        # reset auto authentication
        requests.auth_manager.empty()

    def test_POSTBIN_GET_POST_FILES(self):
        bin = requests.post('http://www.postbin.org/')
        self.assertEqual(bin.status_code, 200)

        post = requests.post(bin.url, data={'some': 'data'})
        self.assertEqual(post.status_code, 201)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')})
        self.assertEqual(post2.status_code, 201)

    def test_POSTBIN_GET_POST_FILES_WITH_PARAMS(self):
        bin = requests.post('http://www.postbin.org/')

        self.assertEqual(bin.status_code, 200)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')}, data={'some': 'data'})
        self.assertEqual(post2.status_code, 201)


    def test_POSTBIN_GET_POST_FILES_WITH_HEADERS(self):
        bin = requests.post('http://www.postbin.org/')
        self.assertEqual(bin.status_code, 200)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')},
        headers={'User-Agent': 'requests-tests'})

        self.assertEqual(post2.status_code, 201)

    def test_nonzero_evaluation(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(bool(r), False)

        r = requests.get('http://google.com/')
        self.assertEqual(bool(r), True)

    def test_request_ok_set(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(r.ok, False)

    def test_status_raising(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertRaises(requests.HTTPError, r.raise_for_status)

        r = requests.get('http://google.com/')
        self.assertFalse(r.error)
        r.raise_for_status()

    def test_cookie_jar(self):
        """"""
        .. todo:: This really doesn't test to make sure the cookie is working
        """"""
        jar = cookielib.CookieJar()
        self.assertFalse(jar)

        requests.get('http://google.com', cookies=jar)
        self.assertTrue(jar)

    def test_decompress_gzip(self):

        r = requests.get('http://api.stackoverflow.com/1.1/users/495995/top-answer-tags')
        r.content.decode('ascii')

    def test_autoauth(self):

        conv_auth = ('requeststest', 'requeststest')
        requests.auth_manager.add_auth('convore.com', conv_auth)

        r = requests.get('https://convore.com/api/account/verify.json')
        self.assertEquals(r.status_code, 200)

    def test_unicode_get(self):
        requests.get('http://google.com', params={'foo': u'f'})
        requests.get('http://google.com', params={'foo': u'foo'})
        requests.get('http://google.com/', params={'foo': u'foo'})


if __name__ == '__main__':
    unittest.main()
","@@ -139,5 +139,11 @@ class RequestsTestSuite(unittest.TestCase):
         r = requests.get('https://convore.com/api/account/verify.json')
         self.assertEquals(r.status_code, 200)
 
+    def test_unicode_get(self):
+        requests.get('http://google.com', params={'foo': u'f'})
+        requests.get('http://google.com', params={'foo': u'foo'})
+        requests.get('http://google.com/', params={'foo': u'foo'})
+
+
 if __name__ == '__main__':
     unittest.main()
",add test for unicode_get,[test_requests.py] add test for unicode_get,59.88995019622808,0.0,143.0,58.83018460610766,0.0,149.0,-1.0597655901204206,0.0,6.0,1.0,0.9442734247350428,Minor,Minor,YES
23ee58d6ec47a06358008cb7a4ab4f9556edc285,"Encode both keys and values for incoming unicode data as UTF-8, coincidentally fixing a bug that caused UTF-8 encoded byte strings to be encoded twice and causing an UnicodeDecodeError.",requests/core.py,"# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import

import urllib
import urllib2
import socket
import zlib

from urllib2 import HTTPError
from urlparse import urlparse

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers, get_handlers



__title__ = 'requests'
__version__ = '0.3.2'
__build__ = 0x000302
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'

__all__ = [
    'Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete',
    'auth_manager', 'AuthObject','RequestException', 'AuthenticationError',
    'URLRequired', 'InvalidMethod', 'HTTPError'
]



class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""

    def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""

    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')

    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 data=dict(), auth=None, cookiejar=None, timeout=None):

        self.url = url
        self.headers = headers
        self.files = files
        self.method = method
        self.data = data

        socket.setdefaulttimeout(timeout)

        for (k, v) in self.data.iteritems():
            self.data[k] = v.encode('utf-8')

        # url encode data if it's a dict
        if hasattr(data, 'items'):
            self._enc_data = urllib.urlencode(self.data)
        else:
            self._enc_data = self.data

        self.response = Response()

        if isinstance(auth, (list, tuple)):
            auth = AuthObject(*auth)
        if not auth:
            auth = auth_manager.get_auth(self.url)
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False


    def __repr__(self):
        return '<Request [%s]>' % (self.method)


    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()

        object.__setattr__(self, name, value)


    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired


    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.cookiejar is not None:
            _handlers.append(urllib2.HTTPCookieProcessor(self.cookiejar))

        if self.auth:
            if not isinstance(self.auth.handler, (urllib2.AbstractBasicAuthHandler, urllib2.AbstractDigestAuthHandler)):
                auth_manager.add_password(self.auth.realm, self.url, self.auth.username, self.auth.password)
                self.auth.handler = self.auth.handler(auth_manager)
                auth_manager.add_auth(self.url, self.auth)

            _handlers.append(self.auth.handler)

        if not _handlers:
            return urllib2.urlopen

        _handlers.extend(get_handlers())
        opener = urllib2.build_opener(*_handlers)

        if self.headers:
            # Allow default headers in the opener to be overloaded
            normal_keys = [k.capitalize() for k in self.headers]
            for key, val in opener.addheaders[:]:
                if key not in normal_keys:
                    continue
                # Remove it, we have a value to take its place
                opener.addheaders.remove((key, val))

        return opener.open

    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""

        self.response.status_code = getattr(resp, 'code', None)
        self.response.headers = getattr(resp.info(), 'dict', None)
        self.response.content = resp.read()

        if self.response.headers.get('content-encoding', None) == 'gzip':
            try:
                self.response.content = zlib.decompress(self.response.content, 16+zlib.MAX_WBITS)
            except zlib.error:
                pass

        self.response.url = getattr(resp, 'url', None)


    @staticmethod
    def _build_url(url, data=None):
        """"""Build URLs.""""""

        if urlparse(url).query:
            return '%s&%s' % (url, data)
        else:
            if data:
                return '%s?%s' % (url, data)
            else:
                return url


    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""
        self._checks()
        success = False

        if self.method in ('GET', 'HEAD', 'DELETE'):
            req = _Request(self._build_url(self.url, self._enc_data), method=self.method)
        else:

            if self.files:
                register_openers()

                if self.data:
                    self.files.update(self.data)

                datagen, headers = multipart_encode(self.files)
                req = _Request(self.url, data=datagen, headers=headers, method=self.method)

            else:
                req = _Request(self.url, data=self._enc_data, method=self.method)

        if self.headers:
            req.headers.update(self.headers)

        if not self.sent or anyway:



            try:
                opener = self._get_opener()
                resp = opener(req)

                if self.cookiejar is not None:
                    self.cookiejar.extract_cookies(resp, req)

            except urllib2.HTTPError, why:
                self._build_response(why)
                self.response.error = why
            else:
                self._build_response(resp)
                self.response.ok = True

            self.response.cached = False
        else:
            self.response.cached = True

        self.sent = self.response.ok

        return self.sent


    def read(self, *args):
        return self.response.read()



class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        self.cached = False


    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)


    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error


    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error

    def read(self, *args):
        return self.content



class AuthManager(object):
    """"""Authentication Manager.""""""

    def __new__(cls):
        singleton = cls.__dict__.get('__singleton__')
        if singleton is not None:
            return singleton

        cls.__singleton__ = singleton = object.__new__(cls)

        return singleton


    def __init__(self):
        self.passwd = {}
        self._auth = {}


    def __repr__(self):
        return '<AuthManager [%s]>' % (self.method)


    def add_auth(self, uri, auth):
        """"""Registers AuthObject to AuthManager.""""""

        uri = self.reduce_uri(uri, False)

        # try to make it an AuthObject
        if not isinstance(auth, AuthObject):
            try:
                auth = AuthObject(*auth)
            except TypeError:
                pass

        self._auth[uri] = auth


    def add_password(self, realm, uri, user, passwd):
        """"""Adds password to AuthManager.""""""
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        reduced_uri = tuple([self.reduce_uri(u, False) for u in uri])

        if reduced_uri not in self.passwd:
            self.passwd[reduced_uri] = {}
        self.passwd[reduced_uri] = (user, passwd)


    def find_user_password(self, realm, authuri):
        for uris, authinfo in self.passwd.iteritems():
            reduced_authuri = self.reduce_uri(authuri, False)
            for uri in uris:
                if self.is_suburi(uri, reduced_authuri):
                    return authinfo

        return (None, None)


    def get_auth(self, uri):
        (in_domain, in_path) = self.reduce_uri(uri, False)

        for domain, path, authority in (
            (i[0][0], i[0][1], i[1]) for i in self._auth.iteritems()
        ):
            if in_domain == domain:
                if path in in_path:
                    return authority


    def reduce_uri(self, uri, default_port=True):
        """"""Accept authority or URI and extract only the authority and path.""""""
        # note HTTP URLs do not have a userinfo component
        parts = urllib2.urlparse.urlsplit(uri)
        if parts[1]:
            # URI
            scheme = parts[0]
            authority = parts[1]
            path = parts[2] or '/'
        else:
            # host or host:port
            scheme = None
            authority = uri
            path = '/'
        host, port = urllib2.splitport(authority)
        if default_port and port is None and scheme is not None:
            dport = {""http"": 80,
                     ""https"": 443,
                     }.get(scheme)
            if dport is not None:
                authority = ""%s:%d"" % (host, dport)

        return authority, path


    def is_suburi(self, base, test):
        """"""Check if test is below base in a URI tree

        Both args must be URIs in reduced form.
        """"""
        if base == test:
            return True
        if base[0] != test[0]:
            return False
        common = urllib2.posixpath.commonprefix((base[1], test[1]))
        if len(common) == len(base[1]):
            return True
        return False


    def empty(self):
        self.passwd = {}


    def remove(self, uri, realm=None):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        for default_port in True, False:
            reduced_uri = tuple([self.reduce_uri(u, default_port) for u in uri])
            del self.passwd[reduced_uri][realm]


    def __contains__(self, uri):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        uri = tuple([self.reduce_uri(u, False) for u in uri])

        if uri in self.passwd:
            return True

        return False

auth_manager = AuthManager()



class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.

    :param username: Username to authenticate with.
    :param password: Password for given username.
    :param realm: (optional) the realm this auth applies to
    :param handler: (optional) basic || digest || proxy_basic || proxy_digest
    """"""

    _handlers = {
        'basic': urllib2.HTTPBasicAuthHandler,
        'digest': urllib2.HTTPDigestAuthHandler,
        'proxy_basic': urllib2.ProxyBasicAuthHandler,
        'proxy_digest': urllib2.ProxyDigestAuthHandler
    }

    def __init__(self, username, password, handler='basic', realm=None):
        self.username = username
        self.password = password
        self.realm = realm

        if isinstance(handler, basestring):
            self.handler = self._handlers.get(handler.lower(), urllib2.HTTPBasicAuthHandler)
        else:
            self.handler = handler




def request(method, url, **kwargs):
    """"""Sends a `method` request. Returns :class:`Response` object.

    :param method: method for the new :class:`Request` object.
    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET/HEAD/DELETE Parameters to send with the :class:`Request`.
    :param data: (optional) Bytes/Dictionary of PUT/POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    data = kwargs.pop('data', dict()) or kwargs.pop('params', dict())

    r = Request(method=method, url=url, data=data, headers=kwargs.pop('headers', {}),
                cookiejar=kwargs.pop('cookies', None), files=kwargs.pop('files', None),
                auth=kwargs.pop('auth', auth_manager.get_auth(url)),
                timeout=kwargs.pop('timeout', None))
    r.send()

    return r.response


def get(url, params={}, headers={}, cookies=None, auth=None, timeout=None):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('GET', url, params=params, headers=headers, cookies=cookies, auth=auth, timeout=timeout)


def head(url, params={}, headers={}, cookies=None, auth=None, timeout=None):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('HEAD', url, params=params, headers=headers, cookies=cookies, auth=auth, timeout=timeout)


def post(url, data={}, headers={}, files=None, cookies=None, auth=None, timeout=None):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('POST', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth, timeout=timeout)


def put(url, data='', headers={}, files={}, cookies=None, auth=None, timeout=None):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('PUT', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth, timeout=timeout)


def delete(url, params={}, headers={}, cookies=None, auth=None, timeout=None):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of DELETE Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('DELETE', url, params=params, headers=headers, cookies=cookies, auth=auth, timeout=timeout)



class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""

class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""

class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import

import urllib
import urllib2
import socket
import zlib

from urllib2 import HTTPError
from urlparse import urlparse

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers, get_handlers



__title__ = 'requests'
__version__ = '0.3.2'
__build__ = 0x000302
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'

__all__ = [
    'Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete',
    'auth_manager', 'AuthObject','RequestException', 'AuthenticationError',
    'URLRequired', 'InvalidMethod', 'HTTPError'
]



class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""

    def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""

    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')

    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 data=dict(), auth=None, cookiejar=None, timeout=None):

        self.url = url
        self.headers = headers
        self.files = files
        self.method = method
        
        self.data = {}
        for (k, v) in data.items():
            self.data.update({
                k.encode('utf-8') if k.__class__ is unicode else k: \
                v.encode('utf-8') if v.__class__ is unicode else v
            })

        socket.setdefaulttimeout(timeout)

        # url encode data if it's a dict
        if hasattr(data, 'items'):
            self._enc_data = urllib.urlencode(self.data)
        else:
            self._enc_data = self.data

        self.response = Response()

        if isinstance(auth, (list, tuple)):
            auth = AuthObject(*auth)
        if not auth:
            auth = auth_manager.get_auth(self.url)
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False


    def __repr__(self):
        return '<Request [%s]>' % (self.method)


    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()

        object.__setattr__(self, name, value)


    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired


    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.cookiejar is not None:
            _handlers.append(urllib2.HTTPCookieProcessor(self.cookiejar))

        if self.auth:
            if not isinstance(self.auth.handler, (urllib2.AbstractBasicAuthHandler, urllib2.AbstractDigestAuthHandler)):
                auth_manager.add_password(self.auth.realm, self.url, self.auth.username, self.auth.password)
                self.auth.handler = self.auth.handler(auth_manager)
                auth_manager.add_auth(self.url, self.auth)

            _handlers.append(self.auth.handler)

        if not _handlers:
            return urllib2.urlopen

        _handlers.extend(get_handlers())
        opener = urllib2.build_opener(*_handlers)

        if self.headers:
            # Allow default headers in the opener to be overloaded
            normal_keys = [k.capitalize() for k in self.headers]
            for key, val in opener.addheaders[:]:
                if key not in normal_keys:
                    continue
                # Remove it, we have a value to take its place
                opener.addheaders.remove((key, val))

        return opener.open

    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""

        self.response.status_code = getattr(resp, 'code', None)
        self.response.headers = getattr(resp.info(), 'dict', None)
        self.response.content = resp.read()

        if self.response.headers.get('content-encoding', None) == 'gzip':
            try:
                self.response.content = zlib.decompress(self.response.content, 16+zlib.MAX_WBITS)
            except zlib.error:
                pass

        self.response.url = getattr(resp, 'url', None)


    @staticmethod
    def _build_url(url, data=None):
        """"""Build URLs.""""""

        if urlparse(url).query:
            return '%s&%s' % (url, data)
        else:
            if data:
                return '%s?%s' % (url, data)
            else:
                return url


    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""
        self._checks()
        success = False

        if self.method in ('GET', 'HEAD', 'DELETE'):
            req = _Request(self._build_url(self.url, self._enc_data), method=self.method)
        else:

            if self.files:
                register_openers()

                if self.data:
                    self.files.update(self.data)

                datagen, headers = multipart_encode(self.files)
                req = _Request(self.url, data=datagen, headers=headers, method=self.method)

            else:
                req = _Request(self.url, data=self._enc_data, method=self.method)

        if self.headers:
            req.headers.update(self.headers)

        if not self.sent or anyway:



            try:
                opener = self._get_opener()
                resp = opener(req)

                if self.cookiejar is not None:
                    self.cookiejar.extract_cookies(resp, req)

            except urllib2.HTTPError, why:
                self._build_response(why)
                self.response.error = why
            else:
                self._build_response(resp)
                self.response.ok = True

            self.response.cached = False
        else:
            self.response.cached = True

        self.sent = self.response.ok

        return self.sent


    def read(self, *args):
        return self.response.read()



class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        self.cached = False


    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)


    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error


    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error

    def read(self, *args):
        return self.content



class AuthManager(object):
    """"""Authentication Manager.""""""

    def __new__(cls):
        singleton = cls.__dict__.get('__singleton__')
        if singleton is not None:
            return singleton

        cls.__singleton__ = singleton = object.__new__(cls)

        return singleton


    def __init__(self):
        self.passwd = {}
        self._auth = {}


    def __repr__(self):
        return '<AuthManager [%s]>' % (self.method)


    def add_auth(self, uri, auth):
        """"""Registers AuthObject to AuthManager.""""""

        uri = self.reduce_uri(uri, False)

        # try to make it an AuthObject
        if not isinstance(auth, AuthObject):
            try:
                auth = AuthObject(*auth)
            except TypeError:
                pass

        self._auth[uri] = auth


    def add_password(self, realm, uri, user, passwd):
        """"""Adds password to AuthManager.""""""
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        reduced_uri = tuple([self.reduce_uri(u, False) for u in uri])

        if reduced_uri not in self.passwd:
            self.passwd[reduced_uri] = {}
        self.passwd[reduced_uri] = (user, passwd)


    def find_user_password(self, realm, authuri):
        for uris, authinfo in self.passwd.iteritems():
            reduced_authuri = self.reduce_uri(authuri, False)
            for uri in uris:
                if self.is_suburi(uri, reduced_authuri):
                    return authinfo

        return (None, None)


    def get_auth(self, uri):
        (in_domain, in_path) = self.reduce_uri(uri, False)

        for domain, path, authority in (
            (i[0][0], i[0][1], i[1]) for i in self._auth.iteritems()
        ):
            if in_domain == domain:
                if path in in_path:
                    return authority


    def reduce_uri(self, uri, default_port=True):
        """"""Accept authority or URI and extract only the authority and path.""""""
        # note HTTP URLs do not have a userinfo component
        parts = urllib2.urlparse.urlsplit(uri)
        if parts[1]:
            # URI
            scheme = parts[0]
            authority = parts[1]
            path = parts[2] or '/'
        else:
            # host or host:port
            scheme = None
            authority = uri
            path = '/'
        host, port = urllib2.splitport(authority)
        if default_port and port is None and scheme is not None:
            dport = {""http"": 80,
                     ""https"": 443,
                     }.get(scheme)
            if dport is not None:
                authority = ""%s:%d"" % (host, dport)

        return authority, path


    def is_suburi(self, base, test):
        """"""Check if test is below base in a URI tree

        Both args must be URIs in reduced form.
        """"""
        if base == test:
            return True
        if base[0] != test[0]:
            return False
        common = urllib2.posixpath.commonprefix((base[1], test[1]))
        if len(common) == len(base[1]):
            return True
        return False


    def empty(self):
        self.passwd = {}


    def remove(self, uri, realm=None):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        for default_port in True, False:
            reduced_uri = tuple([self.reduce_uri(u, default_port) for u in uri])
            del self.passwd[reduced_uri][realm]


    def __contains__(self, uri):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        uri = tuple([self.reduce_uri(u, False) for u in uri])

        if uri in self.passwd:
            return True

        return False

auth_manager = AuthManager()



class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.

    :param username: Username to authenticate with.
    :param password: Password for given username.
    :param realm: (optional) the realm this auth applies to
    :param handler: (optional) basic || digest || proxy_basic || proxy_digest
    """"""

    _handlers = {
        'basic': urllib2.HTTPBasicAuthHandler,
        'digest': urllib2.HTTPDigestAuthHandler,
        'proxy_basic': urllib2.ProxyBasicAuthHandler,
        'proxy_digest': urllib2.ProxyDigestAuthHandler
    }

    def __init__(self, username, password, handler='basic', realm=None):
        self.username = username
        self.password = password
        self.realm = realm

        if isinstance(handler, basestring):
            self.handler = self._handlers.get(handler.lower(), urllib2.HTTPBasicAuthHandler)
        else:
            self.handler = handler




def request(method, url, **kwargs):
    """"""Sends a `method` request. Returns :class:`Response` object.

    :param method: method for the new :class:`Request` object.
    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET/HEAD/DELETE Parameters to send with the :class:`Request`.
    :param data: (optional) Bytes/Dictionary of PUT/POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""
    data = kwargs.pop('data', dict()) or kwargs.pop('params', dict())

    r = Request(method=method, url=url, data=data, headers=kwargs.pop('headers', {}),
                cookiejar=kwargs.pop('cookies', None), files=kwargs.pop('files', None),
                auth=kwargs.pop('auth', auth_manager.get_auth(url)),
                timeout=kwargs.pop('timeout', None))
    r.send()

    return r.response


def get(url, params={}, headers={}, cookies=None, auth=None, timeout=None):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('GET', url, params=params, headers=headers, cookies=cookies, auth=auth, timeout=timeout)


def head(url, params={}, headers={}, cookies=None, auth=None, timeout=None):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('HEAD', url, params=params, headers=headers, cookies=cookies, auth=auth, timeout=timeout)


def post(url, data={}, headers={}, files=None, cookies=None, auth=None, timeout=None):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('POST', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth, timeout=timeout)


def put(url, data='', headers={}, files={}, cookies=None, auth=None, timeout=None):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('PUT', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth, timeout=timeout)


def delete(url, params={}, headers={}, cookies=None, auth=None, timeout=None):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of DELETE Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    """"""

    return request('DELETE', url, params=params, headers=headers, cookies=cookies, auth=auth, timeout=timeout)



class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""

class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""

class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","@@ -70,13 +70,16 @@ class Request(object):
         self.headers = headers
         self.files = files
         self.method = method
-        self.data = data
+        
+        self.data = {}
+        for (k, v) in data.items():
+            self.data.update({
+                k.encode('utf-8') if k.__class__ is unicode else k: \
+                v.encode('utf-8') if v.__class__ is unicode else v
+            })
 
         socket.setdefaulttimeout(timeout)
 
-        for (k, v) in self.data.iteritems():
-            self.data[k] = v.encode('utf-8')
-
         # url encode data if it's a dict
         if hasattr(data, 'items'):
             self._enc_data = urllib.urlencode(self.data)
",update request.py,[requests/core.py] update request.py,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.9999999403953552,0.9884502554912095,Minor,Minor,YES
23ee58d6ec47a06358008cb7a4ab4f9556edc285,"Encode both keys and values for incoming unicode data as UTF-8, coincidentally fixing a bug that caused UTF-8 encoded byte strings to be encoded twice and causing an UnicodeDecodeError.",test_requests.py,"#!/usr/bin/env python
# -*- coding: utf-8 -*-

import unittest
import cookielib

import requests


class RequestsTestSuite(unittest.TestCase):
    """"""Requests test cases.""""""

    def setUp(self):
        pass

    def tearDown(self):
        """"""Teardown.""""""
        pass

    def test_invalid_url(self):
        self.assertRaises(ValueError, requests.get, 'hiwpefhipowhefopw')

    def test_HTTP_200_OK_GET(self):
        r = requests.get('http://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTPS_200_OK_GET(self):
        r = requests.get('https://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTP_200_OK_GET_WITH_PARAMS(self):
        heads = {'User-agent': 'Mozilla/5.0'}

        r = requests.get('http://www.google.com/search', params={'q': 'test'}, headers=heads)
        self.assertEqual(r.status_code, 200)

    def test_HTTP_200_OK_GET_WITH_MIXED_PARAMS(self):
        heads = {'User-agent': 'Mozilla/5.0'}

        r = requests.get('http://google.com/search?test=true', params={'q': 'test'}, headers=heads)
        self.assertEqual(r.status_code, 200)

    def test_user_agent_transfers(self):
        """"""Issue XX""""""
        heads = {'User-agent':
                 'Mozilla/5.0 (github.com/kennethreitz/requests)'}

        r = requests.get('http://whatsmyua.com', headers=heads);
        self.assertTrue(heads['User-agent'] in r.content)

    def test_HTTP_200_OK_HEAD(self):
        r = requests.head('http://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTPS_200_OK_HEAD(self):
        r = requests.head('https://google.com')
        self.assertEqual(r.status_code, 200)

    def test_AUTH_HTTPS_200_OK_GET(self):
        auth = ('requeststest', 'requeststest')
        url = 'https://convore.com/api/account/verify.json'
        r = requests.get(url, auth=auth)

        self.assertEqual(r.status_code, 200)

        r = requests.get(url)
        self.assertEqual(r.status_code, 200)

        # reset auto authentication
        requests.auth_manager.empty()

    def test_POSTBIN_GET_POST_FILES(self):
        bin = requests.post('http://www.postbin.org/')
        self.assertEqual(bin.status_code, 200)

        post = requests.post(bin.url, data={'some': 'data'})
        self.assertEqual(post.status_code, 201)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')})
        self.assertEqual(post2.status_code, 201)

    def test_POSTBIN_GET_POST_FILES_WITH_PARAMS(self):
        bin = requests.post('http://www.postbin.org/')

        self.assertEqual(bin.status_code, 200)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')}, data={'some': 'data'})
        self.assertEqual(post2.status_code, 201)


    def test_POSTBIN_GET_POST_FILES_WITH_HEADERS(self):
        bin = requests.post('http://www.postbin.org/')
        self.assertEqual(bin.status_code, 200)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')},
        headers={'User-Agent': 'requests-tests'})

        self.assertEqual(post2.status_code, 201)

    def test_nonzero_evaluation(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(bool(r), False)

        r = requests.get('http://google.com/')
        self.assertEqual(bool(r), True)

    def test_request_ok_set(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(r.ok, False)

    def test_status_raising(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertRaises(requests.HTTPError, r.raise_for_status)

        r = requests.get('http://google.com/')
        self.assertFalse(r.error)
        r.raise_for_status()

    def test_cookie_jar(self):
        """"""
        .. todo:: This really doesn't test to make sure the cookie is working
        """"""
        jar = cookielib.CookieJar()
        self.assertFalse(jar)

        requests.get('http://google.com', cookies=jar)
        self.assertTrue(jar)

    def test_decompress_gzip(self):

        r = requests.get('http://api.stackoverflow.com/1.1/users/495995/top-answer-tags')
        r.content.decode('ascii')

    def test_autoauth(self):

        conv_auth = ('requeststest', 'requeststest')
        requests.auth_manager.add_auth('convore.com', conv_auth)

        r = requests.get('https://convore.com/api/account/verify.json')
        self.assertEquals(r.status_code, 200)

    def test_unicode_get(self):
        requests.get('http://google.com', params={'foo': u'f'})
        requests.get('http://google.com', params={'foo': u'foo'})
        requests.get('http://google.com/', params={'foo': u'foo'})


if __name__ == '__main__':
    unittest.main()
","#!/usr/bin/env python
# -*- coding: utf-8 -*-

import unittest
import cookielib

import requests


class RequestsTestSuite(unittest.TestCase):
    """"""Requests test cases.""""""

    def setUp(self):
        pass

    def tearDown(self):
        """"""Teardown.""""""
        pass

    def test_invalid_url(self):
        self.assertRaises(ValueError, requests.get, 'hiwpefhipowhefopw')

    def test_HTTP_200_OK_GET(self):
        r = requests.get('http://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTPS_200_OK_GET(self):
        r = requests.get('https://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTP_200_OK_GET_WITH_PARAMS(self):
        heads = {'User-agent': 'Mozilla/5.0'}

        r = requests.get('http://www.google.com/search', params={'q': 'test'}, headers=heads)
        self.assertEqual(r.status_code, 200)

    def test_HTTP_200_OK_GET_WITH_MIXED_PARAMS(self):
        heads = {'User-agent': 'Mozilla/5.0'}

        r = requests.get('http://google.com/search?test=true', params={'q': 'test'}, headers=heads)
        self.assertEqual(r.status_code, 200)

    def test_user_agent_transfers(self):
        """"""Issue XX""""""
        heads = {'User-agent':
                 'Mozilla/5.0 (github.com/kennethreitz/requests)'}

        r = requests.get('http://whatsmyua.com', headers=heads);
        self.assertTrue(heads['User-agent'] in r.content)

    def test_HTTP_200_OK_HEAD(self):
        r = requests.head('http://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTPS_200_OK_HEAD(self):
        r = requests.head('https://google.com')
        self.assertEqual(r.status_code, 200)

    def test_AUTH_HTTPS_200_OK_GET(self):
        auth = ('requeststest', 'requeststest')
        url = 'https://convore.com/api/account/verify.json'
        r = requests.get(url, auth=auth)

        self.assertEqual(r.status_code, 200)

        r = requests.get(url)
        self.assertEqual(r.status_code, 200)

        # reset auto authentication
        requests.auth_manager.empty()

    def test_POSTBIN_GET_POST_FILES(self):
        bin = requests.post('http://www.postbin.org/')
        self.assertEqual(bin.status_code, 200)

        post = requests.post(bin.url, data={'some': 'data'})
        self.assertEqual(post.status_code, 201)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')})
        self.assertEqual(post2.status_code, 201)

    def test_POSTBIN_GET_POST_FILES_WITH_PARAMS(self):
        bin = requests.post('http://www.postbin.org/')

        self.assertEqual(bin.status_code, 200)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')}, data={'some': 'data'})
        self.assertEqual(post2.status_code, 201)


    def test_POSTBIN_GET_POST_FILES_WITH_HEADERS(self):
        bin = requests.post('http://www.postbin.org/')
        self.assertEqual(bin.status_code, 200)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')},
        headers={'User-Agent': 'requests-tests'})

        self.assertEqual(post2.status_code, 201)

    def test_nonzero_evaluation(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(bool(r), False)

        r = requests.get('http://google.com/')
        self.assertEqual(bool(r), True)

    def test_request_ok_set(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(r.ok, False)

    def test_status_raising(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertRaises(requests.HTTPError, r.raise_for_status)

        r = requests.get('http://google.com/')
        self.assertFalse(r.error)
        r.raise_for_status()

    def test_cookie_jar(self):
        """"""
        .. todo:: This really doesn't test to make sure the cookie is working
        """"""
        jar = cookielib.CookieJar()
        self.assertFalse(jar)

        requests.get('http://google.com', cookies=jar)
        self.assertTrue(jar)

    def test_decompress_gzip(self):

        r = requests.get('http://api.stackoverflow.com/1.1/users/495995/top-answer-tags')
        r.content.decode('ascii')

    def test_autoauth(self):

        conv_auth = ('requeststest', 'requeststest')
        requests.auth_manager.add_auth('convore.com', conv_auth)

        r = requests.get('https://convore.com/api/account/verify.json')
        self.assertEquals(r.status_code, 200)

    def test_unicode_get(self):
        requests.get('http://google.com', params={'foo': u'f'})
        requests.get('http://google.com', params={u'f': u'f'})
        requests.get('http://google.com', params={'f': 'f'})
        requests.get('http://google.com', params={'foo': u'foo'})
        requests.get('http://google.com/', params={'foo': u'foo'})


if __name__ == '__main__':
    unittest.main()
","@@ -141,6 +141,8 @@ class RequestsTestSuite(unittest.TestCase):
 
     def test_unicode_get(self):
         requests.get('http://google.com', params={'foo': u'f'})
+        requests.get('http://google.com', params={u'f': u'f'})
+        requests.get('http://google.com', params={'f': 'f'})
         requests.get('http://google.com', params={'foo': u'foo'})
         requests.get('http://google.com/', params={'foo': u'foo'})
 
",fix test_unicode_get,[test_requests.py] fix test_unicode_get,58.83018460610766,0.0,149.0,58.346609006394814,0.0,151.0,-0.483575599712843,0.0,2.0,1.0,0.9702712537779238,Minor,Minor,YES
1971bdbe6726af224d92723b3f5f12f26aa4277f,fix for post non-dict data,requests/core.py,"# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import

import requests
import urllib
import urllib2
import socket
import zlib

from urllib2 import HTTPError
from urlparse import urlparse

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers, get_handlers


__title__ = 'requests'
__version__ = '0.3.3'
__build__ = 0x000303
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'

__all__ = [
    'Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete',
    'auth_manager', 'AuthObject','RequestException', 'AuthenticationError',
    'URLRequired', 'InvalidMethod', 'HTTPError'
]


class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""

    def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""

    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')

    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 data=dict(), auth=None, cookiejar=None, timeout=None):

        self.url = url
        self.headers = headers
        self.files = files
        self.method = method

        self.data = {}
        for (k, v) in data.items():
            self.data.update({
                k.encode('utf-8') if isinstance(k, unicode) else k:
                v.encode('utf-8') if isinstance(v, unicode) else v
            })

        socket.setdefaulttimeout(timeout)

        # url encode data if it's a dict
        if hasattr(data, 'items'):
            self._enc_data = urllib.urlencode(self.data)
        else:
            self._enc_data = self.data

        self.response = Response()

        if isinstance(auth, (list, tuple)):
            auth = AuthObject(*auth)
        if not auth:
            auth = auth_manager.get_auth(self.url)
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False


    def __repr__(self):
        return '<Request [%s]>' % (self.method)


    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()

        object.__setattr__(self, name, value)


    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired


    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.cookiejar is not None:
            _handlers.append(urllib2.HTTPCookieProcessor(self.cookiejar))

        if self.auth:
            if not isinstance(self.auth.handler, (urllib2.AbstractBasicAuthHandler, urllib2.AbstractDigestAuthHandler)):
                auth_manager.add_password(self.auth.realm, self.url, self.auth.username, self.auth.password)
                self.auth.handler = self.auth.handler(auth_manager)
                auth_manager.add_auth(self.url, self.auth)

            _handlers.append(self.auth.handler)

        if not _handlers:
            return urllib2.urlopen

        _handlers.extend(get_handlers())
        opener = urllib2.build_opener(*_handlers)

        if self.headers:
            # Allow default headers in the opener to be overloaded
            normal_keys = [k.capitalize() for k in self.headers]
            for key, val in opener.addheaders[:]:
                if key not in normal_keys:
                    continue
                # Remove it, we have a value to take its place
                opener.addheaders.remove((key, val))

        return opener.open

    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""

        self.response.status_code = getattr(resp, 'code', None)
        self.response.headers = getattr(resp.info(), 'dict', None)
        self.response.content = resp.read()

        if self.response.headers.get('content-encoding', None) == 'gzip':
            try:
                self.response.content = zlib.decompress(self.response.content, 16+zlib.MAX_WBITS)
            except zlib.error:
                pass

        self.response.url = getattr(resp, 'url', None)


    @staticmethod
    def _build_url(url, data=None):
        """"""Build URLs.""""""

        if urlparse(url).query:
            return '%s&%s' % (url, data)
        else:
            if data:
                return '%s?%s' % (url, data)
            else:
                return url


    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""
        self._checks()
        success = False

        if self.method in ('GET', 'HEAD', 'DELETE'):
            req = _Request(self._build_url(self.url, self._enc_data), method=self.method)
        else:

            if self.files:
                register_openers()

                if self.data:
                    self.files.update(self.data)

                datagen, headers = multipart_encode(self.files)
                req = _Request(self.url, data=datagen, headers=headers, method=self.method)

            else:
                req = _Request(self.url, data=self._enc_data, method=self.method)

        if self.headers:
            req.headers.update(self.headers)

        if not self.sent or anyway:



            try:
                opener = self._get_opener()
                resp = opener(req)

                if self.cookiejar is not None:
                    self.cookiejar.extract_cookies(resp, req)

            except urllib2.HTTPError, why:
                self._build_response(why)
                self.response.error = why
            else:
                self._build_response(resp)
                self.response.ok = True

            self.response.cached = False
        else:
            self.response.cached = True

        self.sent = self.response.ok

        return self.sent


    def read(self, *args):
        return self.response.read()



class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        self.cached = False


    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)


    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error


    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error

    def read(self, *args):
        return self.content



class AuthManager(object):
    """"""Authentication Manager.""""""

    def __new__(cls):
        singleton = cls.__dict__.get('__singleton__')
        if singleton is not None:
            return singleton

        cls.__singleton__ = singleton = object.__new__(cls)

        return singleton


    def __init__(self):
        self.passwd = {}
        self._auth = {}


    def __repr__(self):
        return '<AuthManager [%s]>' % (self.method)


    def add_auth(self, uri, auth):
        """"""Registers AuthObject to AuthManager.""""""

        uri = self.reduce_uri(uri, False)

        # try to make it an AuthObject
        if not isinstance(auth, AuthObject):
            try:
                auth = AuthObject(*auth)
            except TypeError:
                pass

        self._auth[uri] = auth


    def add_password(self, realm, uri, user, passwd):
        """"""Adds password to AuthManager.""""""
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        reduced_uri = tuple([self.reduce_uri(u, False) for u in uri])

        if reduced_uri not in self.passwd:
            self.passwd[reduced_uri] = {}
        self.passwd[reduced_uri] = (user, passwd)


    def find_user_password(self, realm, authuri):
        for uris, authinfo in self.passwd.iteritems():
            reduced_authuri = self.reduce_uri(authuri, False)
            for uri in uris:
                if self.is_suburi(uri, reduced_authuri):
                    return authinfo

        return (None, None)


    def get_auth(self, uri):
        (in_domain, in_path) = self.reduce_uri(uri, False)

        for domain, path, authority in (
            (i[0][0], i[0][1], i[1]) for i in self._auth.iteritems()
        ):
            if in_domain == domain:
                if path in in_path:
                    return authority


    def reduce_uri(self, uri, default_port=True):
        """"""Accept authority or URI and extract only the authority and path.""""""
        # note HTTP URLs do not have a userinfo component
        parts = urllib2.urlparse.urlsplit(uri)
        if parts[1]:
            # URI
            scheme = parts[0]
            authority = parts[1]
            path = parts[2] or '/'
        else:
            # host or host:port
            scheme = None
            authority = uri
            path = '/'
        host, port = urllib2.splitport(authority)
        if default_port and port is None and scheme is not None:
            dport = {""http"": 80,
                     ""https"": 443,
                     }.get(scheme)
            if dport is not None:
                authority = ""%s:%d"" % (host, dport)

        return authority, path


    def is_suburi(self, base, test):
        """"""Check if test is below base in a URI tree

        Both args must be URIs in reduced form.
        """"""
        if base == test:
            return True
        if base[0] != test[0]:
            return False
        common = urllib2.posixpath.commonprefix((base[1], test[1]))
        if len(common) == len(base[1]):
            return True
        return False


    def empty(self):
        self.passwd = {}


    def remove(self, uri, realm=None):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        for default_port in True, False:
            reduced_uri = tuple([self.reduce_uri(u, default_port) for u in uri])
            del self.passwd[reduced_uri][realm]


    def __contains__(self, uri):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        uri = tuple([self.reduce_uri(u, False) for u in uri])

        if uri in self.passwd:
            return True

        return False

auth_manager = AuthManager()



class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.

    :param username: Username to authenticate with.
    :param password: Password for given username.
    :param realm: (optional) the realm this auth applies to
    :param handler: (optional) basic || digest || proxy_basic || proxy_digest
    """"""

    _handlers = {
        'basic': urllib2.HTTPBasicAuthHandler,
        'digest': urllib2.HTTPDigestAuthHandler,
        'proxy_basic': urllib2.ProxyBasicAuthHandler,
        'proxy_digest': urllib2.ProxyDigestAuthHandler
    }

    def __init__(self, username, password, handler='basic', realm=None):
        self.username = username
        self.password = password
        self.realm = realm

        if isinstance(handler, basestring):
            self.handler = self._handlers.get(handler.lower(), urllib2.HTTPBasicAuthHandler)
        else:
            self.handler = handler




def request(method, url, **kwargs):
    """"""Sends a `method` request. Returns :class:`Response` object.

    :param method: method for the new :class:`Request` object.
    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET/HEAD/DELETE Parameters to send with the :class:`Request`.
    :param data: (optional) Bytes/Dictionary of PUT/POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""
    data = kwargs.pop('data', dict()) or kwargs.pop('params', dict())

    r = Request(method=method, url=url, data=data, headers=kwargs.pop('headers', {}),
                cookiejar=kwargs.pop('cookies', None), files=kwargs.pop('files', None),
                auth=kwargs.pop('auth', auth_manager.get_auth(url)),
                timeout=kwargs.pop('timeout', requests.timeout))
    r.send()

    return r.response


def get(url, params={}, headers={}, cookies=None, auth=None, **kwargs):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""

    return request('GET', url, params=params, headers=headers, cookies=cookies, auth=auth, **kwargs)


def head(url, params={}, headers={}, cookies=None, auth=None, **kwargs):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""

    return request('HEAD', url, params=params, headers=headers, cookies=cookies, auth=auth, **kwargs)


def post(url, data={}, headers={}, files=None, cookies=None, auth=None, **kwargs):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""

    return request('POST', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth, **kwargs)


def put(url, data='', headers={}, files={}, cookies=None, auth=None, **kwargs):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""

    return request('PUT', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth, **kwargs)


def delete(url, params={}, headers={}, cookies=None, auth=None, **kwargs):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of DELETE Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""

    return request('DELETE', url, params=params, headers=headers, cookies=cookies, auth=auth, **kwargs)



class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""

class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""

class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import

import requests
import urllib
import urllib2
import socket
import zlib

from urllib2 import HTTPError
from urlparse import urlparse

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers, get_handlers


__title__ = 'requests'
__version__ = '0.3.3'
__build__ = 0x000303
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'

__all__ = [
    'Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete',
    'auth_manager', 'AuthObject','RequestException', 'AuthenticationError',
    'URLRequired', 'InvalidMethod', 'HTTPError'
]


class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""

    def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""

    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')

    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 data=dict(), auth=None, cookiejar=None, timeout=None):

        self.url = url
        self.headers = headers
        self.files = files
        self.method = method
        self.data = {}

        socket.setdefaulttimeout(timeout)

        if hasattr(data, 'items'):
            for (k, v) in data.items():
                self.data.update({
                    k.encode('utf-8') if isinstance(k, unicode) else k:
                    v.encode('utf-8') if isinstance(v, unicode) else v
                })
            # url encode data if it's a dict
            self._enc_data = urllib.urlencode(self.data)
        else:
            self._enc_data = self.data

        self.response = Response()

        if isinstance(auth, (list, tuple)):
            auth = AuthObject(*auth)
        if not auth:
            auth = auth_manager.get_auth(self.url)
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False


    def __repr__(self):
        return '<Request [%s]>' % (self.method)


    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()

        object.__setattr__(self, name, value)


    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired


    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.cookiejar is not None:
            _handlers.append(urllib2.HTTPCookieProcessor(self.cookiejar))

        if self.auth:
            if not isinstance(self.auth.handler, (urllib2.AbstractBasicAuthHandler, urllib2.AbstractDigestAuthHandler)):
                auth_manager.add_password(self.auth.realm, self.url, self.auth.username, self.auth.password)
                self.auth.handler = self.auth.handler(auth_manager)
                auth_manager.add_auth(self.url, self.auth)

            _handlers.append(self.auth.handler)

        if not _handlers:
            return urllib2.urlopen

        _handlers.extend(get_handlers())
        opener = urllib2.build_opener(*_handlers)

        if self.headers:
            # Allow default headers in the opener to be overloaded
            normal_keys = [k.capitalize() for k in self.headers]
            for key, val in opener.addheaders[:]:
                if key not in normal_keys:
                    continue
                # Remove it, we have a value to take its place
                opener.addheaders.remove((key, val))

        return opener.open

    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""

        self.response.status_code = getattr(resp, 'code', None)
        self.response.headers = getattr(resp.info(), 'dict', None)
        self.response.content = resp.read()

        if self.response.headers.get('content-encoding', None) == 'gzip':
            try:
                self.response.content = zlib.decompress(self.response.content, 16+zlib.MAX_WBITS)
            except zlib.error:
                pass

        self.response.url = getattr(resp, 'url', None)


    @staticmethod
    def _build_url(url, data=None):
        """"""Build URLs.""""""

        if urlparse(url).query:
            return '%s&%s' % (url, data)
        else:
            if data:
                return '%s?%s' % (url, data)
            else:
                return url


    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""
        self._checks()
        success = False

        if self.method in ('GET', 'HEAD', 'DELETE'):
            req = _Request(self._build_url(self.url, self._enc_data), method=self.method)
        else:

            if self.files:
                register_openers()

                if self.data:
                    self.files.update(self.data)

                datagen, headers = multipart_encode(self.files)
                req = _Request(self.url, data=datagen, headers=headers, method=self.method)

            else:
                req = _Request(self.url, data=self._enc_data, method=self.method)

        if self.headers:
            req.headers.update(self.headers)

        if not self.sent or anyway:



            try:
                opener = self._get_opener()
                resp = opener(req)

                if self.cookiejar is not None:
                    self.cookiejar.extract_cookies(resp, req)

            except urllib2.HTTPError, why:
                self._build_response(why)
                self.response.error = why
            else:
                self._build_response(resp)
                self.response.ok = True

            self.response.cached = False
        else:
            self.response.cached = True

        self.sent = self.response.ok

        return self.sent


    def read(self, *args):
        return self.response.read()



class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        self.cached = False


    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)


    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error


    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error

    def read(self, *args):
        return self.content



class AuthManager(object):
    """"""Authentication Manager.""""""

    def __new__(cls):
        singleton = cls.__dict__.get('__singleton__')
        if singleton is not None:
            return singleton

        cls.__singleton__ = singleton = object.__new__(cls)

        return singleton


    def __init__(self):
        self.passwd = {}
        self._auth = {}


    def __repr__(self):
        return '<AuthManager [%s]>' % (self.method)


    def add_auth(self, uri, auth):
        """"""Registers AuthObject to AuthManager.""""""

        uri = self.reduce_uri(uri, False)

        # try to make it an AuthObject
        if not isinstance(auth, AuthObject):
            try:
                auth = AuthObject(*auth)
            except TypeError:
                pass

        self._auth[uri] = auth


    def add_password(self, realm, uri, user, passwd):
        """"""Adds password to AuthManager.""""""
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        reduced_uri = tuple([self.reduce_uri(u, False) for u in uri])

        if reduced_uri not in self.passwd:
            self.passwd[reduced_uri] = {}
        self.passwd[reduced_uri] = (user, passwd)


    def find_user_password(self, realm, authuri):
        for uris, authinfo in self.passwd.iteritems():
            reduced_authuri = self.reduce_uri(authuri, False)
            for uri in uris:
                if self.is_suburi(uri, reduced_authuri):
                    return authinfo

        return (None, None)


    def get_auth(self, uri):
        (in_domain, in_path) = self.reduce_uri(uri, False)

        for domain, path, authority in (
            (i[0][0], i[0][1], i[1]) for i in self._auth.iteritems()
        ):
            if in_domain == domain:
                if path in in_path:
                    return authority


    def reduce_uri(self, uri, default_port=True):
        """"""Accept authority or URI and extract only the authority and path.""""""
        # note HTTP URLs do not have a userinfo component
        parts = urllib2.urlparse.urlsplit(uri)
        if parts[1]:
            # URI
            scheme = parts[0]
            authority = parts[1]
            path = parts[2] or '/'
        else:
            # host or host:port
            scheme = None
            authority = uri
            path = '/'
        host, port = urllib2.splitport(authority)
        if default_port and port is None and scheme is not None:
            dport = {""http"": 80,
                     ""https"": 443,
                     }.get(scheme)
            if dport is not None:
                authority = ""%s:%d"" % (host, dport)

        return authority, path


    def is_suburi(self, base, test):
        """"""Check if test is below base in a URI tree

        Both args must be URIs in reduced form.
        """"""
        if base == test:
            return True
        if base[0] != test[0]:
            return False
        common = urllib2.posixpath.commonprefix((base[1], test[1]))
        if len(common) == len(base[1]):
            return True
        return False


    def empty(self):
        self.passwd = {}


    def remove(self, uri, realm=None):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        for default_port in True, False:
            reduced_uri = tuple([self.reduce_uri(u, default_port) for u in uri])
            del self.passwd[reduced_uri][realm]


    def __contains__(self, uri):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        uri = tuple([self.reduce_uri(u, False) for u in uri])

        if uri in self.passwd:
            return True

        return False

auth_manager = AuthManager()



class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.

    :param username: Username to authenticate with.
    :param password: Password for given username.
    :param realm: (optional) the realm this auth applies to
    :param handler: (optional) basic || digest || proxy_basic || proxy_digest
    """"""

    _handlers = {
        'basic': urllib2.HTTPBasicAuthHandler,
        'digest': urllib2.HTTPDigestAuthHandler,
        'proxy_basic': urllib2.ProxyBasicAuthHandler,
        'proxy_digest': urllib2.ProxyDigestAuthHandler
    }

    def __init__(self, username, password, handler='basic', realm=None):
        self.username = username
        self.password = password
        self.realm = realm

        if isinstance(handler, basestring):
            self.handler = self._handlers.get(handler.lower(), urllib2.HTTPBasicAuthHandler)
        else:
            self.handler = handler




def request(method, url, **kwargs):
    """"""Sends a `method` request. Returns :class:`Response` object.

    :param method: method for the new :class:`Request` object.
    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET/HEAD/DELETE Parameters to send with the :class:`Request`.
    :param data: (optional) Bytes/Dictionary of PUT/POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""
    data = kwargs.pop('data', dict()) or kwargs.pop('params', dict())

    r = Request(method=method, url=url, data=data, headers=kwargs.pop('headers', {}),
                cookiejar=kwargs.pop('cookies', None), files=kwargs.pop('files', None),
                auth=kwargs.pop('auth', auth_manager.get_auth(url)),
                timeout=kwargs.pop('timeout', requests.timeout))
    r.send()

    return r.response


def get(url, params={}, headers={}, cookies=None, auth=None, **kwargs):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""

    return request('GET', url, params=params, headers=headers, cookies=cookies, auth=auth, **kwargs)


def head(url, params={}, headers={}, cookies=None, auth=None, **kwargs):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""

    return request('HEAD', url, params=params, headers=headers, cookies=cookies, auth=auth, **kwargs)


def post(url, data={}, headers={}, files=None, cookies=None, auth=None, **kwargs):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""

    return request('POST', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth, **kwargs)


def put(url, data='', headers={}, files={}, cookies=None, auth=None, **kwargs):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""

    return request('PUT', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth, **kwargs)


def delete(url, params={}, headers={}, cookies=None, auth=None, **kwargs):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of DELETE Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""

    return request('DELETE', url, params=params, headers=headers, cookies=cookies, auth=auth, **kwargs)



class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""

class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""

class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","@@ -69,18 +69,17 @@ class Request(object):
         self.headers = headers
         self.files = files
         self.method = method
-
         self.data = {}
-        for (k, v) in data.items():
-            self.data.update({
-                k.encode('utf-8') if isinstance(k, unicode) else k:
-                v.encode('utf-8') if isinstance(v, unicode) else v
-            })
 
         socket.setdefaulttimeout(timeout)
 
-        # url encode data if it's a dict
         if hasattr(data, 'items'):
+            for (k, v) in data.items():
+                self.data.update({
+                    k.encode('utf-8') if isinstance(k, unicode) else k:
+                    v.encode('utf-8') if isinstance(v, unicode) else v
+                })
+            # url encode data if it's a dict
             self._enc_data = urllib.urlencode(self.data)
         else:
             self._enc_data = self.data
",add missing timeout in request class,[requests/core.py] add missing timeout in request class,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.998408234916537,Minor,Minor,YES
1971bdbe6726af224d92723b3f5f12f26aa4277f,fix for post non-dict data,test_requests.py,"#!/usr/bin/env python
# -*- coding: utf-8 -*-

import unittest
import cookielib

import requests


class RequestsTestSuite(unittest.TestCase):
    """"""Requests test cases.""""""

    def setUp(self):
        pass

    def tearDown(self):
        """"""Teardown.""""""
        pass

    def test_invalid_url(self):
        self.assertRaises(ValueError, requests.get, 'hiwpefhipowhefopw')

    def test_HTTP_200_OK_GET(self):
        r = requests.get('http://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTPS_200_OK_GET(self):
        r = requests.get('https://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTP_200_OK_GET_WITH_PARAMS(self):
        heads = {'User-agent': 'Mozilla/5.0'}

        r = requests.get('http://www.google.com/search', params={'q': 'test'}, headers=heads)
        self.assertEqual(r.status_code, 200)

    def test_HTTP_200_OK_GET_WITH_MIXED_PARAMS(self):
        heads = {'User-agent': 'Mozilla/5.0'}

        r = requests.get('http://google.com/search?test=true', params={'q': 'test'}, headers=heads)
        self.assertEqual(r.status_code, 200)

    def test_user_agent_transfers(self):
        """"""Issue XX""""""
        heads = {'User-agent':
                 'Mozilla/5.0 (github.com/kennethreitz/requests)'}

        r = requests.get('http://whatsmyua.com', headers=heads);
        self.assertTrue(heads['User-agent'] in r.content)

    def test_HTTP_200_OK_HEAD(self):
        r = requests.head('http://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTPS_200_OK_HEAD(self):
        r = requests.head('https://google.com')
        self.assertEqual(r.status_code, 200)

    def test_AUTH_HTTPS_200_OK_GET(self):
        auth = ('requeststest', 'requeststest')
        url = 'https://convore.com/api/account/verify.json'
        r = requests.get(url, auth=auth)

        self.assertEqual(r.status_code, 200)

        r = requests.get(url)
        self.assertEqual(r.status_code, 200)

        # reset auto authentication
        requests.auth_manager.empty()

    def test_POSTBIN_GET_POST_FILES(self):
        bin = requests.post('http://www.postbin.org/')
        self.assertEqual(bin.status_code, 200)

        post = requests.post(bin.url, data={'some': 'data'})
        self.assertEqual(post.status_code, 201)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')})
        self.assertEqual(post2.status_code, 201)

    def test_POSTBIN_GET_POST_FILES_WITH_PARAMS(self):
        bin = requests.post('http://www.postbin.org/')

        self.assertEqual(bin.status_code, 200)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')}, data={'some': 'data'})
        self.assertEqual(post2.status_code, 201)


    def test_POSTBIN_GET_POST_FILES_WITH_HEADERS(self):
        bin = requests.post('http://www.postbin.org/')
        self.assertEqual(bin.status_code, 200)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')},
        headers={'User-Agent': 'requests-tests'})

        self.assertEqual(post2.status_code, 201)

    def test_nonzero_evaluation(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(bool(r), False)

        r = requests.get('http://google.com/')
        self.assertEqual(bool(r), True)

    def test_request_ok_set(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(r.ok, False)

    def test_status_raising(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertRaises(requests.HTTPError, r.raise_for_status)

        r = requests.get('http://google.com/')
        self.assertFalse(r.error)
        r.raise_for_status()

    def test_cookie_jar(self):
        """"""
        .. todo:: This really doesn't test to make sure the cookie is working
        """"""
        jar = cookielib.CookieJar()
        self.assertFalse(jar)

        requests.get('http://google.com', cookies=jar)
        self.assertTrue(jar)

    def test_decompress_gzip(self):

        r = requests.get('http://api.stackoverflow.com/1.1/users/495995/top-answer-tags')
        r.content.decode('ascii')

    def test_autoauth(self):

        conv_auth = ('requeststest', 'requeststest')
        requests.auth_manager.add_auth('convore.com', conv_auth)

        r = requests.get('https://convore.com/api/account/verify.json')
        self.assertEquals(r.status_code, 200)

    def test_unicode_get(self):
        requests.get('http://google.com', params={'foo': u'f'})
        requests.get('http://google.com', params={u'f': u'f'})
        requests.get('http://google.com', params={'f': 'f'})
        requests.get('http://google.com', params={'foo': u'foo'})
        requests.get('http://google.com/', params={'foo': u'foo'})


if __name__ == '__main__':
    unittest.main()
","#!/usr/bin/env python
# -*- coding: utf-8 -*-

import unittest
import cookielib

import requests


class RequestsTestSuite(unittest.TestCase):
    """"""Requests test cases.""""""

    def setUp(self):
        pass

    def tearDown(self):
        """"""Teardown.""""""
        pass

    def test_invalid_url(self):
        self.assertRaises(ValueError, requests.get, 'hiwpefhipowhefopw')

    def test_HTTP_200_OK_GET(self):
        r = requests.get('http://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTPS_200_OK_GET(self):
        r = requests.get('https://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTP_200_OK_GET_WITH_PARAMS(self):
        heads = {'User-agent': 'Mozilla/5.0'}

        r = requests.get('http://www.google.com/search', params={'q': 'test'}, headers=heads)
        self.assertEqual(r.status_code, 200)

    def test_HTTP_200_OK_GET_WITH_MIXED_PARAMS(self):
        heads = {'User-agent': 'Mozilla/5.0'}

        r = requests.get('http://google.com/search?test=true', params={'q': 'test'}, headers=heads)
        self.assertEqual(r.status_code, 200)

    def test_user_agent_transfers(self):
        """"""Issue XX""""""
        heads = {'User-agent':
                 'Mozilla/5.0 (github.com/kennethreitz/requests)'}

        r = requests.get('http://whatsmyua.com', headers=heads);
        self.assertTrue(heads['User-agent'] in r.content)

    def test_HTTP_200_OK_HEAD(self):
        r = requests.head('http://google.com')
        self.assertEqual(r.status_code, 200)

    def test_HTTPS_200_OK_HEAD(self):
        r = requests.head('https://google.com')
        self.assertEqual(r.status_code, 200)

    def test_AUTH_HTTPS_200_OK_GET(self):
        auth = ('requeststest', 'requeststest')
        url = 'https://convore.com/api/account/verify.json'
        r = requests.get(url, auth=auth)

        self.assertEqual(r.status_code, 200)

        r = requests.get(url)
        self.assertEqual(r.status_code, 200)

        # reset auto authentication
        requests.auth_manager.empty()

    def test_POSTBIN_GET_POST_FILES(self):
        bin = requests.post('http://www.postbin.org/')
        self.assertEqual(bin.status_code, 200)

        post = requests.post(bin.url, data={'some': 'data'})
        self.assertEqual(post.status_code, 201)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')})
        self.assertEqual(post2.status_code, 201)

        post3 = requests.post(bin.url, data='[{""some"": ""json""}]')
        self.assertEqual(post.status_code, 201)

    def test_POSTBIN_GET_POST_FILES_WITH_PARAMS(self):
        bin = requests.post('http://www.postbin.org/')

        self.assertEqual(bin.status_code, 200)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')}, data={'some': 'data'})
        self.assertEqual(post2.status_code, 201)


    def test_POSTBIN_GET_POST_FILES_WITH_HEADERS(self):
        bin = requests.post('http://www.postbin.org/')
        self.assertEqual(bin.status_code, 200)

        post2 = requests.post(bin.url, files={'some': open('test_requests.py')},
        headers={'User-Agent': 'requests-tests'})

        self.assertEqual(post2.status_code, 201)

    def test_nonzero_evaluation(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(bool(r), False)

        r = requests.get('http://google.com/')
        self.assertEqual(bool(r), True)

    def test_request_ok_set(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertEqual(r.ok, False)

    def test_status_raising(self):
        r = requests.get('http://google.com/some-404-url')
        self.assertRaises(requests.HTTPError, r.raise_for_status)

        r = requests.get('http://google.com/')
        self.assertFalse(r.error)
        r.raise_for_status()

    def test_cookie_jar(self):
        """"""
        .. todo:: This really doesn't test to make sure the cookie is working
        """"""
        jar = cookielib.CookieJar()
        self.assertFalse(jar)

        requests.get('http://google.com', cookies=jar)
        self.assertTrue(jar)

    def test_decompress_gzip(self):

        r = requests.get('http://api.stackoverflow.com/1.1/users/495995/top-answer-tags')
        r.content.decode('ascii')

    def test_autoauth(self):

        conv_auth = ('requeststest', 'requeststest')
        requests.auth_manager.add_auth('convore.com', conv_auth)

        r = requests.get('https://convore.com/api/account/verify.json')
        self.assertEquals(r.status_code, 200)

    def test_unicode_get(self):
        requests.get('http://google.com', params={'foo': u'f'})
        requests.get('http://google.com', params={u'f': u'f'})
        requests.get('http://google.com', params={'f': 'f'})
        requests.get('http://google.com', params={'foo': u'foo'})
        requests.get('http://google.com/', params={'foo': u'foo'})


if __name__ == '__main__':
    unittest.main()
","@@ -79,6 +79,9 @@ class RequestsTestSuite(unittest.TestCase):
         post2 = requests.post(bin.url, files={'some': open('test_requests.py')})
         self.assertEqual(post2.status_code, 201)
 
+        post3 = requests.post(bin.url, data='[{""some"": ""json""}]')
+        self.assertEqual(post.status_code, 201)
+
     def test_POSTBIN_GET_POST_FILES_WITH_PARAMS(self):
         bin = requests.post('http://www.postbin.org/')
 
",add test for postbin with params,[test_requests.py] add test for postbin with params,58.346609006394814,0.0,151.0,58.04375187582671,0.0,154.0,-0.3028571305681069,0.0,3.0,1.0,0.9725334115166888,Minor,Minor,YES
1421ffa32ab4709c9a7634493803bd55a3c6615f,HTTP Basic recursion. Fixes #31,requests/core.py,"# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import

import requests
import urllib
import urllib2
import socket
import zlib

from urllib2 import HTTPError
from urlparse import urlparse

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers, get_handlers


__title__ = 'requests'
__version__ = '0.3.3'
__build__ = 0x000303
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'

__all__ = [
    'Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete',
    'auth_manager', 'AuthObject','RequestException', 'AuthenticationError',
    'URLRequired', 'InvalidMethod', 'HTTPError'
]


class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""

    def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""

    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')

    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 data=dict(), auth=None, cookiejar=None, timeout=None):

        socket.setdefaulttimeout(timeout)

        self.url = url
        self.headers = headers
        self.files = files
        self.method = method
        self.data = {}

        # self.data = {}
        if hasattr(data, 'items'):
            for (k, v) in data.items():
                self.data.update({
                    k.encode('utf-8') if isinstance(k, unicode) else k:
                    v.encode('utf-8') if isinstance(v, unicode) else v
                })

        # url encode data if it's a dict
        if hasattr(data, 'items'):
            self._enc_data = urllib.urlencode(self.data)
        else:
            self._enc_data = data


        self.response = Response()

        if isinstance(auth, (list, tuple)):
            auth = AuthObject(*auth)
        if not auth:
            auth = auth_manager.get_auth(self.url)
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False


    def __repr__(self):
        return '<Request [%s]>' % (self.method)


    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()

        object.__setattr__(self, name, value)


    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired


    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.cookiejar is not None:
            _handlers.append(urllib2.HTTPCookieProcessor(self.cookiejar))

        if self.auth:
            if not isinstance(self.auth.handler, (urllib2.AbstractBasicAuthHandler, urllib2.AbstractDigestAuthHandler)):
                auth_manager.add_password(self.auth.realm, self.url, self.auth.username, self.auth.password)
                self.auth.handler = self.auth.handler(auth_manager)
                auth_manager.add_auth(self.url, self.auth)

            _handlers.append(self.auth.handler)

        if not _handlers:
            return urllib2.urlopen

        _handlers.extend(get_handlers())
        opener = urllib2.build_opener(*_handlers)

        if self.headers:
            # Allow default headers in the opener to be overloaded
            normal_keys = [k.capitalize() for k in self.headers]
            for key, val in opener.addheaders[:]:
                if key not in normal_keys:
                    continue
                # Remove it, we have a value to take its place
                opener.addheaders.remove((key, val))

        return opener.open

    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""

        self.response.status_code = getattr(resp, 'code', None)
        self.response.headers = getattr(resp.info(), 'dict', None)
        self.response.content = resp.read()

        if self.response.headers.get('content-encoding', None) == 'gzip':
            try:
                self.response.content = zlib.decompress(self.response.content, 16+zlib.MAX_WBITS)
            except zlib.error:
                pass

        self.response.url = getattr(resp, 'url', None)


    @staticmethod
    def _build_url(url, data=None):
        """"""Build URLs.""""""

        if urlparse(url).query:
            return '%s&%s' % (url, data)
        else:
            if data:
                return '%s?%s' % (url, data)
            else:
                return url


    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""
        self._checks()
        success = False

        if self.method in ('GET', 'HEAD', 'DELETE'):
            req = _Request(self._build_url(self.url, self._enc_data), method=self.method)
        else:

            if self.files:
                register_openers()

                if self.data:
                    self.files.update(self.data)

                datagen, headers = multipart_encode(self.files)
                req = _Request(self.url, data=datagen, headers=headers, method=self.method)

            else:
                req = _Request(self.url, data=self._enc_data, method=self.method)

        if self.headers:
            req.headers.update(self.headers)

        if not self.sent or anyway:

            try:
                opener = self._get_opener()
                resp = opener(req)

                if self.cookiejar is not None:
                    self.cookiejar.extract_cookies(resp, req)

            except urllib2.HTTPError, why:
                self._build_response(why)
                self.response.error = why
            else:
                self._build_response(resp)
                self.response.ok = True

            self.response.cached = False
        else:
            self.response.cached = True

        self.sent = self.response.ok

        return self.sent


    def read(self, *args):
        return self.response.read()



class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        self.cached = False


    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)


    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error


    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error

    def read(self, *args):
        return self.content



class AuthManager(object):
    """"""Authentication Manager.""""""

    def __new__(cls):
        singleton = cls.__dict__.get('__singleton__')
        if singleton is not None:
            return singleton

        cls.__singleton__ = singleton = object.__new__(cls)

        return singleton


    def __init__(self):
        self.passwd = {}
        self._auth = {}


    def __repr__(self):
        return '<AuthManager [%s]>' % (self.method)


    def add_auth(self, uri, auth):
        """"""Registers AuthObject to AuthManager.""""""

        uri = self.reduce_uri(uri, False)

        # try to make it an AuthObject
        if not isinstance(auth, AuthObject):
            try:
                auth = AuthObject(*auth)
            except TypeError:
                pass

        self._auth[uri] = auth


    def add_password(self, realm, uri, user, passwd):
        """"""Adds password to AuthManager.""""""
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        reduced_uri = tuple([self.reduce_uri(u, False) for u in uri])

        if reduced_uri not in self.passwd:
            self.passwd[reduced_uri] = {}
        self.passwd[reduced_uri] = (user, passwd)


    def find_user_password(self, realm, authuri):
        for uris, authinfo in self.passwd.iteritems():
            reduced_authuri = self.reduce_uri(authuri, False)
            for uri in uris:
                if self.is_suburi(uri, reduced_authuri):
                    return authinfo

        return (None, None)


    def get_auth(self, uri):
        (in_domain, in_path) = self.reduce_uri(uri, False)

        for domain, path, authority in (
            (i[0][0], i[0][1], i[1]) for i in self._auth.iteritems()
        ):
            if in_domain == domain:
                if path in in_path:
                    return authority


    def reduce_uri(self, uri, default_port=True):
        """"""Accept authority or URI and extract only the authority and path.""""""
        # note HTTP URLs do not have a userinfo component
        parts = urllib2.urlparse.urlsplit(uri)
        if parts[1]:
            # URI
            scheme = parts[0]
            authority = parts[1]
            path = parts[2] or '/'
        else:
            # host or host:port
            scheme = None
            authority = uri
            path = '/'
        host, port = urllib2.splitport(authority)
        if default_port and port is None and scheme is not None:
            dport = {""http"": 80,
                     ""https"": 443,
                     }.get(scheme)
            if dport is not None:
                authority = ""%s:%d"" % (host, dport)

        return authority, path


    def is_suburi(self, base, test):
        """"""Check if test is below base in a URI tree

        Both args must be URIs in reduced form.
        """"""
        if base == test:
            return True
        if base[0] != test[0]:
            return False
        common = urllib2.posixpath.commonprefix((base[1], test[1]))
        if len(common) == len(base[1]):
            return True
        return False


    def empty(self):
        self.passwd = {}


    def remove(self, uri, realm=None):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        for default_port in True, False:
            reduced_uri = tuple([self.reduce_uri(u, default_port) for u in uri])
            del self.passwd[reduced_uri][realm]


    def __contains__(self, uri):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        uri = tuple([self.reduce_uri(u, False) for u in uri])

        if uri in self.passwd:
            return True

        return False

auth_manager = AuthManager()



class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.

    :param username: Username to authenticate with.
    :param password: Password for given username.
    :param realm: (optional) the realm this auth applies to
    :param handler: (optional) basic || digest || proxy_basic || proxy_digest
    """"""

    _handlers = {
        'basic': urllib2.HTTPBasicAuthHandler,
        'digest': urllib2.HTTPDigestAuthHandler,
        'proxy_basic': urllib2.ProxyBasicAuthHandler,
        'proxy_digest': urllib2.ProxyDigestAuthHandler
    }

    def __init__(self, username, password, handler='basic', realm=None):
        self.username = username
        self.password = password
        self.realm = realm

        if isinstance(handler, basestring):
            self.handler = self._handlers.get(handler.lower(), urllib2.HTTPBasicAuthHandler)
        else:
            self.handler = handler




def request(method, url, **kwargs):
    """"""Sends a `method` request. Returns :class:`Response` object.

    :param method: method for the new :class:`Request` object.
    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET/HEAD/DELETE Parameters to send with the :class:`Request`.
    :param data: (optional) Bytes/Dictionary of PUT/POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""
    data = kwargs.pop('data', dict()) or kwargs.pop('params', dict())

    r = Request(method=method, url=url, data=data, headers=kwargs.pop('headers', {}),
                cookiejar=kwargs.pop('cookies', None), files=kwargs.pop('files', None),
                auth=kwargs.pop('auth', auth_manager.get_auth(url)),
                timeout=kwargs.pop('timeout', requests.timeout))
    r.send()

    return r.response


def get(url, params={}, headers={}, cookies=None, auth=None, **kwargs):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""

    return request('GET', url, params=params, headers=headers, cookies=cookies, auth=auth, **kwargs)


def head(url, params={}, headers={}, cookies=None, auth=None, **kwargs):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""

    return request('HEAD', url, params=params, headers=headers, cookies=cookies, auth=auth, **kwargs)


def post(url, data={}, headers={}, files=None, cookies=None, auth=None, **kwargs):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""

    return request('POST', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth, **kwargs)


def put(url, data='', headers={}, files={}, cookies=None, auth=None, **kwargs):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""

    return request('PUT', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth, **kwargs)


def delete(url, params={}, headers={}, cookies=None, auth=None, **kwargs):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of DELETE Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""

    return request('DELETE', url, params=params, headers=headers, cookies=cookies, auth=auth, **kwargs)



class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""

class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""

class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","# -*- coding: utf-8 -*-

""""""
    requests.core
    ~~~~~~~~~~~~~

    This module implements the main Requests system.

    :copyright: (c) 2011 by Kenneth Reitz.
    :license: ISC, see LICENSE for more details.
""""""

from __future__ import absolute_import

import requests
import urllib
import urllib2
import socket
import zlib

from urllib2 import HTTPError
from urlparse import urlparse

from .packages.poster.encode import multipart_encode
from .packages.poster.streaminghttp import register_openers, get_handlers


__title__ = 'requests'
__version__ = '0.3.3'
__build__ = 0x000303
__author__ = 'Kenneth Reitz'
__license__ = 'ISC'
__copyright__ = 'Copyright 2011 Kenneth Reitz'

__all__ = [
    'Request', 'Response', 'request', 'get', 'head', 'post', 'put', 'delete',
    'auth_manager', 'AuthObject','RequestException', 'AuthenticationError',
    'URLRequired', 'InvalidMethod', 'HTTPError'
]


class _Request(urllib2.Request):
    """"""Hidden wrapper around the urllib2.Request object. Allows for manual
    setting of HTTP methods.
    """"""

    def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None):
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)
        self.method = method

    def get_method(self):
        if self.method:
            return self.method

        return urllib2.Request.get_method(self)


class _HTTPBasicAuthHandler(urllib2.HTTPBasicAuthHandler):
    # from mercurial

    def __init__(self, *args, **kwargs):
        urllib2.HTTPBasicAuthHandler.__init__(self, *args, **kwargs)
        self.retried_req = None

    def reset_retry_count(self):
        # Python 2.6.5 will call this on 401 or 407 errors and thus loop
        # forever. We disable reset_retry_count completely and reset in
        # http_error_auth_reqed instead.
        pass

    def http_error_auth_reqed(self, auth_header, host, req, headers):
        # Reset the retry counter once for each request.
        if req is not self.retried_req:
            self.retried_req = req
            self.retried = 0
        return urllib2.HTTPBasicAuthHandler.http_error_auth_reqed(
                        self, auth_header, host, req, headers)


class Request(object):
    """"""The :class:`Request` object. It carries out all functionality of
    Requests. Recommended interface is with the Requests functions.
    """"""

    _METHODS = ('GET', 'HEAD', 'PUT', 'POST', 'DELETE')

    def __init__(self, url=None, headers=dict(), files=None, method=None,
                 data=dict(), auth=None, cookiejar=None, timeout=None):

        socket.setdefaulttimeout(timeout)

        self.url = url
        self.headers = headers
        self.files = files
        self.method = method
        self.data = {}

        # self.data = {}
        if hasattr(data, 'items'):
            for (k, v) in data.items():
                self.data.update({
                    k.encode('utf-8') if isinstance(k, unicode) else k:
                    v.encode('utf-8') if isinstance(v, unicode) else v
                })

        # url encode data if it's a dict
        if hasattr(data, 'items'):
            self._enc_data = urllib.urlencode(self.data)
        else:
            self._enc_data = data


        self.response = Response()

        if isinstance(auth, (list, tuple)):
            auth = AuthObject(*auth)
        if not auth:
            auth = auth_manager.get_auth(self.url)
        self.auth = auth
        self.cookiejar = cookiejar
        self.sent = False


    def __repr__(self):
        return '<Request [%s]>' % (self.method)


    def __setattr__(self, name, value):
        if (name == 'method') and (value):
            if not value in self._METHODS:
                raise InvalidMethod()

        object.__setattr__(self, name, value)


    def _checks(self):
        """"""Deterministic checks for consistency.""""""

        if not self.url:
            raise URLRequired


    def _get_opener(self):
        """"""Creates appropriate opener object for urllib2.""""""

        _handlers = []

        if self.cookiejar is not None:
            _handlers.append(urllib2.HTTPCookieProcessor(self.cookiejar))

        if self.auth:
            if not isinstance(self.auth.handler, (urllib2.AbstractBasicAuthHandler, urllib2.AbstractDigestAuthHandler)):
                auth_manager.add_password(self.auth.realm, self.url, self.auth.username, self.auth.password)
                self.auth.handler = self.auth.handler(auth_manager)
                auth_manager.add_auth(self.url, self.auth)

            _handlers.append(self.auth.handler)

        if not _handlers:
            return urllib2.urlopen

        _handlers.extend(get_handlers())
        opener = urllib2.build_opener(*_handlers)

        if self.headers:
            # Allow default headers in the opener to be overloaded
            normal_keys = [k.capitalize() for k in self.headers]
            for key, val in opener.addheaders[:]:
                if key not in normal_keys:
                    continue
                # Remove it, we have a value to take its place
                opener.addheaders.remove((key, val))

        return opener.open

    def _build_response(self, resp):
        """"""Build internal Response object from given response.""""""
        if isinstance(resp, HTTPError):
            # print resp.__dict__
            pass

        self.response.status_code = getattr(resp, 'code', None)

        try:
            self.response.headers = getattr(resp.info(), 'dict', None)
            self.response.content = resp.read()
        except AttributeError, why:
            pass

        if self.response.headers.get('content-encoding', None) == 'gzip':
            try:
                self.response.content = zlib.decompress(self.response.content, 16+zlib.MAX_WBITS)
            except zlib.error:
                pass

        self.response.url = getattr(resp, 'url', None)


    @staticmethod
    def _build_url(url, data=None):
        """"""Build URLs.""""""

        if urlparse(url).query:
            return '%s&%s' % (url, data)
        else:
            if data:
                return '%s?%s' % (url, data)
            else:
                return url


    def send(self, anyway=False):
        """"""Sends the request. Returns True of successful, false if not.
        If there was an HTTPError during transmission,
        self.response.status_code will contain the HTTPError code.

        Once a request is successfully sent, `sent` will equal True.

        :param anyway: If True, request will be sent, even if it has
        already been sent.
        """"""
        self._checks()
        success = False

        if self.method in ('GET', 'HEAD', 'DELETE'):
            req = _Request(self._build_url(self.url, self._enc_data), method=self.method)
        else:

            if self.files:
                register_openers()

                if self.data:
                    self.files.update(self.data)

                datagen, headers = multipart_encode(self.files)
                req = _Request(self.url, data=datagen, headers=headers, method=self.method)

            else:
                req = _Request(self.url, data=self._enc_data, method=self.method)

        if self.headers:
            req.headers.update(self.headers)

        if not self.sent or anyway:

            try:
                opener = self._get_opener()
                resp = opener(req)

                if self.cookiejar is not None:
                    self.cookiejar.extract_cookies(resp, req)

            except urllib2.HTTPError, why:
                self._build_response(why)
                self.response.error = why
            else:
                self._build_response(resp)
                self.response.ok = True

            self.response.cached = False
        else:
            self.response.cached = True

        self.sent = self.response.ok

        return self.sent


    def read(self, *args):
        return self.response.read()



class Response(object):
    """"""The :class:`Request` object. All :class:`Request` objects contain a
    :class:`Request.response <response>` attribute, which is an instance of
    this class.
    """"""

    def __init__(self):
        self.content = None
        self.status_code = None
        self.headers = dict()
        self.url = None
        self.ok = False
        self.error = None
        self.cached = False


    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)


    def __nonzero__(self):
        """"""Returns true if status_code is 'OK'.""""""
        return not self.error


    def raise_for_status(self):
        """"""Raises stored HTTPError if one exists.""""""
        if self.error:
            raise self.error

    def read(self, *args):
        return self.content



class AuthManager(object):
    """"""Authentication Manager.""""""

    def __new__(cls):
        singleton = cls.__dict__.get('__singleton__')
        if singleton is not None:
            return singleton

        cls.__singleton__ = singleton = object.__new__(cls)

        return singleton


    def __init__(self):
        self.passwd = {}
        self._auth = {}


    def __repr__(self):
        return '<AuthManager [%s]>' % (self.method)


    def add_auth(self, uri, auth):
        """"""Registers AuthObject to AuthManager.""""""

        uri = self.reduce_uri(uri, False)

        # try to make it an AuthObject
        if not isinstance(auth, AuthObject):
            try:
                auth = AuthObject(*auth)
            except TypeError:
                pass

        self._auth[uri] = auth


    def add_password(self, realm, uri, user, passwd):
        """"""Adds password to AuthManager.""""""
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        reduced_uri = tuple([self.reduce_uri(u, False) for u in uri])

        if reduced_uri not in self.passwd:
            self.passwd[reduced_uri] = {}
        self.passwd[reduced_uri] = (user, passwd)


    def find_user_password(self, realm, authuri):
        for uris, authinfo in self.passwd.iteritems():
            reduced_authuri = self.reduce_uri(authuri, False)
            for uri in uris:
                if self.is_suburi(uri, reduced_authuri):
                    return authinfo

        return (None, None)


    def get_auth(self, uri):
        (in_domain, in_path) = self.reduce_uri(uri, False)

        for domain, path, authority in (
            (i[0][0], i[0][1], i[1]) for i in self._auth.iteritems()
        ):
            if in_domain == domain:
                if path in in_path:
                    return authority


    def reduce_uri(self, uri, default_port=True):
        """"""Accept authority or URI and extract only the authority and path.""""""
        # note HTTP URLs do not have a userinfo component
        parts = urllib2.urlparse.urlsplit(uri)
        if parts[1]:
            # URI
            scheme = parts[0]
            authority = parts[1]
            path = parts[2] or '/'
        else:
            # host or host:port
            scheme = None
            authority = uri
            path = '/'
        host, port = urllib2.splitport(authority)
        if default_port and port is None and scheme is not None:
            dport = {""http"": 80,
                     ""https"": 443,
                     }.get(scheme)
            if dport is not None:
                authority = ""%s:%d"" % (host, dport)

        return authority, path


    def is_suburi(self, base, test):
        """"""Check if test is below base in a URI tree

        Both args must be URIs in reduced form.
        """"""
        if base == test:
            return True
        if base[0] != test[0]:
            return False
        common = urllib2.posixpath.commonprefix((base[1], test[1]))
        if len(common) == len(base[1]):
            return True
        return False


    def empty(self):
        self.passwd = {}


    def remove(self, uri, realm=None):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        for default_port in True, False:
            reduced_uri = tuple([self.reduce_uri(u, default_port) for u in uri])
            del self.passwd[reduced_uri][realm]


    def __contains__(self, uri):
        # uri could be a single URI or a sequence
        if isinstance(uri, basestring):
            uri = [uri]

        uri = tuple([self.reduce_uri(u, False) for u in uri])

        if uri in self.passwd:
            return True

        return False

auth_manager = AuthManager()



class AuthObject(object):
    """"""The :class:`AuthObject` is a simple HTTP Authentication token. When
    given to a Requests function, it enables Basic HTTP Authentication for that
    Request. You can also enable Authorization for domain realms with AutoAuth.
    See AutoAuth for more details.

    :param username: Username to authenticate with.
    :param password: Password for given username.
    :param realm: (optional) the realm this auth applies to
    :param handler: (optional) basic || digest || proxy_basic || proxy_digest
    """"""

    _handlers = {
        'basic': _HTTPBasicAuthHandler,
        'digest': urllib2.HTTPDigestAuthHandler,
        'proxy_basic': urllib2.ProxyBasicAuthHandler,
        'proxy_digest': urllib2.ProxyDigestAuthHandler
    }

    def __init__(self, username, password, handler='basic', realm=None):
        self.username = username
        self.password = password
        self.realm = realm

        if isinstance(handler, basestring):
            self.handler = self._handlers.get(handler.lower(), urllib2.HTTPBasicAuthHandler)
        else:
            self.handler = handler




def request(method, url, **kwargs):
    """"""Sends a `method` request. Returns :class:`Response` object.

    :param method: method for the new :class:`Request` object.
    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET/HEAD/DELETE Parameters to send with the :class:`Request`.
    :param data: (optional) Bytes/Dictionary of PUT/POST Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""
    data = kwargs.pop('data', dict()) or kwargs.pop('params', dict())

    r = Request(method=method, url=url, data=data, headers=kwargs.pop('headers', {}),
                cookiejar=kwargs.pop('cookies', None), files=kwargs.pop('files', None),
                auth=kwargs.pop('auth', auth_manager.get_auth(url)),
                timeout=kwargs.pop('timeout', requests.timeout))
    r.send()

    return r.response


def get(url, params={}, headers={}, cookies=None, auth=None, **kwargs):
    """"""Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""

    return request('GET', url, params=params, headers=headers, cookies=cookies, auth=auth, **kwargs)


def head(url, params={}, headers={}, cookies=None, auth=None, **kwargs):
    """"""Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of GET Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""

    return request('HEAD', url, params=params, headers=headers, cookies=cookies, auth=auth, **kwargs)


def post(url, data={}, headers={}, files=None, cookies=None, auth=None, **kwargs):
    """"""Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary of POST data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""

    return request('POST', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth, **kwargs)


def put(url, data='', headers={}, files={}, cookies=None, auth=None, **kwargs):
    """"""Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Bytes of PUT Data to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""

    return request('PUT', url, data=data, headers=headers, files=files, cookies=cookies, auth=auth, **kwargs)


def delete(url, params={}, headers={}, cookies=None, auth=None, **kwargs):
    """"""Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary of DELETE Parameters to send with the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to sent with the :class:`Request`.
    :param cookies: (optional) CookieJar object to send with the :class:`Request`.
    :param auth: (optional) AuthObject to enable Basic HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request.
    """"""

    return request('DELETE', url, params=params, headers=headers, cookies=cookies, auth=auth, **kwargs)



class RequestException(Exception):
    """"""There was an ambiguous exception that occured while handling your
    request.""""""

class AuthenticationError(RequestException):
    """"""The authentication credentials provided were invalid.""""""

class URLRequired(RequestException):
    """"""A valid URL is required to make a request.""""""

class InvalidMethod(RequestException):
    """"""An inappropriate method was attempted.""""""
","@@ -55,6 +55,28 @@ class _Request(urllib2.Request):
         return urllib2.Request.get_method(self)
 
 
+class _HTTPBasicAuthHandler(urllib2.HTTPBasicAuthHandler):
+    # from mercurial
+
+    def __init__(self, *args, **kwargs):
+        urllib2.HTTPBasicAuthHandler.__init__(self, *args, **kwargs)
+        self.retried_req = None
+
+    def reset_retry_count(self):
+        # Python 2.6.5 will call this on 401 or 407 errors and thus loop
+        # forever. We disable reset_retry_count completely and reset in
+        # http_error_auth_reqed instead.
+        pass
+
+    def http_error_auth_reqed(self, auth_header, host, req, headers):
+        # Reset the retry counter once for each request.
+        if req is not self.retried_req:
+            self.retried_req = req
+            self.retried = 0
+        return urllib2.HTTPBasicAuthHandler.http_error_auth_reqed(
+                        self, auth_header, host, req, headers)
+
+
 class Request(object):
     """"""The :class:`Request` object. It carries out all functionality of
     Requests. Recommended interface is with the Requests functions.
@@ -153,10 +175,17 @@ class Request(object):
 
     def _build_response(self, resp):
         """"""Build internal Response object from given response.""""""
+        if isinstance(resp, HTTPError):
+            # print resp.__dict__
+            pass
 
         self.response.status_code = getattr(resp, 'code', None)
-        self.response.headers = getattr(resp.info(), 'dict', None)
-        self.response.content = resp.read()
+
+        try:
+            self.response.headers = getattr(resp.info(), 'dict', None)
+            self.response.content = resp.read()
+        except AttributeError, why:
+            pass
 
         if self.response.headers.get('content-encoding', None) == 'gzip':
             try:
@@ -431,7 +460,7 @@ class AuthObject(object):
     """"""
 
     _handlers = {
-        'basic': urllib2.HTTPBasicAuthHandler,
+        'basic': _HTTPBasicAuthHandler,
         'digest': urllib2.HTTPDigestAuthHandler,
         'proxy_basic': urllib2.ProxyBasicAuthHandler,
         'proxy_digest': urllib2.ProxyDigestAuthHandler
",fix a bug in urllib 2.6.5,[requests/core.py] fix a bug in urllib 2.6.5,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.9999518990516663,0.952121215978541,Minor,Minor,YES
